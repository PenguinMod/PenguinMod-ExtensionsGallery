// Name: Soup Vectors
// Author: soup
// Description: Vector math tools so you'll never need to do an arctangent ever again.
// ID: souputilsvectors

// Version 5.1 --- 60 blocks
// Part of the Soup Utils pack, which contains
// Soup Utils, Soup Objects, Soup Arrays, and Soup Vectors

// NOTES & CREDITS
//
// - Written by Soup (https://penguinmod.com/profile?user=soup)
// - Made for PenguinMod; should also work in TurboWarp
// - Used some code from SharkPool's "Sty-Lists" and "Variables Expanded" extensions involving use of variables

// ############    ############    ####    ####    ############            ####    ####    ############    ############    ############    ############    ############    ############
// ############    ############    ####    ####    ############            ####    ####    ############    ############    ############    ############    ############    ############
// ####            ####    ####    ####    ####    ####    ####            ####    ####    ####            ####                ####        ####    ####    ####    ####    ####
// ####            ####    ####    ####    ####    ####    ####            ####    ####    ####            ####                ####        ####    ####    ####    ####    ####
// ############    ####    ####    ####    ####    ############            ####    ####    ########        ####                ####        ####    ####    ############    ############
// ############    ####    ####    ####    ####    ############            ####    ####    ########        ####                ####        ####    ####    ############    ############
//         ####    ####    ####    ####    ####    ####                    ####    ####    ####            ####                ####        ####    ####    ########                ####
//         ####    ####    ####    ####    ####    ####                    ####    ####    ####            ####                ####        ####    ####    ########                ####
// ############    ############    ############    ####                        ####        ############    ############        ####        ############    ####    ####    ############
// ############    ############    ############    ####                        ####        ############    ############        ####        ############    ####    ####    ############

(function(Scratch) {
  'use strict';

  if (!Scratch.extensions.unsandboxed) {
    throw new Error('Soup Objects must be unsandboxed to run!');
  }

  let prev_extensions = Array.from(vm.extensionManager._loadedExtensions.keys());
  if (prev_extensions.includes('souputilsvectors')) {
    return; // extension already loaded
  }

  // ######  ##      ######  ####    ######  ##      ######
  // ##      ##      ##  ##  ##  ##  ##  ##  ##      ##
  // ##      ##      ##  ##  ####    ######  ##      ######
  // ##  ##  ##      ##  ##  ##  ##  ##  ##  ##          ##
  // ######  ######  ######  ####    ##  ##  ######  ######
  // These globals are used across all extensions in the Soup Utils pack, and the entire "GLOBALS" section should be copy-pasted to every extension in the pack.
  // The one exception is that the extension's icon data (the next 2 lines) is specific to only that extension.

  const vector_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIyMi43NTc3OSIgaGVpZ2h0PSIzMS40NzU2NyIgdmlld0JveD0iMCwwLDIyLjc1Nzc5LDMxLjQ3NTY3Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzA1LjUwNjU5LC0xNjAuMzk0MjYpIj48ZyBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiPjxpbWFnZSB4PSIzOTE3LjI1MDM1IiB5PSIyMDU0LjQwNjczIiB0cmFuc2Zvcm09InNjYWxlKDAuMDc4MTEsMC4wNzgxMSkiIHdpZHRoPSIyNjgiIGhlaWdodD0iNDAyIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVF3QUFBR1NDQU1BQUFBaFBnK1NBQUFEQUZCTVZFVkhjRXdHQXdRS0JnWURBd01FQVFNS0FnSUZBZ0ozZDNjREJBTUVCQVVCQUFBSUFnSUFBQUFHQWdJQUFBQUFBQUFEQVFFQUFBQUFBQURiM3Q0QUFBQUFBUUJ5T1Q4RUJBUyt2cjZvcUtodkVCc1FFQkRPenM0ZUhoNWxEeHVLaW9waUVSdTV1YmxVRVJ3OU96dGdFQm1XbHBaMmRuWnFhbXFHaFlWSElpV3pzN04yZG5iYzNOeUxpNG8vRlJwTElTVkxTMHRaRUJsaVlXS1FrSkNQajQrYm01dDdlbnFCRHgyMHRMT2xwYVZyYkd5bXBhYWpvNk9BRVIyNXVibi8vLys0RUNXeUVDUzNFQ1hKRWluSUVpbkNFU2ZHRWlqdDdlMzQrZm4xOWZXOUVTYkVFaWl0RUNQQkVTZnM3T3k3RUNhL0VTZXdFQ1N6RUNUcTZ1cmc0T0NxRHlMOS92Nm5EeUxpNHVMeDhmSHo4L1A2K3ZxMUVTWDgvUHorLy8vbDVlVzZFU2JVMU5TWERSN3Y3Ky9MRXluTHk4dmMzTnptNXVhK0VDYmUzdDdrNU9UbzZPaGNYRnpPenM3UjBkS2dEeUgzOS9jQ0FRSGo0K1BhMnRxZERpQmdZR0NqRHlHd3NMREl5TWlIREJ1U0RSMjl2YjNZMTllYURSK2xEaUdvcUtoOGZIeHRiR3haV0Zpc3JLeDNlSGpBd01DMnRyYVJrWkowZEhSaVkyT2tvNlJtWm1henM3Tk1URXpFeE1TNnVyckRDaU83amk2SWg0aUNnb0pvYVdseGNYR1lsNWR2VnlkblVTZElSMGRnU3lLTWpJMmJtNXhWVkZSMlhDZFJVRkRBa3krTURCeWduNkM4Q0NFVUZCaDdZQ2hWUkNXekNCMUZOaUJDUVVBNU9UaTZBaGVBWkNtZmVpcCtDaGlzQUJNbElTQzBpU3l0Q1IyWWRTcXRoQ3lLYWlqdHo5UEpDU2lUY1NycytQaUZhQ25VYVhmNDV1bnE4dkkzTEJyanI3WDAvLzZtZnlyUFUyS09iaXB0Y0hEWmo1Z3ZMaTIvSFN6QkF4bk1QRTY1YXlzYkFnVzBBQkRKZTRYSEl5MVRQUlB0djhYbDdPMjhNa1BrbmFiSUtUM2NmNHJEU1ZqeTJ0MjhleTNCUVNxM0pEWnpOVGRuVUVxeUd5elBFQ2pneE1qSVlXN0JXeXpKbUM5eFV4YlZvcWlHSkN5NkxpZzJCUXFDWVJ1MlZDbVZIQ3FFTkRSb0N4YTRvVys4cW9PeWxsamk1ZXRTQ0JIWDBNQ2ZoVXpGdDVaOGFGK1hieG01bmk2RFRGTGEzK1ROd3FxZmoyK25jWGVvVUZ1bVBFa1E2KzBMOHNxYUFBQUFQM1JTVGxNQURoc3hGaEVMQVFNSE9DRlBQeVpZUnl0aERHbHhGbnNzcE4rUVhhalFMSlcwaExLL2ozeEs1MXJJNEVPcmJudklxOVR3MTczRDdZTFBxZkZqOXQ4cnVBc0pBQUI2TFVsRVFWUjQydFNZWFd2cTZCYkg5d3V6TytWd3JnUnBZWVBNUmJWN09yM1NsblpYdWk5dGIzcWpiTFNscHdSUjhTVXlLS0tnb1BVdGFlb0xKQm9RSTRLY0c3M3FoNUIrcnJQV2V2TEUyTTV3RHM3ZVoyYitwdEc4Wi8zV2Y2MG42WnMzMzE5YklJZmo3UTlPcDlQaDJuR3RhOGUxczBNekVpM2c5Mm96VGc2SEV3LytzSTJuZXZQMzFkYjJXNmNUb3ZLZzNQNjlrNU05dC92ekllbUk1RHM2T3JWMGhCTmJmM2lFKzdqZDdyMFRQOHpoOFBjZU9KSFQ0ZmdiOGRoeU9OK3g2UDBZeE9mUGJnenErUFB4OGZHK0Q3U1AwalN2QmhxUFlWSXRzWjhTVEdQVk8vWjZ2ZnY3WGpyRzV6dUV3NC9oUEx1N3V5ZW9qeDgvL3ZJTGVNanArSXQ1QmMzN0FaM3NjcjE3RHd3K3VUSCs0NFBqZmE5WGtpQXdUVlBIOUZWcnlzMGFxa21TWlpqV1JLdHJ0STlXZzhNQUVCSWFTNUp1R0RNZE5GT3E3WGI3L1B6ODU1OStRaTUrditmOU85ZU9BOHZvcjFCRTRBVXdnaHNSUVBaSnRRTUlSV3ZLR2tSTUFUZGxNL2ptdWw0dU14YU1HTmVMWlUzVlo3b3ltNTJkRmM4QXlqbVUxZTdlSGhiU08rZjJud2ZoTFVMd2ZNSmFnQ280T0RqUXhocmVMVG9Bb3BTSHkrVnlDRnFTN29jcnlYd3V5MFA1dGV5R01mY2RMdTlCTUJzT213aUU3Q0tSVjJaVkhhc0pTdkdRTlJlWDg4UFcvNjhzdGgwT2RBTmlPRDdZMTlEVG1GRzQ0MVc0R0lkZERNaC8weEQzV1E2WHk5ZUgwc2ZjUUlZeUM0N01BbVVJWkNUSjYvVWRmMll1Y2REdzg3MWhiQU1IcUFtMHdzRkJVNjZ0SlhVVkFlYlNpbjdBUGt5UG9JSDFlN0F1M0lrZnc3OXdZaHROTFRsdm1YMHhKTmhrSk9xNys5QnRBWW5MK1IxaGJIMXdVWGNBUHh4b2NIMXNDRU16bWJZMG1rRU1iTEdiZWlBVkNvVUhMdHZQTlQzK2p1aUVLeXIzTmp3bUVwVzFYUzhBSVkrNHZuMG53U0hqTFRqaTBPZURjUUZLWXNrVGhCWlkrWDh0Zml0Z3Jzei9wQUo4TW9YZkVvUEVXZG5zeEdqSXZIaVlUYUJ5RE4vUm50dURBL0MzOU1pUFRvOS9EMGpzMTJDUVFEdmNyelVBTzRPSE5RWXNPcVo2SGFhWG10Ui9SM1FFVFRaT2pFbmhwWDJZVjZobVZvTXpBWUV1NGpzODhidCsrRllrUGxDVDhNMTB0U2JmRCt3NW9lRHhZdysvWUl2ZURKZzBuVXhKM1RXOVdEVFhUUzFOVEZtQVZsQnNqbm1nbXpMZHloOVpZQTVsSXhsVjNYZm85cnUreGJQcmx0UGpQanJUMWViOW96MGJMd3hnbFVCOW5RQkNXRU13R3NGa0NuOTEyWXhXc3UyalY2d3NLbXRFVnBZak9uUnZacGRkV29NYXpwczFTYStlSHJwZFAvN1JYdkhPdjNlOEQ3VngvMWlnaTc0b2diWDR3Zk04L2xYc1BQRFhVZFZ0ZWJhU2JVWm9WcFRKMGs1bnlnNWZ1N0IxR2pzUmhNS0tlU2lEUS9aOVJ5ZWVQK0lPZElWUEh3OHpjQXQxdXB3dEkvWUsrSzBDNEg2bm0yY2M0VVp0elk1MU80M1BvY2JOQmZPSkhZZk9KVFlrOUNHNzlMb3pURmE4ampoYTNrLzRhSXpIRng2R21uRjI1Ti9aMnJ4dHVrOW50Y3owcFQ5ZlVaaStOQUhCS3p4ZzdPYVlSdzFOTTEvSlNCSVhQQzdCQTVOT0g0bit1R0FmM0pNT1FsWTFRalFrUU1Dblh1Y0o0TXpOdXl5c2lLeHFPbE9RcGJOZHo2YVBWeTczcWJxY2RFZGR4REd4R2orSHdPdGdEbUlRcHBpZkF1YmZHdmZOUjJkNGNEWm1zNW1pS0ZWVWc2bEk2aFE3cVBacWptdGhNKzFhaFdQZ1hXUm1HTHJPUUFFY2RCQTg1TndQSGlBems2blZhNmJUZFNTcnFnWWJUZXVQbXZmUTgyR2pkdkVQOTZrK1dZeTZML282cDJCYVljNHhBSVhCUGI2WElnQ1dlRVJnTUFnTUFjWE9nbDZwRHlxRFdxUWUrNExsZmgrMzJ1QlllR1lHY2hrVGxTWWlLZFFuTnBQWSs4cWFtZWZkWWVmMG41dFV5dGFubjZYdVd1c2pPNWdsTVdjYWpRQkQ0WkdjWUQ0Uzg1ZHVlTjF1RkZuVUhRb0drendqRVNBU3B0MHlDNUhpZVBySW92OFNHREpxRnh0VlBBZTNDbU9DTGI0KzZiTDAyRHhTdDZvYTduNDBVay9kcmcyTTRYUzM1ZWY1YWlpd3hnZU9BZXlRUVE3Y0RkZ0xPSVNWMFUyWHJ3bldLT1FXRTBTMWdSOWVPc3hBNWsvTERsVzJzY05SQWFFaTU0dEdHWE1pR1NpYkVTL2JpYTI1d2ZKb2tmRWUrVGN3eHM3dTJZTUpZL1ZZd0IzUm5ZSWZsckpKZ1pVRnRnV2wwZWkwKytod1RKK0JtV085a25vR3hVNGhzZmJBazg2dHdHSmt0Y0ZJc0tiQmZZRC80NW1oMzlwVVZPaVNqbVU1ZzJwSHhTZkRod3hhWkQ1YVdkb3lkRmM3LzdqQnZ5OTNkdnVEcDhYSTdJNE14QUkwSDAweUQvZERQa1NZL2RFd2xFYTcxU3UxK3NXcXdRWUJxaFVPWUtXaUtkNDUwUDl3WUN3bWltSTJLMlN6V2ZnaHhrbzlGTFVQQ0xsUlZWWUJTM1R1V2JYZEtzR092UllSZ1QxbVJKKzFrdUVnTThVYm5sUEptQ2k2OCtmSmJBTVliN1k4dTduWi9Ia0JMSmdaRUFTMDAzcGhBQ0RNY2RMOGo1elM2UFJiY092bGR0RzBBN01KTlkwT3Ivcnlxa3RhZlJJZ0FBRVNJaENGU2o2WlNnZWkwY0JWT3BudGxiRlZ0QmlXY3IvVG9aRE43amxHSHAxeUw0YmtrQmdpdzgxc096cWtNT2tpRDU3TitlSjVvV1kzZ2ZIR2MzZ1RyeEVOaHVMNWVUR3FQOHJzTFZtbC94N29CdldIZHI4bFZ2SkNySy9va0JYSlVJcHRDSnJTaW1OQ24rVytCMm5NQ2tLbGtrZFZRTEFRRHllQ1Y4RkVLbGtSSUNTUW1NMm5BaGRmUUYrRFloRUNOekRpVXJhU3IyU1pXMHlyS0xvRU56SFdHeTBSemlhSUplUUZ3SXBWaFNvS0pXbHlZWXBabkxPVUx1YUQwc1c1ZnlNWWQ1YzlhZklNRUFERTgvTjg4cmhrLzNFakZKTEJxcmRkN2dueFpGNXN0Ykh6ZFZnaVM3MlNJSWc5TkVJcEp1UkRpV0QwK3ZMaTV2YjI5dXZYMjV1Ym13c1F6bTVnR2VLK3ZiaU9CaE4zNFNSRUJaV1N2NHRlM3R6OG11enIrRURSMU1helRrc0kzU1h1UXBXc0dJc0JOR0pDZlFsS3NOTXF3UjNFY1Z1SnJRWWUyRjNBSXdCc21Pa3V6Qmk2YWprZDNoQkc3dGV3YUR6Q3FaNFF4YUNHVlRIR0hxV08wYUdVL3BJSW9jSmR4bHFRL3g3WVhNakdldjFPbzlQckY5dTliRDZYamtZaWtXZ2dtRTZFNHhpcnlHTHBnUXRpMkNTeVdCbmhSRHFkRGdhRE1FOG5VcWxFTUJDTkJPSXRSVkxoT1VMV2pIWXBud2hFcmlQQmNGNHdxMHBBYThHMXdDWnczVW95bHd2RmNRM3JJc0NEaG0zNDBsVzVQa2NjM1lGVVNnUXFtOEs0RXdXaExOVUJ4dlJlbzVFVEJ3WlYxUlhtQUFpbmNoY05oQVVvOW5nNEY0YnNZQWR0ektCbktKTFVFS0szLy9yeU5aSVRldjNHVEI5citJQUU3d25XUzhUallJbXYyV05Ed1o1VEVvVjhMb29sY25NZERRU3VVbUMzRGxTRHBKU0ZaRG9BalNRU3ZVb0JVYWd2RWxZY1dDS1Bub0RxQ3FaelNhd1lCRklxZDdCdFY2bXJHbU41c2xoTXBGWWxuMDF1QkdQTHRSdE9RbmNUVzRyYWJHb3FIeUFsRlZ4Ylp0MC9LK1Fpa1VROEh3K2xVcmtRdXkxWVd5bFZkYjFSYk9VdnYxeUdla1Y4L1MvVXU5aS9ucCtlbnY2OXBpZHczV0xlcmJPdXJJNk5ha3NJM2tESHVMaThqa0R0SlBHVWFJc0lBRXJmaGVMUWIrSjVybmd5aEVyaW1tUXFlSlZPc1lVS05KaDJGYm8zSDV2MXNhUzBSTUFVMzh3WkNFT0VHaFFoMiswR2RDVWNOaFJkVlpWZUxDdVNUekViZVZGSUJxT0JSQ2pQc3BVUHBhL1RZcmtsM0YxK2ljWWE2bUM2ZUkzZ2xaQUphVEd2TjZWKzVlcm02eGZzSnRSSkw5S2hkT0FxbUlwam00d0p5WEE0SEdJUWtnUWpCVVdHUlpoUDNzR1B1MVFPTjRlelFBUEhvRFlNNHpBSXd6MzNXajB4dEJHTWJZQVJFdG1ZMVMremN4YmJEYldtbHl2LzRkVk1mdHJLc2pnY3BWdEtTWkY2MDFJVzZVVkgzVktwZTlHTExHcmJHR05zUm84TVpoSmc0d0Zzd05nWU1EWUd4eFBHS1J3WmpCVGhDRUVpb2JDb2l0amtIN0N5cnpVa08yL3NOUkl0WmRIbm5IdmZpSjFVREtuek1DRmdlTzk5NzNlR2U4OWhKT0N4ak5nTHliUjkxT21acFF6QkgxWXdHUFNNZEEwTmphMkdYNUlhcEhzbUdiQjFESzJ2b1lRK1lwTEJIeTh0TGVGN3pvNUtPNkd1dGlFTXQwUmtkamNHc1JWdUJ0Sm5kSDdBNS9GTVRrN2lDMjF1YnRMamdadzBHZHJkblo0elF1U3hlVER1K0JiS0o2Q0ZOWXdxcktCSlF4cTJoMXB5ay9zL2hueVF3QXNadms3Q3dKMTVYandzdUcxejdORUVQZDN6eGV5dW9kc3o0SGE3WjVtQmtOMmVicnFIaWV5N0pUSjJsd0lMZnlKVnpKNWdhUUxWQnFZRVVERkd5a29ld0lDTTROMXZQbXhOQzhKb0M0VEt4UXk5RTRxWXpXak1nNUhXSnBxUHpHYndoVmJMQlRmRWF1Y0laYTQyWi9Ja21zNXNZdlZLSlE4RTJyVjVZK2luRmxieFAvejEzLzhOVHJ0WXBtS0ZUalpiTGhlejBRWDNiQkNmaHM5bURMajJEbmVkenRrQk8xb1FEYlJyZC9JYlNiN2tOSWdIZDRlenQ2L0NwVDJpd2RJd2hCL01sL0RjSWZKaUpud0xRUHhyWXhnM1JneWUwUFBpcTJmbFZWWk5sVFBUdmhGbVRxak1CRE1halFaUGJPY3dPam5XRmVnR0c0SDBGZHVFSzk1TFVZaUc3SmZNRk1DL2picy8zbTlsMWZxbi83aCttMDhYbnJPcUwzdklObGUyRHN2SnFDdG14OHFodXkyWVBGajFPTzFCTGxsSXNxRUIyMGdYNmhzVTdrd1hqejY4V1pMYm15Vkc1SXl0SEdpcHQ1MmlqWDIyOU1EcUhaQ251eUVOemE1bFRySXBTSXpQc2p1NEZDdVdDekZEOThSRTE5Z1FsQ1lDRXFMaTdQYTVkbmJzRkdNQ052ZDhadk5nYnh2Vzl1Q1BVQ2NlUWlXSVVsejQzK3hQTFMzaDcvM2x5YjkyNTExUktQYUlSUkYzUXRIUFMxdTQ1WnhKdTJLek5wczduZmFBTkkwa1YyQXhHelFFeHREYlNScGpuclhrRHRTQitXYy92K1hSUTAwRzJRZ1paUytiM0kxNWpFYTNDOHEyQWpEWjNuK0dPamtMYjIwQnNlem1ydHZRUGVLWjlYbWdmQWtFdWdOUXRvMk4wYW1HSmlaM0MydHp2dEFDcFBFeW5ITGYvd3BYN3JDZUxERVlVTWk2RnRZTy92bW9wWjJ1aDM5Ny9Ea1pMYUNYQ0V0a1ZpZUE1Uk1wVkhwaEhpSjhhTkpJQm9ITDdwNGJoVFJBc3FCU0V5OTB6R2xmaU9JRmx2YkQvaU5hNVBEVUFRWE1PMllVUzBxSE85R0ZXYnQ3T3YzOFpDK0IvUENOOE1PMy9sd3VzWFZRbUxZNW5YT3h3dXJhYmlZYUd3MEVFQVVhdXRQQUd1U016R2EyaUJpTzJNNGpicjF5WllDZndNOVhQOWVmUG14cE4vamhrOGZWNjg4blNRcHdXV0ZYaWJXMElCVlVTc3daazFCb3h1dytLQkM3blI1RGx4VDNiTUVRTFNmU3RPcWtySjlaVzNBVlpNdXRMRi9jN3F4R1hlaGZ6cUFyQTNySSsybUZSU2hJTzJjL2x3NHlrQ29NbnFBcmVYQ3dDblZNMUJhQThyNXIxRERwUmpGQXpnY25ydXhqU1NkMXB3aEdLWVdMaDUxazhxUjRYWXM4YlZFWlR4Ny84a3YxZWd0M2JDUmxZTE00TCt2czhUUGhjaHBTNjRBTnFtL25hR0JzZEc0aHVncnhNRlhhSjNyd1pJdUhlNGViSVlRMUJNOXlGSDNMaDJFWUZ5S2dwQzZEZmI1UTNzcGgrZi91RFI2VWJlRjRkK1l2Wm1LR29iYUpVYU52K3ZuSlNYS3puTjBCVDBwSHNRQ0M5VWVLT2hsc3ExemE3c012Y29JeXNvZWZyK3ZIeDVIV2xSR0pJSTZySWh2QkVXQ3dmbDVGR0R6QVFRRTg0UUdzVmpGQllHRVVteTlRck1CSHpMMkN2T05zTHpiV2RzT0dSaWVuMDV2WkxmOUxldXM3c1VqRG1QTGg3VkhpWkpxdDZqMXp3ZGhhSnJtS2E5WXNiZU9FMmY2MDFJNFFXanA4VzVpN3lXSHg2cnA2dk81d0hMY0c0eDdCaUJ4SEl0WDY5UlhXNDN1OHZaaW4va2RGTldnaTdJSHlMZ0N0YmJkb2FDVWhOQ1h6L25BeFBRQkZBbGJYM2VqekUwTmRSbnZNVmRoRWxVTk1JWUhUbGk3ZmlnOG50a0Y2SjZ0ODQ1TUZjdHdZeHpXTzJMY1Q3anpNOXNLeHMvT01qbkJ1djVMYVNsMWQxMnMxeHdiWXJXQWNyNit2ZzdnQXg5VTJUZVB3cVFwWm81ZEdqOWhkQzgwcy9KZlRZZnVDZTh6Z08xbE1ua2x4NnhlRVRrdTRTb0p0cHRJZkttMUx2V01HbGhvRHVBM3U1N2l3ZDZ2WUFoZTZyamxGdng5Q2ZmN3FHbEE0bG4rTnJ5emZIb2JEc2VGd3JCK2pQbGpEbmZzSk5jYWt0amNmWE9OREpCWE9oSGR3aENFQ3pFWml1MnMvb1JvL1VVenJKR2hrcDZUcTlyUG1XcVBwQm5tYnhDLzJLQzh2NnRYYWNqdytQTHl5dUhoYkdCR0FzYkd4REgvRzRhaFY2eGNYbDZnOUVGK2xzaTJOckJHT2xOZ1hUQWs4aE5hZ09KYVN4NjZQMk1yd1MrcFdqNlRnM0UrSnpUVXBhT1J6Nms2L1grcTFzazRybkJGYmowZVhseGNYMVZwdE1SNC9QejhmWkRBY2Q2Q001Y1dWZVB6WE9Qd3hCdVNTT2tZVnNXWEtQd3VITU13SFJCaVEvSTNaSEpxemtLWll3b3JIeTJPU09LM0VwdDVZOE1rcG12N2lDQWNmVE1CVFlmZU1RRlEzRnMvUFQwOVBMWmErd1R1QkVXRXdpQVpvYlhBNHZyaXhYcXRXa1FnR3B4UnZGaXVHRnduSXR0Z1l2UUVqckVDaEdyWEljUjhzU1lOLzlBOFB4TG13bkFUckVoRUtjandRSHVPd3Zyd3kyR2RwdDFyYkxjVGlMcFVCTUZhR2dVWGZPUnFHSWdCU3IxOWZRMkJOS0NhSTVPRkQwQWFESVNZK2tVUk9qU1RIVlNGSklyWE5aMG01eUZUQ0lFMXh0N2xFRFBVcWVjWWdDT0wxYTQxR080NDBCQmdiQ09QUlhTaGpCWVV4T05qWFo3RllyWEF1WUFKSWFuSWtEY1plV1k3aE5QQkRJSkJyTnJYRlF6TUhJWTRSVmlvSklYeEt1dUNIaU1HeEhEOUhDaWFUYVdwS013Nm1VQWJBV0g5Ni8wNlVJY0FBR3NpakhRek8wd2RucVJFVGdISjVGZVlkZU9ZeDZDMllFeFNlMHRSSEtBSlMwcGJQVHpNaTlGZjI4YmQ1OElYRVNneVlGbXFMS3lCYmkzVmNxOVVBQnpCVWhSckdjc3N3SGp6OFIyTmxFSTMyZHV2NHVHWnF5cVRSa2tvRzQ4U2tWaWNvcUpYTHEveVZPQjZodW1jK29oYVdYc0wzd084ckttTUpHaFVCOGVBSUNSQURnSUFVRU1JcE9jWHIxMTZ2dDZlbmg3SFFhaFV3TUxVdTMwWVpCQU9sSVljaFNNT0NOTWkwYUJxQ2Nub09YQ0RHTGlNWERDcjErc1UxWFBzbDJxdkxWOUtRQjg4Q1RPYmlVQjlUaDVCbktUNWMrdW1YTHk1a0FCd1FGTTRaZ0JjdnZQMW1yeGtnTUVFSWRzY3dtREtPRlRDR0ZUQ3NBZzVHQkhob05IZ1JQR3FSRDZFNmE5eXFaSFZNemwrMitrV2RXNjBxL0hKdEVlTTNKb2h4OEFTVEY2Mi92eDllWnJQWiswVVljTVczanhrM2xkRWNCaG00elpUSjFFTVg2bjJOQi91RWRrcDJqdGMxU0E4S0xnNU51bGs0aG1zZkZ6L0NhVDR5VjdSaURJRDdmc0ZOL3g1Ti8xNlAxdHZiMjluWmlTaFFGejJtN3dyajI1VEI5YUhSc0d1QmNON0R6SXRYMndsWHJ0ZmhMZWowN3p2QWREcmQrL2M2SFh4RmR3Zlc4WDRHckFQZTFESFRNVU5mQzZiajl3NTN6MS9FQVVpUUxKckFZRmNrd0NENmQ2a01xTHErRG9QaE1Ka1lEaSt5Nk84bkdNUUM3bTNtRXg3czA1ZHNSa1FpMFpERDZPOFhZSmliS3NONlJ6QnVLaU0rL00wd21ESVlqVjZTaDQ3MGdNWUYwTnc2dUlZVUxBUWtmeXlNRzhwWWlYK1RtM0FZNXBzd09BNFJ4aWYrRXY4ajl4SUdvN2UzT1F5V1VKVXdNSkNQTjRJUnVTTmxLR0ZnemZWN2xLR0NvUmUxSWRjQXgvRkpRb0V3Q01qdlVVWkRHT015R0xldk14NTlVUmxxR1BRa3Z1NG1qV0dvd2R3ZERJc0tSdVRwbjF1YUErVXd4SUpja1ZDNHJ4QVVLeFRuVnRGcHNOQ1lrdHhGRklkSWhFVlNuZVF3a2hqd0F3RVFBcDBlUC9UaXpiTzdsd0lGOHhCdmp4ZEtETk1VbFRqa0hWcmgrZkFsSzZHSUl3dEhxekR1UGZnN3dZaDhCUVlXNWxZMURJMENobGVDb2Vjd2V1VXdDQWNnWUhyUUNaR0NVT2kvRG9QVld5SU03WGVCUWNvNGpueGRHYUkyYnNEUWlEQjZ6Q3Bsd0dQdmtHY1cvcHFSd2laM0VNRXZrS1lBZytQd1VoNFJZR2dGRTFqZ1F2S09ZUENZMFJDR1JZU0JpMWRLTFBEU05sU0dtZFZkeXNDaFZ5dWpNUXk5RW9aYUdiUW0rU05nUFBpaU1pd3FaVFJ6azZrcG9RZzFONDhaL1A0RmhjaUVvVlBETUJPS1RyTmFHU1lWREswQW8vMzd4QXhJS0lzeU41RkNCbE1Hd1JBY1JZSWhCRkM0QTFFWnZZMWdLT3J2aGpBSVI2Y3NZdkFLUXhZemtJUkNHZTE4WVlKVnhtMWcvTkJJR1NzU2pEN0Uza0FaTWhnbU9ZeitKakJFVDVHcnBKa3lSQ2ZwYkFaREZqK1ptMWl3NHJvdGpIdjNtOFlNUm9PZHFsM0NvVWl0R2trWi8yZm1XbUxhU05Md2FKVTk3WDJQMFY3M2tqbk9hVlFHSElMQkROZ1p3d1pzajJPWXpZenlnSm9RWm5BQ3lTUTdtVmNlMGlRVENjMml5SkVQRXc0V0oxL2NXa3VXR3N0cUJiVzYvWkE4SURoazFkS3FMejVFMmdQUjdsK3ZkdHZ1TnNqWTJjMGxtSWE0NnF2di8vN3ZxeXBudENNWUZqTzg4NWFZZWpzSjZLVHRENFhDWFRNRzJzb2swV1daL09GOXdZeUVBSU51Q2s4M0xIa3pNeWdjZzN5dkp4WnJRVU9BTWV3TWhxVVhMY3hvdUN5M3h0b21vQnlOd0FEcnJBRjdtWHpZcFFOdE1DTmhZMGJJdnR2bEFFYVkxaTFsaHFkSk5JNWdCczBxUWtxOUhickpwSnRtT0hlVEZzMzRzRXRtL001eW9BbW5NckhERVd6MVhjMWx3b1A4bURNWWRrQ0dXbTNHbUFCalVqUVRnZ1pEWkhTeUZZeHdrMllFZWdlR0N6TWN3V2hycmtkcWhnV0hBeHJ6RFRmT2lURnNLeE03TTBhZFRGZTRJelArOU1jVE11TjQyYVNtYVh0ZFpST2VUbWltdDlkSlA3SkpsMkIwNkNhdDJZVHlvcUxydVlyTmRCVXJSYTB0bTR6OXI3UEppWmh4N0d5U3pTQTBVeG5nN2FTUVZUTVpWVC9RUmp0a2s2UHR1TmZGam5lZlRmckFqUFpzVXBFUVFxL05lcEtDb2FtUmlLUy9rdmZWQ3BUMTVQOVJOam1aWmh5UEdVRVZzSWcreEhnRndJaHB3QkowK0t0aDdGNlhpdThvbXhTT2wwMjZac2I3cDQrZFRiUUlUUDlDQ2h0UUorR0NEaSt1S1JnREdwSDl0WjVtazNHbmJGTEw1dFJzNlZqWnBHdG1OSVBSbWswQzlteFNJWmYyTG1Kc2tsSGtTY244aEhFOUVZdFYwWHFvejlsa3NxQkxzQmJ5Mm5HeXljbVlrVHdxbTlBL0ZJeXJHQzhSQWMyUkY5OWpaUmxLV1VWM0RFY0hPdHllVFk0RXd5V2JsQmZKRzg2WWlXTmtrNU16NCtoc29wSGhuTU1Ld2FJd1ExN2N3SFhBb3BCQlArQjRUN0xKdUVDanBiSEdTaEs3VGZyU09FNDJPYkZtSENPYlNHdzRSTHVLaUlGaGd2R0NyMy9CWm4relNaYmZyTjNHOFdOa2s5NHh3ejJieUdROGp4Vml5QS9vMko3aE5CQkRSMU83dU43WGJQS1p6TUM0QksxczhPaHMwbE5tdUdTVFBVcU5qVlVZUkptTzdRSUJBM0NwZ3BDZU9KdU1kY29tbkJsM01HZEd1SC9NNkpoTkJ2YXN2WEU2cEM5K3M4QkE2L1hZUVJYTnZvRUY2MjgyS1JGWGd5Nm5zQkxvWXpaeGFLM05ZR2lWdkp6TDZlVzh0aGZjbzJ5ZE9nZ1A1c0Yrd1plM2Z5MERGcTh4Vm9KOXppWUUvZG5uR0tmN2wwMk9CdU5BcjhJb1psRlV5c2hhc0NaZmdrSDU5RXFGTVdQdXBnOUZjLzhBNzlHYVRheldPdFNUYkZJZ3Jmd0tXRHgvUDdQSm1kTWRzNG1lc1gxS1lrYXY3UjFlOUFFYUdXb3pvdlR6Ti9jM1lZemh2cDZiRklwbEg1S0FGMHF5cjlua1RDZG03T1Y4VFo4WjhhbmE2dTY5RWZ1M0h2K1VnakV1SEN1YmVMdk1KcE5aU0VYcUxyd1BheVcxNGtHNW5PMUROam5USVp2c3lSRXg1K3NQSGx5Y2c3OXoycHFSK3ZuK3JiOWU0QThndDJFbE1XSFBKc085emliNm9wUjU5cEs4RCtoRkxhdEwwTlVrS2FPNVpaTVB1bWRHMGpXYmNHRVlXYnkzc2I2ZFN1SHRIKy9OeWROaDA5aDZlZmNKQitNNVZvenBmcCtiNks5MlNTUmM5bmkwckNyTlJtN2Qvd3FoeU91NDN5bWJ4THNGbzRObWhQeDdUQzltYm03U3oyVENjUERXMDI5TmYzZzZYVmVVUlFiR0E3QWE3WHVndzY3bkp0MWxFMU5SakxRLzV0RmtZblhlMUZQcmo0ajlTenRsazNqaWd4TnJSbnMyWWNTWWUwRStwcXJVNittbFJOS3NHemdOaVdBaGJiN20vU1NWN09tNVNTbWZCVDBvdG03Nm1lblZJSmpkSEs5TXBmN1c5OFVtNkhaek5sbm9GVFBhczRsT1ovc3RnY0pjV1FNN0hnajZsOUtHd2ZaQWVRMmhwM1g3dVVsaFp5ZXJxeGxWemNuWllzZHNzbE1xRm92NUV1c21jazR1RWpBS2VWVkNVVjgxVTNZOE45RzVKVmRXUW51Vk90aGVKd2ZhVTJaWVpVS3I1RXZTTEpKcmpZT0M0QUkvSytCMWNoTUhHdWNtcGJ3dW9RaVZYVjgxVnk0MnVmRjVxSGVFOGd5VUVtdmFlUXBHYVJGSkdVQmp2SXordytLcGxHcy9OL0hrNmFOSEdDZElJNGtyUnR3cG0vU2FHUXdNTXF3b2lMaXg1SGM2TjFHcEcwWG5VbWxSSlRzRUNtaUNoNzlkdVVuSHJlWnRhQlRwTDZoZWVrKzB5T1o4T2JuaUJ6Q291ZDlmSGN0TlNlWERSL1JKNUkybjdkd2t4eG9iVnFqTkdIREpKdDB6NDlRWjkyeEN4bnVmOE1MNVRoZlBUbWpENEZXeUE5WWMwSGxGbEhiN1BIMVdMVnAzdXZqMG9lQlhMU3pJVmxrYzBLRXdvU3V2VUZVejhUcXpjNWVNY091NUNXOXVkdzE3Tmhsb3RlUGRNNE9Ba1hZeFhXVEFYNFBUZHJuVHBYRVQ4a3dKMHFPQ2tqd1RwZTBGdUdRbWVlYmUzK05nOE9sL0F3OUJOWExNdlk1c1l3Vk1lNGxadS9zUlZES3drZVpiRjF0bXk3bUpVS2xiU3FoVE5qa2hNMXpPVFdDZEVZeDIyZTFPVjVXTjdWTzhRc0hRNlpUT2djYlVRNTVodHZ1RG9tOUNGSXdkdHZqb0JsQmhmcjdFcDNVTm9BYlJLRE52djRnTzY5Z0lqUE9ITjVSWTgrNjRMajQ3ZmR2c1pNZjd3b3dBS1ZHWW1ldWRMajYvODdoTzduU3hUVXIwTXl6OUlEU0dIVjRJMTR4UkFnYUwvTkdQNFNtNERVNGI5QXZHYXlDZ1BQOUVieHRZOFk4WEJCaDR5WFp1TWpFUnExb1o0TTYvK2dFRzF3eG5adWdVakJYWE8xMWlwYkFCZytWbGNCNklzVXo5cDBoNFcya0FRMER6QkRJNE5GZitpbFFKVkpFZ0VkcUNkeHMvSzE1ZXdXazdNMkxGaUlYRzVkMjQrN25KeVpqaGxrMnlGSXkxOWp0ZGcreEdnbGhmck1CWVZXdXRUZWE3K0RmUXVqSkdpRUUxQXFXd0FqVEo4K2xlcEZYaTVSdEZ4TkhVd1grS2w1c2NETkZhWlZSNUlORDRwajdObVZGcnl5YTlaWWJJSmhvZHZmdWRMZ3NNUFByWkFmdC9FWHpiR0ljb0ZsN1ZZbnRvYUo1VEFlVFRoTWJTVkNWZUwrZlFKNkM4SVhEaTRoZFRMV0JVcFdUSzRzYUd5YkFvNXdiOHJkbmtSQUxhcWhuVzU5UWtzanlOYzVQV08xMDJNRWI1aEs3QzRuSnIzUUFqSWFoQWRtY0N3QXdPeld4VGxSQmltSUFGcnlnaUwvSEd1UW5VNGF4czRBUCtxMU12bERVeURrM0tEU1I2VlNZMlpqaWNtOGhFRDlmYzduUjVjbnpMQitPSmltaXpNQU9lVGNRaWJvQks4SitjSXZKcFZRbnZKVU1DVTRDRzdQb0ord0x5NHJmZDZZcVZvNXFpV0d5OFNzLzFnbVZVTVpTV2M1T3VtZkhlcVE3WnhLOU5RZDlNdU43cFVwbnNmUXBnQ0MzOUdpc2lkQzFhYzB6djhDOWZNUG5rMEtEdlFHdTkzcDJxOVpBb1JrRXdhZ3NyVGRsRXlpU3c2ZEZtZUQ3RUpDSnBWVFZCMmwyUE5PUDNaem9kRlZUUnlKYlplcWRMaUVhaDRTSkhxMXdndDBXVkRBc3JjUTQ2QktmQzFDYkdRMDFWWXRpcUJCNU9UMEl2aVRLSXZ3TGFUQmF6VmpZcG9ISWRyM25ZQ3FEb0hEbllDK3UrQXdNdjljcU91ekJEZ0hFQWxXeTQzZWtTYkYrSGJvSXMwVE01TWZJTUhmUWx4Z3VjMjUvRDJ0dXFoUGFTWWE5c3ZhcVBRNW5vSEl6blVDVUZ0V3BsazRKY3c0YkhNNmhiSlJZTzUxRXVpWTNlQmJWTzJRUXFVVVdYdDVlZFAyOFM1c082QUxNUU5KamhrakUyTmlSek1MNEhObVNzUW9nM1Y4bUMxeXNPVVgrRW1qbDc5cXd3SktERXhtUWV5ZW02eUNhMWFaejJlR0txK0xjVVVNK3FaaWp4bnRueDkwNTEzQkFtM2ZYZVA1MnppY2FIRFZFdUxWSURkQUEvTDVNTTd3a3AwRXlyRUJSeWJzSmZqYVJvTDVHRmpRV0pBRERLamI2VEtLZ1NhS1lsb2NGMHpPTXArS3pkUmsyZE9UQkJNZDRSR0FGL0FKYi9TY2dwbTFpNnZnRzFYbXFBd1hlNmlrdy9vMzhEcUlwV0w2a0RNYkw4aU9FeDdTV0NDVC9BejVITkhVbHNrbUFEK29xY3BnY3lvNFVDeVNiaG1HZXdiTDJSbVluQVkyTzUzWTczQXd4NmJsTGJSK2YvUGVDUVRTcVNpR2xZbVNoeC9md1l1aU5qQmgvME5WaitjTmFhWUx4aHhSSEFGUFo2aFlDOHhFb013T0FJZndUZUxWbVVwSnFpK0NHYkZQTFpJcnZUVldTdForUTcvSEEvb3E4b1NtTGczWURCVHRRcW42QkxiOXZsVXhNZDhDNnNVV3lVei9BakFjWndsYXJncGVkaytiTU1xanVnSGw1TFBxRktqRVpmdmM3TVdvbXo1aWxSRE5XWE5hR2pBRE1BelZ5RjNPbXFzWGVkZXJ6OTlDb3FyeXBLMmltYkpQcVJUZGk1ODhGZkVKSmJzMGxOR0l0N1FJelF4R2dqcGpBd0tCbWlGOEE0S1lQZUxOdXQyY1RHL1B5OEFKRld5WHcyYXJYblZlWmF5VGYrRHI4V1VDTnlVakdDUkRMbzl0bmJtTmpxUXA4L2ZEWlhCYjFRVEtkemt4UFk4VCtmVHFjNzN1a0tIODZneFZ4K3o4YU1ZRkhuT25aMW14QmpZbFNJeHZQL2tuZCtzVTNjZHdBZms0QnBVcVZLU0R6c1lROVRwYjF0ajN1TTQzODBzVk03MlpLMEpMQVFicXZiUWtORUJpV0lTU3V3UDhDb3I0eUdiVFExVFVKWHhDSXMzSnlVV0lzQ2dsUFA0aFExQWU0S1NUbHBPZXVDWC93d21RY3E3ZnY5M2ZseXR1L3M4L21jVnRzaDhrK0pmZmU1Ny8vZjkvczdGWWE2Wms0dUNuTFdPZDN0VXRTY25vVVBEM2Y1YjZYMzZoRldUTmV0azVENXJzLzNMSFpuTWxkSTBFWEMyNi8rZlQrdGFlUDVsdDN6WDJlSHNVNXZ0bTdpV0RKMkFvd2E4eVpkei9lMDlNM2NlZkJsdjFvUS9yTC8va1BOUExaZ2hiUWJpK1BhZFZ3ZWppQ01lVXpiOXArQmxEeGZES3YyOW1CWnAraElpWno0bG1jTzZkOUJmREtIZjdXMzdTVDgyYlBGdmtWUFZtc0hhbC9jZysvVmQwamZYbkhmKzQreXc5a2g4NTR1NXpDK3E4T3c3dWtLNTdCRyszQnA3c25uRHg0OHVIVS9yUy9Bdm90VmU5Skp6NnJMS0cvZHVJTFdFMC83OENtc2VYbjlmbXI1a09ZQU9uMkxMVXZhZ3ZXTjRiVmJNMm5OWk93OWZqWWNtaU9nZmc3UnlPU0ZtYjZsN2l4cGdBSEJpQ3d2N3ZzbHJtMzJ0TUU3NzMzOS9LbkpES2hJcjBWUFYwT1NVYnVuYXlYM3U4UGtqanljV1p5QmU2eVp3UDBnRjZBazZsakI4cDFYaU40OFc3NjFpTENPNGlKc3RwZlVnNG1xdndyMjgwNUx1ck9ZeFV6ZVMrOWVTaGZyT204c2thLzczcnd3ZWUzaW1YUjZiaTJqTlFNaGpmWm5meno3NGJXTGw4K2MrZURVaDNmSm10WjBkNy9iMVhHVURDMkZyOWJHMUx2MitNd3ZYdFkwVmp0ZWVROVhIZk5oYmNUQzg4Vi9UdTRqRmVHV1BTMDlYLzNwTHA1eE4yR2hGY1kvL2RkOFMzbzUrM0h4QmZhazd6elplTG0rTnF5c256L3cwUi9POSt4ZStqcWZLZW9JeVUwNjg5bE1CbDRSUHhoUW1QWjB1V0V6cXZaMGRVL25McDdiYjBDeC96aTJJZ3pudWplR2IwNDhPdkQzMzc5emVGZDYvdDVqdkh2WmFZKzZ3T2lqNW5ZZjZzRnJUUytEQzFqRXpjWjcrdmIvNmtsT3ExeWRmbU9YM3U3UjB6WXoveHdzQXRwTzQ3ckp5SlhCM3NoMExwZWJIalhVeHQxZE4xRmgxSjQzNlJ6SloyNzg1ZkxwZzRkLy9WWmZ5OEVMWjFFc010Tmh3N3hKYkNTWHplaEwxTm5jQ1gydGxmSjk4ZkhicjdXOWQ2OHpEejZUZW42ODdiVzNqMExrT3Z3NllmSG1wKzhlT1BEbjk4Kzk4MnJQcnNOSFAzajJEN1FJM1RHbjh5YURnei80a2NNNHc4UzFXc3pDaitZemszZi8rcHNESDEyYnZFSFdvck1qcldXejhLTXFqa3cyUDMwaVl1enA4aC9UdGxjR0ZoU1YxYjUrckZlRVFBa205WDJZNGMrdmREcWZOM0VNQStNTTIxTUZuYjNUcXVwcTErdnhHbWJob3hzOVhaNXd1Q3RhUG0vU21zY09pNXpheHBUTDRnc2NXOVJEOFJGUTA2RWN2bm8ybTgrTmhodVpOM0V1R1R1dEpjTmtGajQ4Y2l5WHkrZEJjYWRIR3AyRjl3ZDV2ZEZWclFnTkRBUklEMU5JNzlEb2NESnZNampxSE1aTE50U2tORGZ4aHNQZS9zWm40WDE2b0ZZc2dyZ3pDejg0K0RPSE1MYVd3ckNjTitreVdUZHBkQlorUmk5elJHek1tOWllaFc5TU11ek9tK0RSNmQ0cy9PY2J4VUJYWitFYnNSbFdhbEk1YitMS0xQd0dESzNLQXduclVPMTVrM2I3cy9CdTJJek5ub1duNW5VdGNYY1czcmxrYksyRXNWbXo4SXQ2QWMvZFdYaFhKYVBXTEh5L083UHdsRm9NdXpBOFBGTGZMSHl0ZVJNM2JNYW16OElUeVdpN0FWcGlZOTZramxuNFJpVmpFL2JwcXBnMzhaR3F4MEhVa29wNWswQWpzL0ROOENiTzkrbXlPMjh5bjM0WmZVbTN5N1B3emlWanErMEkxTGpsb2RkcW42NUErU3k4cjhxSXhlcnpjNmR4dmJYNnZFbnBYbmFlNXVZbUw5bk1UYm9xZDlBdGw0eDY1MDE4bUx6bC9NR2dtV3hFRFNNbkcxcytsa2RkcnVZbWRVbUdEbU9pSkROcFlKOHVTSU43amEzMFFDSmdWQmFDQWpmVG5aaVlpQXlVd2JETVRWeVNqQ3F6OEVhRFViYjFJN0Z3RG1iaGpjTkl1amNKVkZvT1ZwWmwxaWdaVGN4TnBtM2xKa1VXWFY3dkNwemNpZ29qNHBtSWtMM0FZM1hsSnBTdmZESkxoUkhYU01RUkJBc0h2S1lzS2h6SEtmTEFoRUV5dnVIY1JBOCsrMldGV3lCbmgzTGhXU0czVGFYUmdSS05JQmdtYUM0WmpIb1FFQXh1dDR5YkxqTUVCZ04vR2dqRTQ5aStJNHFLSW5HQ0pFZmpySkpNSmVIZ1pIZ3pNNXZ4VGVRbVd2NE9MTGdVT1JRNTRnRVU1TGFKTXRZZElQNWtqZlpUMnpUWjd6TUVHbVJEVU1vNGM2TFArZklpSERJTE1pRnlTUUd1dnlDSUFJTXJKT0V0a2trRjBGZUVYZDlRYnFLRkdkNFZKWlhpRklWTExjaGcwMFE4YVhMZm92RW8zRkhBQXBmRjhqeVB1MHpqdGZOdzZTQUtCQUpQRGxIa2VleWdoZ1BFQXI4SEdFd0lDTkIwVWxEWWVJZVlwQVdPa3poZ0hKVzVwTUsyZzN3b3JCRkdNeUxRYmJiRGNSVkc2eWNnR0lvTVprTlI1SWtKT0ZOQ0JtbkU0UzVLOElVWVluaTRqaURvQUMvQndVbVN5UHR3ejNGZUVyUkRaQmhLbEFSTzlNSHZDaExQQUF2QUtzQi9Bb05PY2hMb2ljTEdZdkFXTW5nVGdDRWJZRFFsTjlsYUo0d3VnTEdnZU1IVGdUK0pSRVRRRmpBZHNnSVhFU1VpWFNod1BDUFR0QVF3R0pGT0ZPQmZBaTdYQnpCRXVnRGZ3QTlvZ01GTDhKM0FNenlISHhsZUtOQWNYRDhuZHFCa29HWndLQ1V4V1VqS3NSaEt4b0FaakZaVEdGc2RWY2UzbGVRbXVza29aV0ZNV1Q4Qk5WRld5R2I4Y0dKS2lnTmxpY0M1MGh6YkVaYzVtaTRrbFJBdjZEQkEzQVc2UU9QTlJ4aUNSQTdlcDhKSVNDQTlDY0FYRkFHR3dBa2dMS3FhSkZHQUFBWlJFeGxVS0NXVDU1bG9oODVqSXh6dlJnTTZOTkp3MEhYRjhJUVR3NE1zRERCMEdtQkFGMEJQaUhlZDhJRDlFSkZMdTFMZzVBNlFESlIwUVpSMUdFQUJiSUpRVUJWRFNBaXEzdkJFTWhJQ3lJZ28wUWlEbDhqbEM2Qm04WUFtR1pxYUZBQlNNcVd3cW10dEhvd3l5VEFhVUJNWXJkaVUwS3BhVVBDdXFzM2daRWpoOFRPUkRFRVN1WUlFdGtHRGdSQ1lWWVJDWUJSb09CSTBwNnFKSUJFNkNBUHRKeDRnRWtvQTFVUkMzNnJJcWpjQmEwS1VwQWpEb0NsbE1GeXdHVVkxK1cxbE9LNExCajV5b3F0L1JWbEExNHFPZjBCSndYa3FpcURhREdBaXNXRDlRRHFNTUJncGtkQmdDT0Fqd0Urb2tpSHdva0RUQXNLSWd3RkYvNEh1RkNTRFJnQkpnQVl3UkxEUTRIRWp0bUc0SkJtMVlCRGg2Tzlhd1pnUXZNbEFaQUxFSkpsS0VkOGFBeGh3WVNHV0EyTmdvU2E2elVBWUNZSDNvK0VvRU1sUVBRMXhyUUh3TFBBMUJuWWtHR2ZiMi9FUlNBTTZqUDdOa0F6ZG0vUmEyZ3lNUWVIanlrby94dU53aGhCMXBRUTg3UmpZRElEQnh1R2FkUmdKdElvMEdFcStLQmtjWGlaeHFRa2FmVW1Dd0FpQlpLQnZKZll6SUVQd0JYRXRHOVVlVTRBdEdzV25JSG1hVjgvWVpydlNwY3BGcTU2K3ErVmdEOURBZ3lVUktLdEljREY0WFlKSVlBaEFJN0hoV29zMkErWEVENkxBTTM2Unc5K0ZDSlNYTVFCbDJRQW1lMndVUGtlTFdhc093MlBRRXEvN01IYThXQThNdzd4ZU1ZV1BvRFBCWEkya2FaaGJNU0ZJTFVRSUxpSG9Fc0YzYUVFWGhVRVhoNjVFZGEwVVJxSStCbjVINWhFR21CYk1UT0lJQXovSHNieWpMcmFTS21nOU1IN3FLTTc0WHIwd1dpdkxmaVNKVjJ1Z21ITkNOSzQrd2tkOWVnT3Z4dU5hYXNKci8wZ0JVTnVFQ0lBRTFmemR1RzVTUklGcUVpMkQ0YWtPWTlBaGpPL3NOTUFZdElKaFNFMWFUV3VnRVgwSmljQUl4WXRaSzJQSVVpbDhITkFxUS82VFRBMStyQ2F0VE5VYWFNa3F2S2M4VStzeXEzUTVnN0hkbG1TMEdueHJIUVhoc3Mzc3FJMm5GVmp1dWVNS0RNZVNVYWVhV0VpR3JiSmYyYU4vS21FRUhFbUc2emJqV0owR3RDN0pLRnMzc1liaDFsSkJnelpqczJCb1NKekRHR2dxakIwT09uY2NxMGw5KzNSRm5mZDBPWVN4NVVWWFlFUy9UVEJHSGF2SkM0M0RHSWpZWGpleDJQYlJvbk9uQmd5djI1S3hyUUtHeGJxSjVTTTlCdXkwTVptc205alltaXBxM2Naa0tobEhHaldnVlNYai93ekdsaGVxcjV0MFd2ZDBlWnowZE5VUEkxcXJEN1F5enZoaHc1SmhWaEN1MXNaa0tobzIycGdha3d3N2JVd3UySXovSVJqTmtZd3FQVjFlaTU2dUdqRE1uVWxWTmFuZTA3VjVrdUZpVDVjZHoycmU3V2NqemloZlVXdStaRmpEc0ZJVFV4aFUwMkU0VnBPU09BTXJ3a09XTnNNV0RLMjhVNm9tMVNYRFh4Mkd0WnA0M1ZhVExhN0JVRzJHYlJoKy83Y1BSb1ZrT0ZZVFp6Q0NOV0RFTE5xbHEvYUJPbFNUN1dXU1liRytXSlNOZXRSRWY3eHhzVjNKV04zeCt5MGxJeG90aFdIUG0zU1gySXlmdUNJWnJzTlFxOExhSThCSkJaUmhpcy85YmhhTVVZY3d0dThvRDhlSHFzQXdWUk9QaFRjeFBQaWF3b2VpKzBMUkdKbktpRVJEZnZJRGZSdjJxakJpbXljWlpnYlV2RVc0bG1TVUIxMEVSakRvUTRtSWRRNnRyNit2clQzRll3Mk85WkZlRDBvSUZRb0dLMXhydFBTb0NxUFZSY2xvSmd5MG9OUXFFNGl0aE5jQnc2VkxZOWZIeHFZK214MGJHeDkvK21odGZTZ2NDVkNybEQvVUNBeDNiY2FQSzJBY3NZWmhhSm91cmpGYWVoTzhSaENManQ3MXRVZGoxMi9lSGgrYi9lZlVwZGxVYW56cTVzTE5xZG1wUzQrT0hlbFlYZlVGeTlXa2xFU3hQWGdUYk1hMjd6Y05SZ2pVb0d0ay9lbjQyUGpVN1p1ejQ3TzNyMSs2K3JmYk42OWUvUzh4NXhNU1Y1TEg4WVVjc3RtcnNNekFzbnNZMkdFRGU1aGxkMkhDSG1MOGswUGIycTB0TFlPUU9PdC8wWUNLWXhJMWgyQVdnampweTFUeFdJck9TcjBXVW9VODM2djRyQ0RPU3hIQ1FqeTB6SGl3YVpYR3Z1akY0d2dhOWxmZHJkMXFPOXUyTGxzS0RYcnhmZnI3Ky82K3Yrb3FxV3ZiVmdSK3RKdCtWS2xycFFRWTkrOFhPUVY2MWNyNDFSZm53d2hlQWdhVVNIV2diaWRCbEdKRWNVV3BFSVFTZ3dtTUNSVjJKT3B4bTZGRU91eXZhcSs5VWhpWFVNWVhGMUpHWmNGZVY5SFp4SDhFbzMyajRXR0NTU201aTVTanBFUlFIZzduM09PdXBGUXlKTGpMYlpSNDFMRFJmbngwUEJBNEhUL3pqdkgvVlVZQmpHQnhaWndMQTV4eklyMHJiRSthUkVuUHNsM2I5ZlRwaElnRjN3NFgyTUFVTE1UekJJaGpZYVBLVjFQVVFFRnZoVER1L0UrVlVYRTVHQVZsY2dKR2JYdGdKSTBWdHptZHhhN25lQUNEVzFHOVV2Q2RpbnJZSU1nd2laZnlrSkd1cTJrL3Qwd3VEZ09VVVZHZU1xNFZoeEUrQjBaaG1SU2NTc2pEQ0FBTGYrMUc5M0NDdWd6YUtaWGNzamhVaXlUTWk2UXlQRUFoRnNVVVk4WWRHeG1VSkVZVzJtdjkyVEk1dlhKbDBsQUFvL1cvS3FNOEdMOHVFVVpsaVRBeUJscGQ1WCtRd0ZRaXd5QWdDKzR5aENrWXAydWxvcEZvOWpDUGl6RDBXYTBRNW5HU0dQZUJiOVJjRFl5dmYvdUhNcFh4K1dkcC9URjhPVERPN1NhZ2kxMENBRENSdHVlNUZJRkJTQnRqTzVLREVVbWxPRFlSajZZOEF3RXRnUkpocUJSL01SaUJQSXd6S2FNQVJ2Z1l4cU9kY21GVVhQdnNwMkl3bWtzb2sySXdZUG1xRjhJSnBHeGlFaGVhaHkycE5FeDQrdzNzYVE2WlUxMnBxRzNNR25ZMFpTbmxRcjFJbVc3ZUtLYU00MjdTVU13eTlPWDg0Q2xsUFByNjQ1L0tobkhySUgyMU1LcXE2dElRdWFFMm1OWUZBV05RUkFFTUZNMWFCcnlBaXhpejFJcGF0cks1cmhRYnB4dHJxd05Gc3ZpRllld2MvUG4zRmVYbGpHdTN2dnZwNGNPSG1UM1FDOEk0NlJsSGQ1RjgxZDFwcEJCMFZKZEoyMUdHaktRaTBFeVVTVEl3dEdGWU5pUFk0S0FMaEd5TGdtd0VTYnowdDE4WVJ2QUVqUENJUGkxOStQekx2NVhiVFc0OTF6UmVabUdjM2VvNmplTTBqTnUzVDhLbzJRZ01Kd3dDbVVwNUZPd1RHb25MSllWME5XdDRubVBwVHNLVmJSTUQyNDdMQ09GUkQzSTZwbWkzN2tWdHpTbTdLQWFqMEQ0YmM1ZXk5RllYL05YQVl2encrZFROOG1EOEVzcmt5ZFIzaHpzdlgxNEd4djFqR0g3ZlFsMEN4bEtYQzgraVNBcWxwTEFac3pneU1XUU5EcG1ESzREQnNDRmR5Z1MxbzFHUFFkdGhOQjNjOEpYZ0djVmhOTmRsaExGeitIVDAyYzFMS09QcE4vOENHc2N3Sm9wODJGcFN6dEEwZkw2WkhlZ2M4TGhPeEtHSTZJN2lRZVNNV0xaUTNMT0ZVRkp4cnBoQUpsTE10VFdNaU9QQ1RNc1N3MFZoZEpjQ0l4bE82czlha3dmUFJxZkxWWWIyak9kUHBwNDlPZmo0Q0hDVXBJd2lnVHhmSmxXMXc3dE1Dc2s5d1IwS0l4a2hSUEtJanVGV0pBS1RPNGpDbFlnd2htZE5lSkhFMXBiS0dhV1FSTHQ5dnVMQ09BOUc1dCsyQnBOMThOVThNUmMrWEpuczc1aWN1b3huUEgvNmJQcGJLSlZ4MEVadUQ3UjhHQUZ3VDRLcHg3R3dHS0lnQklTa2xjbmdxUWpGTHN4cEVwdFlFc00wTVRRZDVtbEw1Y0FDMGQwSC9xcUx3MGdHa3hrTFRhNXZiUS9zRDR4K1d6YU1pZ3lNYjU1TlRrNGRmQVFySGg0NXRTTjh0bEIremtCclhsUkMzREpOYWd0RFJGd1lUcFdBNGQzSndJZ29qTGpEbVdFaWxnbGlCSUlwendSU1RqRE0rZlJodzBieENmNFlSbXZoMGljeEs1T1Z5V1F5T0QrZlhGc1pIUm9iNkpoK1BQWGxieXArY2IwTUdEYysvK3MvTll6SDB4MlRVQ3M3NCtQalI3ZDhMd3lqdTl0ZjNRQXpDVlNCelJWMm80NGdUQWlDbUpPS09JN2xZbVJITFlrTnBPQVh1cm5DY0pMTllSWVhNTzFEMXJnUURGakpaR3Nsa0FpdXJxMHN0KzN2ai9WM2pKWVBvK0ozZi95SGh2SHQ0K21CdG83dGc0OWhmZU5rSWg4MGlsam8rVEJxTnVyU1JMcktobHBBQWg0ZjZTMGRHRW9pamg1Z0RXYWxPSUlzWmt2RUJQUVQ0dW5na2Jsb3dCbENPQkYrVWVQLzJUSTVwWXpNam5BeXFWR0U0bnVkYlFPWGcvSEpYd0RHbElZeDJ0SGZQN3E5Y3BnY21adWJDSmZxR2JsL1Q1VTk0MWF6OFNDaHVDdVU3cHp3dGd2TWJPNmlXYXozZEtCbHdFelBBSmF0QVNHSzZIRStUem5VTUNURHd6TyttdEpodENZclkzUHpyYXRiN3pZN1czcERQVU5qYlFOWEFlUHg1UFQwNk1EUS9sREg5c3JXeDJSNER0Wjg2VEJ5UjBGckZuWVNYdFJ4YkdxWThManc1ak9sRkpvbG5sTGM4aVJCbE9nTlVGZkFQSUtrM3UzSkRTc1dETFZDb3AxZ3JhOUVHSTJ4Mk54Y1RJdGllN01udmhRZjdPeThRaGhhR1FOaiszdjdIZHRiYSt0MXpmUGgrZVlDRm5rY3JXZU9QK2JLeE8rZjJVRmdsaWtQK2dXbGxPbkdDdW8zbFNPWjYzbkNOT0ZIUXJsNmZOUFo4NGdGTEVkUklXbTZ1YW9FR1BDaWI5akdXcE9yV3l2TExVdUxTMzB0b1o2cmd3SEM2T2pvSHhob0d4dnE3Qnpybjk1ZVdWdXRtOHZvNHp3WUJiMjFJWHQycHlad0o0MjQ1VmdleEFZcVhBWXhRck9BOFJYeWhSTFN3QzZERkNhQWpCTEhOWkpkZWtOVXBrZE93Z2dVZ1hHbk1mYmhRMFlVVysrV04zdjY2dXZqZmZkYVFrQkR3K2kvQkl3YkdnYjRaMFlZd0tJTmFQVHN4ZU9EYmN2dmdNZDZzbTVlQTVtZnJ5d0JoczhmVEdQR0tJeG8wQ3lrSWxSbHRHRVM3bGt3aUREQ1hFRUlaQXFxQklleHJSQ0dBMkdNbkFzanQrc1hnL1VoRnJ1enZycTJCZVV4dUxUNC9XSjlWMjl2NzVYQXFEZ0JBMUNNRFkwTkRRMTFoZ0JJNXliNHg5cDZFbERNeDg1Vnh1MzhRYVphZi9NdXhqQm5VSXpna1lsK2JrcHRGMFBxU2xrZVRDbFNCdzhHK1FKRDJNcXpzRFFNRjF3MU1WSjl2akpBR0JwRzQvdlZ0VGZ2bG52dUxpNHUzVzNxNit2cjZycDNiekFMWSt3U01LNGZ3ZENXMForRG9WbDBoZ2IzOXZZR1EyT2J5eHJJYWpLWUtabTVHRUE1ZVM0MmU0Y3greGZYQmlaMnRWVUlhaHA2QnhRa1lCb3NFbUZJUkMwRmVRc2dZV0k3SGpHZzhVWlBDRU0zWDBrU0R4WjhaemU2R21abVhyMzZBRXRMNHUwS0ZNZnJlMDFMd0dLcHZ1OE1qSTdIVXpldkRNYVladEhaMDlrRFBPS0xpNHZ4MENaVURBQ0JtbW1NYVpGa1ZtUEJKY1k4ak9GZHBXQTJGUWJZaEtJTW1hYUpQRWhiaHFLR0hZMVFFenhFY2c3SlUya1kwUUpwT05wVkV6c0ZNTUE5OVczQVY2OW1Zak8zNzcvL1lYWHQ3WnNmdHpkZjMvMGUxdUpTZlZOVFg5T1Z3cmp4eWFkSFpaSlhob2JSMHhNS3RiU0VXZ2E3K3VMeGVHOVBUaUxycmJxanpXa2NkL0twS3dlakdtQklLVnlIRThqYXJzMk1XUXg5UmRqRU5HWk5PNVZ5SVdSSVUzZGRwcnpUeXJDaGluYUg4ekF5S0Y3Qm1tbDQvOE8vMzc3Umd1aTcrOVhpNGxkL3Yxc1BxMGt2amFNTGFBeENPK25Kd3BqTXdyaGVqakkrelNtajR4Z0drTWpDQ0FHTTNudngrQktzZUZmTGF3RHlidVUvdkoxZGF4dlpHY2R6NXcvUVQ5QlBNdEFiU1JjVkJRVTFrcEJOS2piZVJOUVZOdTBha3VKQTJHUUp3WW02NEJsbWwwRTR6S0RTR2Nvd00rNTQ4dExNRGlGNzBiSUoyVGJRNWlKSUxSZ0NKWkJLMUtnWC9UOW4za2NqMlpidEhyK1FpMkJiUC8zTzgzYU9yVWRNRWpENWs3K0lDLzArTWpQakYrOVZTVkpOS3FIUWcxbU81TWhpWDdRUlNrWFJIZlRReDV1bTBCY1JZajBYelFwMWI0TWd3Wm9lU0wzLzJZTnZHUUMySG40S0NxVEQ4OWUwTXdxMTBqNlUySzhWUWhSRXcxY2pDZVAyb2pDVzhtQmNZU1RJakV2cnRLNWRneDdZbzFoUFZxOHdKTy9lL1pXWS9PMEYrNzJ4aHo5aWYwUGl3Y05mdlVmSHdic20xVlE4YnhsUTN4TVUzckdSU3RDNkRrelY3SG1pcUhxT2FqQUdPdjFXdmM1U3E0b1MvZjJ2Ly9EZzA1LzgrTVdMNzcrUE1PeTllZHg1OXF5S3JWRmtUakF0QUNPcFJoNk1wYk14NDhwVm40UVA0OXExbFpVVnFOaXVWRjdodlZEQWJsMTlBMDJZSjk4UWt4ZUljWGdtdi8zZDcvOHBBQU9DZ2lUamVVYTFxZWs5RitXNHB6cGFGeFpvdkdPYXFpSUtsRTdRbnFFVXhmKzBDWWJGbzYzLyswL3AxWTU5Q0MvMzloNC9ycGM2UmF4T3FWNnYxMXF0QWx2bGNrS05GSXpMcUxyT3dvek5MSXoxOVlDRkQ0TjlhbGZLVDZBSXlRcGIyK3Q3ak1ucjU4Ly84dWpSdTI4QTVqMHFDRWxEUjg3enRtdFptdVVZaG9wb3Fucm1ZSURzaVRTQ0hoNTlxNEVIYnlESVFpVEJvMGhxOGVwUS9NK2ZYNFBDeTcwM2J4N1hHMVYva1JLbGVnMG9XakdLbUVYYWpBU00wNWlSQXlQWUk0RVovbXF2d3N4S3VkQ3ExZmVmaGF0VGFqMStzN2YzOG8vLytLK0Z4c3h3TFhTa21tN2JCZ1VQVmJVTjZrMU1kTzgweFVCSnFwcGRHN3ZGc0NHR3FtcTBZMnhKR2tvN2h4eTN2RXdmeTRTaENTV3c2cVJGRmtaQ2pTU014V1BHaGZ5WTRXY1N3dUN2RUVhYjN0cGdVY0hPTGJSYXRWcXRYdC9IVDl2eFhlNTA2djlHYWFGWXFDalFocG1JQXJiRml6eDZFVTlpSTBCa1cxSHA5L3VpWmVEQld3aWE2UFlOU05QckdySTBkTFplY1Z5MTJxVFZhRFRZbHl3eEhQaFdyZG94ekRoRnpMaVFiNGFmVjdNdzJqNlFBRWFaZUJBUk1LR05qUkJYcFJjcVVTVlJzWFRka214ZFYyVWJWWWNrMkhxWGFnMVVZaDdhVlZGUmtHb2syVUcvSWlpMlp0c2FRaWphVm43b2ZQNk1xeGI5MVFsV29FWnNobytqNHI5TmJaTXp5Q2IzTTJaY3ZSaUVpeEJIdUVmYVBveEtna1dML0tBZnVWTnNjdHNqK3dEVlpSZFBlYmRyMkpxc3VnZ0dXcmRuV3FoR0pjdVNBUUVsdVNTS2RGOUZVV1EwTEdoalhWZFNoc0pvYmJuYUtFWXI4cUtlTktOUW1HSEdsWTJOYzRvWkRNYktTaHBHWkVhd1VVSVlvRkduemRMazFpYnFVRUJFTkdSREp3QzhoSkJCc3dza1V3UUxRYVVqRldySjRBY3ZvV2lYSlZWekRWVzJCT1ZBdW5tUlM3QmdjcFE2Q1ROYWNTNkoxY2pBK1BuMndqQ1dqZ3RqSlcxR0pXVkdDS1BCWGJzcml6eFBNS2plMW1RWlZRWVY1WWliNElHWUtTSFgwRHpEa2xHSXlLWXVDNnBuR0RKaXFYUGdmRjNoaXNXanpNaUVqRmt3Zm5EaHJNeUl0Z2x3c1BkWWpkVjRteVROS1Brd1NwK1BobzV0ZGczSm92bW1ia3U4S0FveVpWUEowMVFKUGIxaDBiYlJkVk9WM1M3YUZFbVFEY1B0RHZTRDBmVjZGa2JhakNoOGxpdWhIUXpHQ3ZYd3A5OG1TM05oQU1LSzcwVWNOQkw1SkRBakNCcjR5WXZWNWF1VEE2b29OUS9iaENZV3VtbWdYelZkaDZlcHArT3FnaU9qYyswT2VxWm45elJKUXRtdTBWOWVHdWpEeVlkR0JLTkRiemxtSkdDVTQvZ1p3RUEyT1llWWtZR1JNU01mQmlYWUJsZmYvYWpUZ1NIOWhTYlhaRWVIbm9rbXhKWHBhTUJ4WllXYVdWNURMd0pJa3NLT2thak8wRFg1RnJmY25HRkdMY2NNdjloSXd6Z0xNKzVQd1NBYUlZeDRtMFJtQk5tRTRhaUZadURuNTRxYms3R0p4OGJ1SFhpbTVzbDBDZGJWTlVmemVOUWRncUxhamlqZ2s0QjZYYUVNbzFPVDBuUHRtNXRSWHAxdFJoUkFBek5Zb3hhMThKZmpPbVB4bURFSHhzcDB6R2pQQ0tBRW8vcmtMcDBZd2dXVEhqTWRuUWwwZXNJTGhtbklTQ0NDaVo0TUNWVUNIYVd2U0liTzVobTlzZnJacXdTTUdXWkVGVmM1VkNRMXo3aDhxa1p0NldRd2NtTUdZeEhBYUZTNVQwYnM4ZlZNbVpJSWJGRDlxYkNId29OdXRlbGQ2czlFQ2NVSXlqQW5tQXZyS3ZKcW9zakltbEZQd1NpSE1JSnRraGdJbno1bUpHZWdXUmp6WWthOFRRSVlpQm9mN25wam1tS1ppSm5VeWROSW1DYWpqajVnQmJwbk9RNktkcW5iMDlDMXliS05ZRHJReDZPdFdxckl5REVqRGhubGhCam5Zc1pzR01sdGtqR2pFS2tSd1dnZVRnNmcvVUMzTFRveGNGVFZVZGxrMUJ5ZzhCQUVHVzBiT2pocVhneTZIVW1IQytqemQ1QkswbUpNbVpFSFkrWTJPWG5NV0RveGpCd3owakFhWFBYZXlFQWVNVzNiOHl3TEgreXpaN3U5UVJmZGlPcWF0a0hEWWN0RWJrSEhvcUk3TVViYkhOZk1NNlAwZnpYanErUzVDUTJFNTIrVDloRm1BTWFUTFhuY2MybHVRMHJRb282VmpZQzdydTNZbW9XTzFkQU1MRS9sNlZScE9McU42Tm1ZQ2hrenpFakV6eUMxbmtYTVdEbzVqQ1BOYUZhNUsxL1pZN29XekRzMCtMTnBRWXh1Y0cxY282TnBWemMxdzZXYkt5SS9IRXE3Nk4yYkdUT0NwaFZmZXNxTVNzYU1NNEdSWThaR09OQUk1enIrbWphalBNT01ScE1yYmt4a20ycE9DeVdINmJwc3lPbmZla1JWU3J1RWhSUWtXeFZCUXhTbG5jTW0xNHhoZEpKbTFJOHlvNTBMWTdHWWtZU3hkaU9lN3FSaEpFSm9KWWFSVEs0QmpDWmdMQmUzMGIyaUUrUFJucXU4VEtNczNiUnB6bUZwUFlQM2RMQkFGMCsvV0NBTW55cDNMaTl6WEhXR0dWTXhJMFpCWmxSbXdGaHNuakcxVGViRHlERWpCUU5tTkRsdWYzdkMwMlBsWlZsVVpJTUtMVHFFZFpCTUVDWjRyYWM1S0VNa1ZPYmZpY3B2TmxDc1ZWTXc1c1dNU2lhYm5CV01PVEhESDNVZHl3eFdqaWZNd0FQak9tdGZLaElOTER4QlJNdXVxMzNCUWkzT1M0SWllYUpLOTZSNU9td1QrMjlwOE1sUU5LYk1LQjFoUnVXY1kwWWl0ODR6bzFMSlpKT0VHUVJqdWJpMjg3YmZQOUJOMUZlV1J0V21hdlg3amlFOWxVeGdRRzJ1U0QxMytOM28xdFZxQUdNNlpwUm0xaG1GNENTcFhRbGdCUGN6VHBOTkx1VEdqSGt3bUJtc0lKNW5CcjMwOGVyZFh5cUMwWFVVM3RaN3NNR1QrMzJVbkU5NWdvRXlTemd3bmJkZlhPOVF2RGlKR1RHTXBCbFRNTTR5WmhDTWxYbG1SREJxVVE4Zm0wRTBtczNOTDM4cnVtTlpSZTNwaUs1TFUxQkhVZ1JMbExzRDNiSEdCNk03TjVyRXJab3lvNU11UUlPdU5Ubk9LQmZtbUhGdjBXM2ltM0h2Zm5DTEtWMkNKc3hZalhGTW01R0MwWXhnY0Z6cDh0Wk5UeDRPeDkyQkp1dXU1Tms4anlncXE1bytIb3J5eDhuOXd5TG5zOGczZzlTSTY0d0VqVUxDakd3QXZYZTZtSEVNR0t2UjRjbVVHZkhjTDIwR2V6WDRHN3NUdWlQc2FwNnJJYlU2a3FkcnN1MGFnamlhM0Q1cytDODVXRTJhMGNtWVVjK2JkQ1hOT0NNWUYrYVpjZkZTdGlzNXNSbWcwYWhkdlg4SHNlUEFHby9ITGdvd2JUeTJIT250Rjd1YjdVNGpmRDN4SERNNlljOWFyNWV5SjJyUmtVRnV6RmdZeGh3ejF2TmhaTXlJVHRiOGs1TkcyZ3oyUUo5c1hMKzdNNWw4eExMcDAyVHlyNjE3bXg4YWlSY1RuNDRaaVpLTEhTOUdJYlFRc1NpRU1TT1krcDFyekRpR0dTMC91UVp6UHdhRG1kRk13R0M3WmYvd2srdWZiZTN1N0h5OWRYdjd4cXRHK2pYbVo1dFJTbTJVTEl5bzVzcURzVmcyMmIxMU93MGpPbTFkei9Sb2lYbEduaGswQlowMkk5Z3VwUnA3Sml1RlZyM1lUS05JbXBHTUdDR1B0Qm54T285c2Npd1k3ZkF0TE1lbnpaZ0hnNTJ0VC8vektET3lNTmozS3hUT0pXYUVaa1RiWkMwSHhveVFNZE9NdU9vNjlxcG16U2o2SCtFK0tkVVR5Zlc4elppQ3dXNW9YRndQVW1zc0JqME5NOHdJRHd0WXA3WVlqTWFzR2FoZmFNUnF0TTR6WnVUQ3VKU0EwUTYxb0k5S201M2VaTXc0QXhoSk14Sm5yU3k5MXFJQitiUVpaNWxOZkJqQm5ZUlVvYkVlSGNBbkFrWm03SmVKR1F2RHFHYk42TVNsUm14RzRUaG0vUENVTVNPNnVoUEJDRTdpMTlQWEVUS244SkVhQzhCWW5ndWpFOGZRVW1CR3NFdit4OXU1OUNhT1pYRzhkNmw5cldiWmk5N1ZkNmlrVkFrUXFzaURGQk1nNUtGTUJZalZKWlFzcHFWQm1rVkxzeDFyZWx1clllRUZDeVFXSGlGajJiSmtnU1dueE5PV2tKQzk0QVAwUjVoejd2VVRUS29DSktTZVVhVVMvL0kvcjN2UFBmZjd5dmg1VFdYOEFBd21BQ1AxY3NxbytNcWdWdUpMNDNGbHJOVFRoVEQ4SXhaQkdHNUdIcFpHT3F5TTY3bmQxblZneEpjckkvZkR5dmpIMzM5ZW96WlpoT0htb0c1NTRnVVVOK05LT1owN29SMDF2MUo3YW16MVlFUVlTbUsrMys5N3lsZ2RSdEJuTE1BSTdCYzRBWVY1dEhObmJSaFJocEo0S1dYQVI3eit5My8rNngzTENzRW8weTdodTJEclk3Q25LeFhxejNDM0NsYUZNWStpNGh2S0VtVTR1eVp6alR0cndFQmx1REErTDRGQjAxRDR3UlNwb1R3VGpNQWE2Rnh3alZhR3QxRVFEV09WUTg4THlyaHlUNXhRT3psZGFCSU81aG1MTzJycktTTy9xQXgvRVRSQ0dXNXBzZ2xsNEd5cUlBd3Z0bnJ4aEVvakNNTnJCSTNlYTEwWlJxRlFpRlNHMytFV29ReDNvWXZ1T3p1aGRXVVlyNWZBdUY4S3cxVkdiRlBLT0krRU1hK00zRkpsUk1CNHN4bGx1Q2V6cURTY2h2cEFmQzI2VG1OK3J6WHhMTXFJTDhDNERzVVMxMHlDTUZiM0dWUVp0TjNQODZCQk93bTVEWnB2TUkvdHRhNEFnd2JXRUl6S284cVloM0Y3ZDdvUm4vSFRLakRTait5MUxzQTRYd1ZHMEdjc1YwWnFzekMyWG9WaGVBY1lnM2JpOWRTN3BySzRWZUR2cUsxaEp2bUlacFVnak91Z012ek9SMm9tNVkxRmt4QU0vd1Rqbi8zK3JYTU1oOVlvUVR0SkwvUm5oR3VUek5zZnJWc1hsVkVKTFB3RllTRDd3Skxmb3pCVzhobS8vQkVKQTJuYzM1emM5dnNNeU5EZlR3ckRpSzBGNHhFekNiVWtoQStjWEMrRlVWM2JaL3p5eDllZ3ovQ2R4dW05TkpPcWZWSHNNN2QzZDM2UlVsd3NUOXh0ZUEvR2szQzRNSHd6cWNUbjkwMnk4NGR2ZkNOQkZnNk1xeTlmUHEvaE03WUN5bkJqNnhVOUQ5K3ZQaGlHclpMcEZIalV1bCtrVGZYQjhpVGx0WUw2YmJFcnczQnIrRW9vRXcvazRuNVhMRmJOem9GbkF1UFVnVUZHUnF6aE15SmhvRElBeHJUUm1CQWUxZkl0dy9UcGdkbzVHS0hWbmVkUVJpNFhkSitwVk9BOGdhZU1DQmhQOXhtZU12NGRna0ZvQUl4Sm8vSFg1b2NwbmM5UXhwUHhJbk1iUEpvMXA0eEVFTVlQWjZCUkJYd2dsZ1EyVFVJSHNoaXlTMEFxa3dBTTRqUGVyS2NNRDhaVkdFWVR4MmMwUGsxQklLQVF5YXFlTXNGVVkwNFpQb3luZUZBSGhuTmUwVjBkZDFqRVpibmk2WUowTUhrdzZERjQ0akkyQWlOQ0daNEhwVEJ3N0E0bDBrU0ZxSmJJaFBPdWFHV3NBR04rT1lPODRFL0VURndiQ1IzSElqWnljUkhJdWRaWHh0ZWxNTUJuTkQ5UkhQajYwRHdhekZycHVST01rY3A0dXMvSUY1eURySjR5VUJhWmJNOHljeFVuK1F5ZStXWWNYVkJoNEVGT1A3UytJVDVqYXhWbGZQMW5CSXpxL1ovM013T256TGhEbVloQXBzdGg1TmFFa2ZkZ1VDT0o1ek9aaEtrcVl6NGh1MjA3bElSSXhqYlFqYTB3akM5QlpXeXRwQXlFc1pob2xHKyt6Qjdzd2ZTRGZ5RlFzK2txZzRsV0J0MTV6cStuRE1keFZ2S1pkay9vNkFwZmtkMjJIU2U5UVJncEo1SVFJM0VTME9yVldqQmV6Y0VJbDJvM1Y1YWtHbUFsSDQ1d0VGRVRZWWdNVTR5QU1iZHprbGxER2M1R1dyemRHMnVkdW00VEdEU1dwSmxZUzI0eE41WjFrMnFKcEVaRFdaeVE1ZUNRTWw2dm1vRkd3Y0MxdnhQTXRrNGVwdUF0UGh6aE5FRklPMmF0UjJCVUhCaUZWV0NFbFZISnRDVmxYNi9yZFFGZ1hCTmxRS29sdGhnZXA5N1lENnAxSVRMVVJrNDlHRmRyd1loVWhsK2RsRS82dHdSR2Mycll4cVFaZ2hIc2ZvemFVOHM4YldrbnJJeDRoaGYyOVlQOUdvSGhLQ01OTENSaGdOUGJ1SWt0aWVrNVpWeGQvZnJaaDdHMW9qTEl4a2tvNjZxNk1PNElqTWJrd2JMd095S0p3ZWFkVkdDek5hU01wMnlxUmNGSUFBejdrc0l3NHhsWlR1QW5rbHZXZURBaFUzOGFqUjNiNm91RUJja3kzS0wxdDlWaHZGb0d3MU5HR1dHQUpGUkc3cDlhVnRWWitVdkZydDNENmJHb3VyV3dBV1YwOVAzOU9pZVlpVGdZeUhVc203dTJCRWlLdWVQanMrTXpyakY5S0xjdWJ0RjliZ2dHVmNidkN6Q3FIb3dUQndaODVpS1VKMFZhdDZhY0VUeGtDTTc2UG1NZVJpTGh3a0F6TWEyWnhDZXlMVmxTemhydWZaZzdYTk9BRFBEQ1o3RWhaU3lIVWFZd1BnR01HNFNCdFVtUklaT0lUay91R0JFblptV0RQcU95WWpRaHMxUUtia3NHZmpDQmNWbmIxbXpiR05pU0xHY3RtMnR3WkRaV0U5U3hBMm85eFM4akRPUHo4eW1qN0N2anBrVVhOWXJwZmhvSG1hbGpMRmJNZEpidThOQVNudnFMd21MMzQrTzFHa1dSa1F0NWttNVZjbTNUSENyN2RUTFZyMWJYZFExZzhNSzBBUWF5TTUxTXBqaFhyekVWckJhelFSaGJqOEFnZlc1QlpkemlnaGZvSW1YaERNUUpmRkVEUTVqeExUa09TUkdCa2ZFSDVzQTMrd21yb09jWktNY1MrY3g1SmwrcFFBNCtWaFN0czMrQUYwTnQxN1oxemdBWU0zQ2RvSXVwUFp2WjArYlJUbU5IaVlEeDI3cDV4bmRoTkQwWWQybnhaS1pNUUtwNkEwZVc0U0JLeUpmaldXU1JOVTJ6M1c0bjhsUVcrVVM3WFFrL05IaUd6TnlpZWFITjk2U2hPb2FYT3V5MTg1bjRlVnNkMU91MTJnRzlKZXZnRW1EMFpCNk1CSUlxaExWVVN6S21qWjNHa1NFOUo0elA4ekRLODhvbzl2dXpRYlBCN1RqaldvSEhSTEN1WlZ6MWswMFZIMmdJajNUK05wOHo0Um1IRWp4ZWdicUdRZ0llRzE1bXUxTHdTRlRhdmFHZ2FOK1NPTHp1Y0tRTXpVTCszQngzOUZycHdMMHk3QUJnV0xJS3dqam16bXdlL0JTakRoQUdGQWNNeWNVeEdkOWNOUG5YNHpCY1pkemRpa1hKQVA5Rko5TWY0NlJTanJzMHBKd2N6MVV5dk5MQjRXdmZCUDV0SHBTdWpYQVFtekJzaytlRzl3Z2F2aFQzUGNEQ0hBcmFLTG43a1MzVldIaXIxVVpDci9EV0hJLzBtbnY5RDg3TjI3YjVtSUFzR2dNMUxjZGFNZmdpanI0SDQ2ZG5ndUVwNDZKbDJkUEdFUjFicTlOeGgvQzdNY3ZLY1lpR0duemg5YnF1OFpCTGYrdlc0YTNiWmJVeFR4NWJHYkZkOHZxYnBwcFVHKzJoMXNYUmIxMldMUjBlZ2poMC9VRGd6OXVnRERBVHFveU9wdGdQa21rWitoa2tGellQV1doTTVCVUtRM3c1R0tGb2NnOHdpa1Uwa3VZUmlmT29EZTc0M1JuaU1IcWdEVkJHclZZNkxOV1YzbENyMWRuZFpISjNGd0N3Z29uZmJQaERjbS92ZjN2d250SFlKRERNOFc2ZC9LdmRqNGQweG5aSkg2azVDb05JbzFZemhudzZDNFl4MFRFTmZ5akdSSUJ4YnplZkZ3YlpldjQxRXNZbkIwWWYvOW80MmtGZFRHeFZGUWFjam9OQjlVdWJ6OGdPak1PYU5sYllMa3V1elVyaXMyc3FQd1Jac0N5OWR4TGYwM05nSk90czE1dnlpRERxQndaZlVSWE5Wa2I3d0lPRHBDc2h3My85ME5FeGxLaGlMQVVwWDltQkVUU1Q2Z3ZCY0pYUkZ5MjcyU0JCZmpDMnhEUS9NOTV4N3k2M09mMVNoY0Rvd1BnNDBwSmQwQVRyM0R3SWxpSm9YWGJQZjNYWk1YRWJiWVNSQk1laUdkcW9VOExiV1d1MXpyRFNreVNlNWhuMXVzREU1WVJzS1pjSUF3ckZXQnBnM0JBWXh2UDVqRVVZNVFWbGlET2pDY3JndUNQaHR0WEt5dURKZEc1Nys1SUQwNGlmdXpEd05yV1ByQWNENzFVRGlleTV5a0FZU2c4UGNMYkJURWJLR0ljYjlvYkt0enJlbWxZcmphL2prS1gwRU1ZbHFVM2tuR3daN3dERzhRQmhwTUZuVUJnUVdrK1dLbVBEMFFTa0VWYUdLR0pjUGRwcGNvT1pMSXRaK0tsMk9BNWhnS243TUVyb0taTHd5MjZTM0NRSVlCem55VG93TkFsZEtIaFZRWUpZaTVsSmpoZEttRnJVYTRLWmh6eWw1eXFEd0pDMGQ1d0hReFF0akNaVDIyb1ZYeDZHN3pOVTlKODdXRCszV3VsVVdpVGZzdTNMN1ZyTlpqSytNdGlPSmdpQzV0OVh5aWJmYTVCVnZxZmlZTm5SRUdHMGV4THZaMlREVWFsR0hwK1BaK0tac0RLa0FZR0Jac0trV3d3SnJkT0hxdmhTTUc0V2ZZYm93amdUK0phWVRvT2JSODhHTUxickJwOHhIUmdsTUFPcG5ZUEFtV1NkT3lhN2U0ckVtME50cit2QVVFbHd6ZFA4Njd5UWE3ZXpRNjFVcDNXcUI4TlhCb0hCVFZTRUlaOUMwblhVbU14T3hRdkN3bGtCcFRCKzN6aU02a0xWQ2pCdVBSalRoeE1DUTVTTEVQTnc5cmcra0R3WWJGMGplUlhHVTZLTDNlNTdSY3JUdklJbE1MNk5DMTdpQlpucWVBeENVa2FIYzhvNDhKV2huWEgvcCsxOFh0TmEwemcrdTg1K05uUC9nRHQvdzkybEtYaU5FMko3cXlQUnhGcHhqSTNPRWRHRmdvSXBKeDQ3cDZJbFRvVkJWN3B3NFVMSWhjT0lFVVZHakpCSWpMOUFDTHB3TzVtQmR0TjJjNS9uUFQ4OEhtMlNhc2QyMFJZYXdpZmY1OWY3UHUvelFHaDlmb21Id1RWTWRrNkxXTUk3SldXSU1CTDBxZ2ZDOThBNCtKb3lBRVlGWWRoSzJ1azFENlBYM1JKZ1BNdmwrbWRtS0QvTVZ5MENBN3hIcTByQ2g2Wk1rZzBKaHNFenJFS3EydDRoWTVUSjJra0ZqSUxvUVBmNXBHdGNxVlhVamRGcDhmUm1ndCtTM0Vya01GYVp0djBWR0lMTFVQaU1YZDZCWXZWOGVRakswQUlNZGZYNjRzbGpoTkhRbkJFWU83bGN1NHVsSzBpamZxN2lZWlNGbkxNUElIN2VsbUJBcHRyYnhsVjBtSXJuQ0F5Rm1aQ1RMaU1mV3ZmNWROdzFIZVR6cC9CSFoybDNJYzJJUzhyNGJoa29md1o2ZUxDUVoyQm8zWno1REZ2SkpzSm9RdWJJSytOOEIzS3FGMWk0bnBVaGpHQXcyZTZMVHJJdGh6RnN0TjVoTmk2TzFuNm1VSWJnTTdhSWF5cGlZYmcvYUV3dkJ6Z052amdKZFRvU2pOQ0IvakJFL1g5Z2hKWXB3N3VMU2RjdkNFT01KcmFTYmlyQUdFa3dDcXE2RWthdkswVU1nQ0dhaWFtL2pkRVhjcEtkWmh1S3VpYnU0SnhYUnI0dzRkQk1YTlBySXRiSmtJU09idkw1VGN5L0tpNExmNWxHQ25ncjVFaHJ3bmowNDVFRXc2NDg2VHFjanlZQW8rTWo2WGdSODR3U0tvTVVEYnpQRU0za1dXRm5Ec2JQa0lJdWhRSHV0QUJadStvY2FsVk12UHF0QlFjS2Y1dHdIa090Vm9KQ0RRK0NOemR4NmpzeDFISEp4VjhVZ0REMERvbzlDWWZjQUlNSnIrb3pIdDBKZzQ4bUkwa1pPS3QvT2lxZWJrSUpmK21xUWY1VHFlRlJwY0tCRnBvVGJnWUQ4aTdNc1piQTRPcnZvRXhUbmJmckRlNU1ZOWlvTG9SV3ZDcG9kWFdtSWFmVzlrZEZpQ2Zrem1UenRKakhpd0lMZjgzcWRYa1BmT0dqTjZ6UEhZaUxNRlk3OWp1Um1jbmNWWUdZam85bXlzQVNmZ0I1TVB4a0JsVnR6YVl1a2RTUXdHaFZheEtNTXFkUXhqd013V2RVZTZnTDFYbjlTa09PUWJ1OW5LaU1taGhOSHVkZTFxZlZmbjhNNFRSL0laeU01NHY1UWJWVGNRcFhTRTZIM3M2Y3ZJa0dRMVFnSGxrZEJwakpTVW9KUStZeTlKM2RTN0lCaDRmaGRaWU9HNlBpTC9zZzA4SFVWcXFWdVBKKy9na21YUmV6cEl1SFlSWmdiQytIMFREc05iYlBlZWZxd1dOQWc2a1AvMXRRaGdUajZjc256ZXZyRVo2QlZnZlBpOEpuTkttNjFCMG4wTkE3dEVaM09NeEdrK2x3d0wwbWpEL2NEZU93QThuZXpWOU9NZlVGTTluMWRsempTUkV5RGJDVVFhTTZucFpIRjg4QlJxN3dzbndtMWlZS1pXeC9CUWFVckFSR3UwR2VoS01IeVluUnBPWWg5eVprM3cwZWRXRXBwS3RPcmtmNyt6ZWo2MEZqWENrNW5EaFB6V1d4QnROdjA1bWpaSmF4dSszeFNHUjFuNEVPTkNYekdlNzVXL2pEUSsvdXVERVozRUJSaERDOFhtZW5BbmxYRVE5MzhqZlgxNWdrN3dPTVF1RzZxM2tvRENUd1Y0QlI1bUdvK2pnOUFxclVWemtwendBWXcwYnpBcFdCSnZnWS9YV2x3azB2NjZTL1RGZnBrTllNcDBVZEN2L2puMy9MeG82T1V2NEFnUkVMLzdDNk11Wmd5SlRoRS9xbGQzMjQ3ZVZ5NnVzZ2pGMVg1UUFiMzU3dm8xdEhiNFl3bmx6azhVcFVEc05ndmxjWkJJWktsV3Mxcm9aUXdUY0xPU2tEcldscUdraGdjbVF2Vk80QzRuYXRaQ3RWbk54NFBPWXNGY2h4RUliREczTDdvK2wwTk1nY0g2ZjhjWUFSajhUWUgxYjNHWGZET05UL3I0THJiNnhqdllYc0xuRG9TaUh3cWVEUzkza1V1QS9vNGpFWTlUZkJBR1dZaUpsc3E5N3Q5T3JsU1ErU3JpWXUvZUdWb2RtcURjdE52RERJNVovZ2tUTkc4Z3F1aklEZmFyNVJ4ZUhhdFlkUDBvdzlTQ0VNTm1FbnlsZ1hobitwejVDOU9MSGdEYSt3eDZHakkwMlJlV2s1RWhoMWE2cEZNLzhhRE5XQ21iU2hhdTIyU2VXaUFodzd1T2VtMTJxK1FtVk1yZ0FHU0dNOGVZcnJaSExONjhtVXE5aEkzMDVIMitGZjNPQ3RyMjQza29adjMwOEhtT09qVklxTzJ3T1JvSitIc1VwUGwxd1pnVVZsNlBsWEZsNUh4K1VWWWJncXBWQmpNT0liQThqeW0xRjlxcTV0SVl5bmNoZ3Y1REJlS0dCQWFJVXlqcFF1TytRWU5OY3VnOHZFVFZDRHFzZWdNVzF0YWNhTmNoMzdVcXFjd3lhODNCUStwSjNMb1hOR2t1OVBrbEhhenJ4SnN2NWdBSUtKQ0dPbDNzY2ZrM2ZBMElzYmNNVE5ML2l3MCtubzhEZU1OemQ0Yy9LeTJib2NlMm9lY20rU0E3dC9WZGhXd3BnemszTVJ4bG0vVjhCRVE2V0NRZzBJVnJ1OWk2ZWdrSHBWWThCbTJGcE5NK1E0VHFlcDFXcEd0WFlPaG91WWlTTnc4dm9vbWZMYkV5ZFJKbUtuMW9YeFU1cVlTWUtjZ1M1L2ZqTmJkc0x2d1lFOFZOdlJqNmY5OHFRK3FKY2I0NkVOKzNnMTByM0puK3NTakhOTVFSVXc4QWp3WjRCaHhzTnhLTk55VUtsZDVPb2NCTmNtTHYvcFFqVkNwakI1eUpRdThuaVJWNGJMcFpNcncrV3luN3hPMjYxME1FNHp3VENEMFFSaC9IRlZuM0V2REd5YUlqQkVaZUEzZ3EzVGFqMzQ5dXFZYzRCUE14bU5KazF0MkNlWGFLOTZSQmxtZ0ZFbkI1K0Y4NTRJbzlIR2cxQWV4c1lHMTYvamZkck9UcnRWdnRveWM5MXV0WHJGRFkxaUE3MkhiQWt6MmNSM1dDSUxVUmt1S3YzNmlBN1NBV3VFVGlYWmtBekdTclhKRWhnTHJ6bDM1NVFoOU5KcnlUNGdvVUVEZTNjMEhqVlg3WFp4SlZCM0tNRG9JNXplZHJzdUtRTnh0WHF0RmprRDNmQmNnVnVBVDc5Nmh0czh6S1JSbzdZMW0wZ2xIMWVtbTlFUWxVRmwzcngrbldaOFBpYjk1ajBib3RaWEJpdURzZkRxV1Q5RGdlbXZWNFFCTkd5a085Vm9uSFc0bVl4bjhCa096endHN05GNHNjZFY4WU5YMFFLTUlmd1ZiNS9GZjlEZy9pQ09HNTd0NGRCeEFsZFkvc05QcEpwTkVSRmZic3FWNGJTelIrK1BzNVRESGsxR000azF6ZVFSRHlORzJ2MWtyemtmQUVOcXB0ZEtQY0llczlpVllWQk1JVExQZGE2WWwzUm9tR1VqZGpUenlwakJVQ3BEVHlYb01Cc0xIQVNpYVRZVy94NCtneFY2SCtkZlpzbmVMOHBoZUMyS2FRbmErWWxNZklmYkEzdmNEUGhMTmlSV0kwZUIwaERuRGkwb2c4Qnc2SzFVeUV2RjZJRGRuODNTQW96c1dqNERZWUNkQkFLQndQeDBBSEdLeHNKS29HVXc1cVpHUExUaGIvNFIwakpobUpiNkRLRlZXbXVKeE4wTUc0N2JZNWtNWDZpSk1CNnRvQTBCQm5hckJDTUJoWjJRM1I3NmI0Q3hvSXg3Y0tBeXpMTkhTQjUrOXBMb01XUVRxUmFWUVNaRk9Ld3Ntd2huMlVROGxrblJFYnRjR1N2QStMMW9KcEZFbUpFL0xKaFZhaElNZmp5OVl0emgzV1p5bnphVXlsQUtReHlQb0Y0MEUvaWhPQ2s2bW1FU2RKWm1tR3c2U3NjRGM4cFlvVFpKWmxFWmZpYjg1VGJBWHowcjVxc0lJMFZFR2hieWZVakRkM1JhV1Z1czUxdVZZZGd3S0pTaDBXam1Zb2swTjBNR2czOWJvYlZRMldTS1RqRGhETTNReWIrL1RWRnJLdU4zUDZVQkJrT25icjk4dUVVUGFsOGVUK1pnT0dSejNIVHJLTVB3ZFo5aFVnU1RPUmhrUDRIYUVvZ2VzOEVFbllGYUxYWDg5dCtzbFZyYloyUlpPaEhHY1owcEVNWjhQQkdIbDgxZ3lBYkdMaXJESlBRSWIzMmptWWhQc2p5ZXU1UXhYNlk1TEM2THp4OWxZMHc0R3MxbVQ2TGhHQlN0MzBFWk5OakloMzk5dUkwUVpWQzRBOXduajY2NGxOSzdESVpDR2VKNEtqTHVVR2dUTnR3bkRINlFuY0pNVERPWGdjOHJ4SmMzTW1VUW54SEpzckZna003UUNUK0RLT0xmUVJsaHY1OEZhWHk1L1JpaDVMY0ZNenZ4ZXIwUFVzWnNPb0RZUVA0Z0dBcyt3eVFvZzlmR2NtVllISllJWmhjaGlvRU1Jd0x4TVBJOWxJRTFQRXNHMjM2MFVwUVY3MklvcVpGSnpMc1Vxd2VGZ0tKVWh2UXlTeFRHUTJIc0xVWVQvSm9lK0VvYW0zcXBNaXpPZURhZGliaXRibXNrRlFXUktLTEpDc3JBYUlJRk1NRDQ5ZGRidDV0eWY2SSszbjcyZlFyeDd3cjBRdDRsWDB1cE0rTGJQSTFSTFl5bW4va01FY2JlV2pBSTF5M00yczBnRWZQR25sRzdKQUcxN01Zeko1bTR6NXFBa2pXYU9zb0Uxb2ttandEZ240Z3lHT1lXN2VURHJkMGQvMHg5L3M5L2IzMmZ4TnVDMllaakFZYkRwY1BaRGZ4VEthMWlET2JXS2o1alNXakZoWDE3SGwwb0VBbUVkQjZUYmZiaVd5ZUR3V2I4djNGMlBxR0o1RmtjVDZjN25XUjZacmFIdnN5eWMxa1dwdWNQdTMwWUdMcG5sNjFqekdVdVNsQkRFZ3F4Z2hvTFNRZ0tLZERFUkczYktLMGRyWlRHZ0ppaURBbzJVYkFiVWlBWmN0bERrYnUzT214ZHJKSktKV0QxWmQrdk5Fa3ZEWlB1K1YwU2dxU3FQdlY5My9kK1pmM2VqM1FuODV1Ym1XeDJKK3AwL3VFNlkzeDhZbnhrNHR1ZjRrRlVaNkFnZVNjbkFyaDJMc3ZkOCs1S3ozVzlEN2gxZVdpaTZPVnhxOGMyYTNiNkM0WDRWbjhhdlNCdUxMSDRvUEhPNzNyRy9BY3dybnJLRE5ad0dwK1o3cThWUXM4Mzl2YVdNa2s3ZHVNWm9CRmpjZStDZTVsTWVna1hrY2hrMHB1eFVEb1lDUHpodWNuNHhNVEV5TVNUVEFIQkNCc0dtZ29FU0xsMXJnQU1xa2NRUTJWQUpybWV1bHJkSG9kMUxicXoydWwwZHRMeEpONnpvWlVWSnZzSExabG1yaXJ1MjVWaExKMmZuNE41bXRGL2U4Wms3MUZPcUNrdk9xd0FnK05laEJkOWppdGxVS29MOUhpMkNEZUdJRHlPQlR5Y2owYlRtNkdzZitnWmYvMTYvRk9WZ1ZoTWpvLzg0enRRUmpqaHo3NkRzVVU2dlJwSXBLdDBrNnE2NGhxbUUySUYyY1pnTEU0dCtKZE9lVUVVR1lFN1hNcUVTUXNvMXdFVHpKdmxONlliRnIvVGMyZm0vV0ZNK3dlNy9qZzgrRllwOUdLWDR3UlJhalpiclpiQWI0ZE4wd1lMczNsUjY2ckhVOGNHRFBlQ1pkbnFUWlNpMlhnaGY2Mk1wNDhtUGgzRzVPVGtCTURJSWhnb25aeS8wd0plNTVZbUE0dHVWMUZVcTlGcXhrcHAya3B2Q01OdG5vcnZjNHdraVVBREJ0MTVGUXVGZG9LMnVXbjdOWTFCZi9VWjBQdjhiUTBTcm42YjY3bW1mTE1ZbGMyRU1wc1hxeDJhWnBBa09JN25XRm9TK1hYY1lVY3dqbjhsdWczZFE2anFnZ2V0Y3JDNHJkNUlNSjhQRjBJN2hVRTVIbno2NkJPVmdXUXhPWGwvY3ZMN0h4RU1xRmtpb0F3NVJUcEpYRWN3emk5ckdtRjFVZml5UlFVdVBiU3lHSVo1d2ZtOExsNmU1RmdPN1dqT0NEeVB6bmhwellZTisyQUNpaG1mQjNlbXd1R3dQd1h1WjNxdk96M0tOajcwbUdMSzQzWTdZR2JpczZKWFRKSXBmenFkTW1OWVlwZEQvdzhGQjhPd0xNZno5WEs1bm1zSjI2WGxHZFQ5L2MyeHFyUjFWVlprNG13UkxYWjJXd09wU0RRRGNmTGJFTVkvdi9uRXhEbytZQUhqODE5K0NnT014Rm9rS01zQXc0c1BZQ2p0YzFudHVYUlpwL1JHVzE4K1d3QVVGcXVkS093THRhcHhqdWkwT1FGdEtpaXdNUkt6R3d0d1VOaFBrNFZYZTd1VkNsdXA3TVhpcnB0Ry9EWXlBQldkTjVCY2k4U3owWlFQTTYxRTl6YVdOdmEzMmZwcFpnWERTaHdqc2lBNGxnZklhQy9vZ3lKWEwvTzBXQXhSR0NydzNrd0JERTFyWHlxcTJZT1dMa0pLaWFRS29mVlFQaDgweXZIVXMzK2hOZjRmRDJQSTRzN1kyTmdYUXhncE5DSkpLRUFEbW5LdUtGMUFvL2JJN3FXaTZZMmE1bjV6M0hNRERCOFpvc1VtQ3lqWUhNUHhBMTN3akZDSno0R0xRbEVBZDl1WkJwbm5JSTVFdE5OZ1p6MktYK2tpc3JweEVic3dScWR6dU9QQmJQRTlqcUZSdkFuY2FnQTd5L0RTQ1lpTnIzTTBiWmduVXl6Q3dUanBZSWZFekE2THJ1bHF0eUhMalhZWHhZa0J3eG5NaDBMNWJEUWROQjd1Sko0OUh2bDRZY0RucmxqY3UzZnZzeWZmb1RCSlJOYU1sN3FjcEJPRWNYNnV5Q3F1NHoxVnVRUWE1MjBkVjFYS0RRZjNrYkdpeE5UTGRicDJkSUNFRENqZ1pBVnVQV0NDUUprMlliYXRIZVN2VXJOYXJUWmJseExZYkNqd3F3R0RqUEc4TUFnQ3VNei9WaExZNGpxSG9ERjBUaXJ1aHJGK2pCZGJOSTlRdDA1b3VyTzB0TSs4TGRiTG5GZ0ZaVXlaZGFXdDZCcTZVWnBPV1EwWWtGOUxzYzFDY2kyZVRTQVlxY2lmSDQ5OHREQlFGcm5TeGIzUjBidlhNTGFNcDZDa0U5SUpXS2lpOXltWFJZZVNRNUdWY3pnRFJiTkFrUHJ3VEZFRUdQemJCbDFaVDJkZVZIZ2dBZHBnTXg1czJnNGxRbUtiRTQrYW9KbzZESTUrMjJpTDNIN0NqcXJKZUVlVWpMMDZHWENjcXNqczRNU2UwQlNNRHg0VStTam15Wi95WXFQSkFXc3B0NUgxVW1TK0loYnJkVmFzUmduTVJzbnR5NGFzZGJ1YWFuRmJsbEY3R2ZqcERVS0FVQ1NjUFBwR0xmSHZwM2NCeHNSSDBiaGhBY0lZZmZEZ3krOS9OT1lta2JYaDgzR25EdHdCaG9ZVGZUQnRWZXZLU2xkREN0RXRaOGd6T2t5T0wvUE5ockNmNnZYSWNLZ0QxeTBjOEljbER3WW1zUGFjRjVzNVEva3NoSHVkeXgzVmdFYmNoMkcrVFY1c0g0RWRvUENpRWFNVXZzc1hjMXk1ek9kRWR0K1ArZkRDSHR1cTBRZ0cvU3JWVDhaakVDNWx2aWhjcER6emR0QXN1SmtNN2trZHYxbTRnaEZJK0oxV1l0QjlLTGtWL3VHYlVYUjlJUCtSMitxdWNhTzhBT3MwZFBIZ3k2OGVmUDV6YWFDTXErZmpKSldVSWJYS0d0NG5WbnBuUUFNZHZ3MkdTaDFicDl6SkMwRml5M1htaEgwZXNNOWdKcnl3eW5MQTV6UkRZWE9ZNVJYb29zcHp1V3JycU5hazRUckxYT3Qxazk5RDZTWnp5alNQZ0NUNjQ5c2FVOW4wRXFFS0N4OC9aWTZZL2VBQ3FNY1UzbUNiQi9VNkkrV2VGd292S215UkJXRTAyWkRWNXJPQm02dTZrZlYxeWpQb3dnUXduRnVCRmN2ZzlXQm5jaTM0N09zeHlKTG9sdDhtanYrUEVXQng5NnVIdjZBU05KSzYvckxBbUtoQlNkNGxld0NqcDZMYm9jZ2FsQi9xc1hYQnZKam1SSVlEaDZmcHBWRGNueVQ3Sy81MXZuNFkybkpnbU1OZkVkbzVqcWxLQXZoRzdXVU4yUXVvU0dKWFNXeVd6RlE0NmVVSk1wbFdXNnhrcUhtVE9WbzVrQ0J5eEU3QmpabDgyRncvelVvQWd6NnFzbkFFcEs0NkxUSjdRWjk5eWdIRmhhcWhzNEhUVVQxbTQrMDJxd1VQT0NrQ05TeERNQ0xCdjQrTzM0R1NZY0xBY1h2WitUNkx1M2NmUHZrNWFDem12RkVHVE5iMHBJYVVZYUhRMFZGNXJoS3FScDFaTFI3N1ZneDh2bDduV1lIbjlqc1g2VklrRXMvc0ZIQ0h6NFI1WTZ6WTV2aW1SSyt1ditqUXpkZU5JcnIwazlmaWFSWllRVjVtWDc2bTYyWDJkWTNiSk5IdVVJSGZjbUt1eUFnaDNHUjRqcTlrd0dDYlJRZ21TTndjSkZ0aE85dWZ0WG5NaStZM1VHRW9LSXJsQVF6MDV1TUtoZHFzR1RDU3FkUVAzNDdlSDN0MC8vNzQ1TWZBbUJ3RXlaREZaMTg4L05QZlN1Z0x4cldicjVGSVk1ODlBaVpxUGRVb1J5SFhhcTRlQlJXT3hXMTJKRjlCUWdCLzVBZXBsYStzeDcwdXNBdTdDZk52RjVzSEhIZkVia2Q2Z2Z3dUw3MThlUUFsQ2RlNEZGWWo2RDIyL0dHelhhMlhtWnAwNkVjVGwvbCtsaGFLT1VaSTkyY1JqTmxqQTBhWlp4bk8rUGQwVXhKMjB5NWpvZ1l6TkYwRzFjSU4wdDBlai92cS9lQkJXei9TRzBDenRNY1B4dTZOM2JsdmlHUDhGc080WWpHQUFTd2VQdnpMajBGL01ESE1Kb09sV1FZTkJBTkhhUVJaaUVhY0RXY25EZ2RSV2dKdi9FOFpGUVJ3OTZBbWo0VjdtQW55YXVHdzJXSTRWcUpEL3lQc1hFSWFTYmM0em0yN2NhWmJwNTIrTmk2YXUyb1l1bW51bmFhbm1VWFBvcFltR3pjSmtoaFVncWprWVpBRVNTQkMzb25teVZUTW95cXZTekJGbFJpSXhFQkdtRUN3Y1RPTDRON1Z6YVkyTXpkNHU0WGUzWE8rcXJ4c2V5YUNpS3ZrbC84NTUzL085OVgzV1NsbHp3NkY4K2NUS0kyMVNsMFVRbGhlZmQ3aVRRTlN3czB4a3lCZFhLOTgxVUZsSkdVWVdvQUJ0S0MrUVBDdzJLWnhPMlhEa2hKYitGOE04RzRnaTE0YnJ6YzJWd2VuN2NqUFYralhuVTdYaSsvdTNidDMvOEhmTVZLUXh1UmZCTWtZaSttWnFabW5yOUYzQlVlVVllay9aYUcyWFgvNEFOSUVIaCt1ZTZ2b1FUZTEydDY2TCtjcENCY2dqaGJhWjRnWGMxbWpvTGFWT2I3ZVJHRmY1ZVpCQjl1TzkzejM1QVJkVS9PVWZ3OXhzaEpQWlcrYUFLTlI4UVlrR0M0Smh0dWlHQ2pqREpYQmNSMjhNUHRxbnc1ZVVrb3k2UHJGOXNmdklJdmZyL0dVQnR3UjJ6OTZDR0RzNG8zdzl2S1BMeDg4UWhxeU5MNnNqVnVGNUJzU0pETlRVN1BQWDRWeHdDUHZwUi9idmJPaDdsbXYvL3UvNnc4UUtMMGVtcHg1VmR5ZHRzMnJnM2tQMCtMQk9FTmhoSytRQ2MxVGlsOXB2bDduVzV6STdxbHdVVVNuMzROSU9RZmZjSHpTaWRqQWx5T01PaGFMaWpsT1lGejZaQmhiTW93OEtxUEdWUnNjTDVRT2NuYTlWckV0cjVvc0dLR1YxdXhlcTFYRHc4b0d6MWNBQzE4Ky84OXBzQXYzN3Y4VmpjbCs4aVFKUXhJR3dKaDYvUGpKczFmNWROZ0hOT1RwdUtYLy9JM05abEQzZXJZUGYreWlRRlpCR1p0R0c4UUlrNHh2cjZ4Wm9rbG9ZQ3NjaUxyVDVRdEJKYVdsK1dxZHIvRlFLSjBLekFoVUFpcmxTZmJ3c0hqUzJYRXNVU3NCQ1VaV3JPeklNT3hYbmVJSWpNczBnY0hlVkx3NWUyTDkwK1gyc201SjNxcGlraS9mR1p6UDFjOFpHOGdpNGN1SDNuNDMvZWdiSW8wSGNxRGNIU21UbndXSkpBeUFNZmNtUktkeHhTRGdHSWNoVDNkMjlaQTZEUWFTTU5RSmN3M0NJbUkzd3Zlc0tlOWt6cHZzNGVGRmtlVlM2OVJ5aUs5WHdTU2RkemxQZ0V4MkZ1eWx6Z25rZ094cHh4elFVcFRUazhFd3lZNHBBeE9vQkdOWjE1TmhpTm4zTnRMUktMU0RmVHNtMHdKNXhOZTBPZ29EY094YUhNNm9MMDJIZm53NThlMjNFbzIveVFYMkRoaVRja2ZTRDVLQk1BREc0NmR2a2trNmhON0w2WUNPK3ZhVEJXb05tUWhqSWRObzFhNVNDMlROTSs0QVdDNXRZcWZUQnVOUTQwV1JjVkVyNWFQemFnWmRRcVBsTmkyak50YjhmUFdNUDJUYmtqSVNNb3l4bkRFR0k0UTVBMDBYd2xDdURjNitWUFczUEpwdUtRT2Z1b0UyMkpXbWsrbDMweE1UQU9PUkpBM1pia3orR1l5aE1HUVlrRFRTN3IxUW5vaGpuWno4T0FyRG9ER1NHU2hhSE5XcVpZOW5PK2dBOW5PK2VEREg4Q2R0OU5PTkd6NjNEWTFKNVFiWXRNNVBXY0c5UlVZNytWaEQ1R3FnakgwOWFDbHhRR0JBRkpTY2cycFN6SEJTQWxVUzA0WGxocXNlTTNSY3ZiWTBzb1kwd3FJUFEyTTBxbTBXUnlCaEQ0ZjIzT2tYM3orY0lEUUdPZlRyTzUybzdEMWxGbjFoRUJoUFp1ZGVoNU1IZmpxTk9FQWNVcFFNWVF6MlFNS1BhanNJZGJXR1RvTXY3WmhqWE9hMGlUQ2FWZDdkbzdaU3JIZ0tZY05WMit5Rk96Ni9USzJFcjhRaTE4cFUrUlMwcmlzSW85NnFjZlV6d1U1R1hKWmtoZ3lKU0duZHBwYnNIN3NON0ZQUFJmN0luTFl0aml0amNPOE0yUkNBTTlrTnZTTVJ0THZ5OUY2RS91SGRTeG1HbkVQdmhrRlFmRFdTUGNkaGdEUkNTYk9IRHFYejRMOFM2M3BTckc3QmtNenY1cG90eldIYmppV1ZZelBOZGpXTHRxcGFiUUdNWGw3by9ydUNIZjdwYVpFdjVHM1VTazQ0TC9KOHNja25jUjFFZ25ISXRSc1hkQS8rc2VpS1ZicGNsdVhwSHJqUFJjWFdBZGVzQU53YXoyWTdQS2huU2J2MkJXWGdNYTJhWFVjaWFuZVZRM1RFNjArLy9mN2g5RU9FY1VzYVgwM2VxUXU1Yng5RWlRVGp5Wk81NXorRVUrWWRQOEVCQnN4aDJaVXM2RzFsYUl5YnlpMlBQTlhoV3gwMms0RnFjdGc2Ym9zdFdybEliUlU2N1hZV1IzWHQweTUzNVErRnpHeVZiVlZFMW90S0lEN2pGRHFiWmp0NzVmWTU3ZWtJZTh6V01pS2YzdFpSaWsxWGhHT3hOVU8zbitsMlNuSHFDOHJBc21JMTZCMkJxQ3VjVDlNcGN5RVZmdnY5MU1UMHc0Y0RHQU5wM0lZeDVqMC9nekU3Ty9jbTdFcVZkbEp1eElIQmd1cVFxOG1JTXZDWGNqTjhCYmFUekhWYTBwQ3lsbTJMSE9PakZKUTJ4M1JQcS9qVnN0V1RHeGJudVpWempxOTMrWndHWWVpVG5BZ3VySmF0QWlLbUVPTTd4U3pmS29xQ2o5SkJCeC81clh1R1BUNkhJOVp1aHQ2Z3RQTjNLZ08wQVIxYXd1Y3E1ME8wMitPTmVjSS92WnVhbWU3REdIb040a09IZ1RJNVlqR0dLV01rVEFERzAyZHZuRDUvTEJieEozT1lTVjMyUk54aVUwdlBFNnRIbEtIUkxLZzJraGU4aklMTUtyTm5UYkYxa1ROUTI5Q1pwc0JtMVRuczByT05lck54Zkp3bC9RVjh5Zmo2TlgvUi9RL2FiZTY0VWNHeEI3U2wvRm1YQmRjQnl0QzRXMksxaXg0Y2xmY2JFelpSd3hOeis4b3dtVlR6cXMyTnJYZ2k2Z3VYMHpsNnp5ekUvRDc3dTM4QmkrbXhwREdhUTJVZS9ZVHhPWXd4R3ErQ2RyYzNWa0FjSUk0eTR0alMyN0N3YXRSRFpXaXNScE0yUUNlVDdyMlBWekZFMHVsMHUxMU9jTzh1NjVTZzlXQUJ2dnQybHNSOU5nT3ZMRnNSK1lKTEpRMUNIYVdPV0sxZ01jYk9BeVRBOFN5Z2NsMVN1TnBTQnNsQnEzUDE4YU0vNlQ0SVdiU0t0VEVZWk4xLzA3aEIvR2E0bkUvbmtxbWRHRk5JMm45Q0ZqTW9qSWtKb294QmRiMEZZM0lJUTBvWmQ4Q1luZnZIcTBTUUxqQ3hIWStFSTB5U2g5Nm1sbUdRWW9JcmE2dWIrSTQwdTNGZmFNL01rTTl6VkNnYmw1ZHhIWW1hdDhkYTV6K2ZuTE04Q1gyZUs5WkZUc2ozOTM1ZXBobitwbDBoZWFGMjBZTFUwT2gyaE53Q3BWTW9kWlN6ZEhIaFRZVmNBYjBhcnpYVURzOGJsOWZUNExmVnRoV0krbHdTQ24vRUt3amVrTlArYm5acVJvb1NZcnR1d1JpV2xENkxyMlZoeURCdVMyUHUyUnU3czV5S0NZelpJNlVPTWpVUE9DQmNyS3ZTWEVtK3ExTkYzdUhscXNFU3Q2ZHBkNUlPeDFjVkNyS010RXpOKzd4ODUrYjBwRjF2bkowMXpzVnVoemU3VFAzVkFwMEphS0NXSUVTeVhVa2RIcGQxa2NLakhpbGJPUlIyN0dwVVdyS2FyMUJxMTRZSDBjTmZDeVkxTVZqMkFZcUNjTVM0ZmZIODg2ZFR0MkRjUnhnRDQvV25NTzZReGl6UXlDZGNTUy9EeEx3SEEzWDRvaGd1dXhzR2VibVZiTkVndTZXWEZPQXdsVmI5dXVYVEVueEtlYlYxZVVVWmpBaXNlRk90NG4zT1lqSEx2STlxUjliUlBvVVBZdGxNc1pqcGtpaTZpdVJ3UnFiRC9Wd0tyVW1sSkJlNkx1TEJka3F5Y1Z6ZSs3aGdNb0xWUk51TkpEQnRwdlpMd3BHd2t3dkczejVIWFJBV3c5SjZGNHpKeWM5Z0VKL1JwekUxa0FabzQvV0xhQ0w5UGlZSUpmT0JIK1dCK3hWOGVPc2M2a050SFZ4b01kaXRNcTlkd25jOVBBWVRuSlBDa0M4Y1FTNGhLNFRDZTVkMWZNVlZaNDBtOTJPTUlEQXhzeWNVTkNnV3lVZkhCeXFVT3BERDZFWnBBZ05lODV0cXpCTjJuOHNGTE5LQVlpOVNZSTZPWW43WGV2VFZzeWVQcHo2TGtqdGd5Q3dHRS9GQm5JeEpRNmJ4OU5sekVFYzA1Q25CT3kzczc4bUZsb1NMTTc0RjVzT2d0aHJKQlNmOWl4aEJJTXIvZDNjMkwyMXVXeGcvMXEvRWo2ckI0RUFjT1Fsa2NDV1dPeEh1SFo0NmNhS0lzUlFKb2tHTlVwUVFRU0htd3hpVGFDQnFRSklnT0t2L3c1MlYvajFuZW1kM3JiVy8xbjQvWXRQVG5sUHV5bWxQdFpxNmYzbWVaNi85dnZ0OVkyQVFEWWlIUHk0cmplSkQ3cUhjYUdhT1ZqODZOeVQ4NS93VXRKNHB3WFArZC9zajN1Vk83WlZHR0dMUGp0Z3VCNEMyVjdkUUVwZllYUUVJNFk5YzZ1Ymw1ZVdwM0N6VjNzMy9JelNtV0VoaHVHRVFEVDhZRmcydERZalJoVWkybEcxVW54NEJSK3ErZkVmeVFIMEFEK2pVejA5MlFTRmJiRk1YYmV2aXlsaCtUMGtKUzRiYnd6L2VDOVd2dSsvemFHNzRLRzY4dnZ4SlNJSnQ5ZHYrZmZWZzR5U3hnN01vZ0JBazBCK2R4OCtnaXZ0VzdXd3BpaFlaVXk3Und1Z0Zoa2lOZmc1RE9HVm1kbTZoV1RyTHRuSm95SnZVUGZSaExjR0QwaFFQQzZKRTF2WVBWdVU3YlB4dWJYRVRHNWsrcm91OThiUTFvY3NHSHI1VkJUY2tpUFA0eUdON1pSVkNRcHdrcTJVS1l2cTRRbEdrNFNmNytuS1R1OHFjVmFMejRkREV4Smd4aVJKR3J6Q2MwaEJPZ2VTWWp5MFdTb1dyWXVxR2ZGMEZ1N1NNWGZCWUtiMEZIYWdFdXBBdDNOUVVGNXIrcEc2aUxuZmZzRzBZcnAwWjdGMnk1SjVSdkxiZzAyWWNvaks1ZFF3TDg4UWhYbzJvVUZUYVFPSWlsd0lTTHkrUHFZdG1KZ09xbUEwakNhZEpHSXlnTDR3aENjTnBGQ3MzWnNJemMzUFJadjJzMEx3Z3Q5eDAwdmZsQytoTUJaQmFpVTVTSTVSVE1jM3NKL0dld25GMkgzWTJSQTlSQ0l1b2ZTcHl1elR1VkFBMUpPbGRHTmIyZG9uRkxla0NVTFNGSmpvM2dPTHpUZld1WGE5bkl3dUFZc0toaXluQlltQmd3TzR6dkdBUURha05BY05vWTBKckE3d3lGN3ZDemZXdGNocmtBZkdSRnJOTG0rU2hyOVhCWTJJSlVTZTdHd2VybUtZZmVucXZWa3hQM0wrV3hET0VSMkJCNlBLU0szRVF5TUV4QXNGakZkazJicjlJNCt6eDllVXhEYUtvbHlwUlFERWRVaXdtcFM2TVNiUkx1c0tRczZ0TlEybEQ0Z0N2ek0zSElzQy9WbW1VMDA4d0VUNCs1YSsvME1xbFVvQnBZT2ZvZkc4aktkNkJCa1NOTnpZNVZHY1o5amFPdDNDUEtGNmhKQk5SYjVuRk4yWDlJQ1pqU01ldGZUb0poTGRFT1QxRnVvbTlnKzFOaVhNOXZwRzRMV1d4NWE3bVVSS2dpWFN4VmNuVXNoRXd5QXlTWUxwd3NVQmhlTUlJQnNYbUZDME5Nb3J0Rkk1akJ0UUJVUnJOMXV1bFFsdndlRVFlMUtzRERsakdKZU5xRzhyNisvZytaUDVacVZTREtyR0x2T2dNREYzREF6UHlpbmo3czVYVnJiWGRjN29uREVWQ0xRTlZ3OHZrZHM3MzQzaVFnOTRIZkhQbDVMYldiaFR2VTArUGdrU3EySGlHK1hocE1RWlpFWnBnc21EWnlWaElHTUdnVXhtYUJzRVlZTEZCTkRRT204YmN3c0xkY3gydnRyL0M3SUpHNlRNa1NLN1l1S3JVTHMrVHk4WVI4VFc2ZHJCT1BIQndnb3FPbHIwMWJPSlhrbmhUbVBNandGQ25MNFd2TE9CK3B3enVBN2lGem01ck93Nk54ZTRSU0FKQjVKL0FHd1FpZHdmL0p0Z0RTTXpQaE1PaDBJUUhDOHNqaWtVZzZLVU1Kd3pTUnIrMGlrNk9DWU9Ed21NaEdzbldMM0ViWFF0ZkpWVEl6Vk8rV3I2N2VzNUExNFJUeXRiVzJnbTZ1eVNTSDZ0Q3Z4ZGt1M2FTM0k0dnYvK3dlYkJMTi95QS9vbjZCbWdjZE1GSEZmcUdUS0hTYkdFdlFjNTRBWDlDTjl4b1oydWx6UE5pZEFIOGdWSEJaVEZ1TE9MUWhSQ0dnV0Ywd1dFd0dsT0dodHNyVWgvUmR1YjBDSThyVlZxZ0VOeXY5UmxNMHhGZENLMWhxQ09DYW1LMW0rMDJqWTk2dGN2VHhNWW1YbWZ6Zm1YM0VQS3dJUHJJWnZNS3F0VnFOYUR1b0M0dWl1V0hYRFdkNm1DdkxrQjAwZzkzcmVkc3BuUlp5elNKUkJoV1VhR1FiUkhKZ3VjRk40ay9ERXNhaklZV2h5ZU8rWVZZNVBuMEpMbTZrYmpNTmh2RjNIV2VUSU9OU0NlVnJ1YStQSlRMeGVKRjhRSUtCb1lEYkxXdXhOb1hBbVlQQWdPK2w0NU5BWVFXRGg4R1g0VGhmOG5sN3F2VjYzUXEzOEdnaGhuajYxZkVjSTFyWnhBRXFMSmVlSTdFZ0FTaUNJVnNGSUtGTXkrTVN3SUJGcUFjaHBTR29zRzBJWEZNdW5Cd2ZjVGVMWlVTRVArSm5iTWFUSGQzeFlkcU9vOERJQ2lQTnpkUG5VNG5uMCtsMDlmVmF2VStCMnNUNEhOSDJnRUhVTGZRdU1PWEg0WVBvMC9sWWZ4UE4yQThlZ2JTQXMxYXVZc1dVSUFNb2Z0dUxTMUdZMElUSVh3NDAwSzBGL1k4MGhVR28wR3pxeTBPb3FFbldRdkh0TUl4Q3p3SVNDUzdzNU1RdDlHN0ZlZHVSTjZyZXNSTWdYcDZrbWhTcWZRMUZMejQxMmtCZ0FoZzlueldFRjZrSzY3TERYRGt5UUZtN1I2c1U0MGtvTFJCSkFyTlF2ZGFPaTlZZkFhOCt3d2ZHbVpXa2NraGNZUUVEbTBYb1E5MFRDeTYrRnc2UGQ4NDJGNyt0TDEvY25pTHMwMjVtdW9JbWJ5WTRlRURmK3RTRkQvNTlQMERKSEpwNStRZ1RwZFdiSy9WbHlLb2lEa2dRVUZob2JBdDR1RVIyWEQ1d0RBelNwK0Y0NDBsanZGeG5xU0tSOWp3VUVnV0FFaTdkTG03TFhhSmZ6ZzRnbGZ4Q2t6dzVaN3NyMTk5VWVaUDhtUFNUaWVQY1lPdGZ2TVpraVd4dHJuK2NYMzVlUC84OWwvdkFNVGM3S3pDUUNCWWx5VlY0YktJbmxPSGhyeGhhQnJ5RUEvaGNNNHFVMHdjSEFmbklZR1FZd1FSY00xUzdlUjQrOE8vMTVkWDE4N3BSQjhkZk1Gd3VNTXdoWXpFUkczUXJFRVRScGsrQlZIU2tLc2R2S29XR3E1RDJwVlZFbnBBWjJCSmQwd3pFaVlzbEVNc0ZvTnVGc1BEWnYvME1INW8wNUE0QmoxeHNJbkZnMGVZS1lSY014K0wvZlBkdS9aU3BvYWJybkVKZDRZTlZRbWJEbXk4U25RWWRTT1pQTjZGWnV2czdFejhwU3BxT1o0WEZ5T1JhRFNHR0VBUHN3S0RrWVJsRDkxYVNCSm1hZVppRVRBc3JKUE9BYXNSSFZMWllkWnRhbDZ4Mnc3bUYwUEVjbzMwRFdRSmhrazBHb2tzTGk0dXRiUFpwVXkyVUQrRHhqS3h0cnFNNjlOUEt4dTRWL01VYUJTeVM5Q1dhQVFMa0ExekloMVVUWWN0Y3poSVNIK0lzTkNyMUVHNUlCa0ttbTZMeThJTnhFSEQzWFM0c3RRV2lDRXlJMlV5T3lPTWcxTEJuZ1JxQVNzR1ZZNWVBSndsVVhMME1Id2FQeFFob0pKZ05RWVhDWmtVNDNxeEx2ekJIV0wxV2tIZm5UdE9kVWdhZlZvYnJPc3dFNjNnd1IwamlNaFpSc3RFeXlVczdTTXpoV3FlNktpYW8vSGpReEdRTXNCbjQySEpyTUUwWVZKVCs4TnVMdm9zV1h3YkRKTWNLa24xTVIvaVlicFNDWVFwUkxsRy9lZzBEQU5rUm5sSTBLRVB3dUlEVjAzTC82YW43VW5ES1FndENZYUNpY0xaYVBVTXd4SUhuMWxzZVFBUWNveU9rQW1iQ0RXRlRpenFseGx5MlA1TU9Hd2hDRTJMMXRMNGdvZUVBS0duajM0V0ZiWkJiSXYwQk1ORWgrQXhhUG9PenNOTU1Fb2lrNVpJaUlvRXcvWFN2VUtxdFE2SmJ6WlBOaWIxb0RNQ1g0NFJtNFRMSDdybk5Mb0k5Z2lENFhDMlljb3UvZjFhSWN3enlqVk1Kb0xLaEJwY3Q1cFEvNXZRK2Nnb2FEMllqSkFjMVB6QlVaaUcwOFhpVlJqRERoaVNoclB2RUYzNnFJNFBRMlJjRWhFempXSXlaalBoY0t5SFZ4a0dITU9rN1F3TGhHa3JPQW9IaTBDWEN3dXNSalFZY05QZ002MmVYSVJBTkpJUmZKQnF4eVVVTmR1b2g0RWpIbG81WTJMWTVxR0hQNGJmYmpQUWdoaFJGTVRrWVpLQ3RWaW0remFITDJpQTNXRllQRHh3Y0xjSUhnd0k0cEE5Q0hlTk1jNms1dkpxVFhJUlRQS1FCQXFLd3dqWGc1YkVLQ2VoUTVPekNBWlkrVjl5WWk5VExMY0UzZXF3QktKblhKMGlrZ2lUQ2VxRXRPTEE0MTNqVGdiakkzWStNQktqbzA0U0EzNGtIQ3k2WHFuSFlUaHdtTlpqY05ETXRpN0hXRWhNdUlvSjJJRGhkSVNieHBrSlhBQWNHS2FZTlRRRjkvVGh3Y0ZpOGRyMUpnNGNIcE50bjhIaE1veURpTW5XL2hHcnhpV2NjZGZvaFJFc0JFd0tpb0t5eHR0UkM0VWpNNGRjSFpaZHIxK3pONnlXTHY0NFpHZkt1akhMTVNaV0paUitxM0IwSS83VmIvMlpBSEF0S0FxMk5kNG80em9pMDRPRVdwY052NllMSHFWdWlYaE10bGFFcU5kbjFNbkVJWk1lYXFwZklYQkRNSW93VFNZL2NxTlJlSkVZN3YzK0dhd0N6aVd0cXptMWdEQWlCZ21PU1hIQllickhMcEZOR1R0b0NEWUl5eGlhQkFzS0c4VDNEUCsxeXhvZHg5R0g3QVFaR0hBaGNZZUpWb3I4NDF2K01GL3c5dTJVV3dnOEtHMXIyS3B3NWNTUGd1QksxcUFIRFphb25BbW40dEFKakJJZm8rNlgvZTJvL0ZzMWZBc0FoMkN2TzN3WEg0RWZwd2kvYWNhZEhvYUluMDVHZTYwM2ZoekU4dys2T2t4MjdqVFl3NlR4WjJFRVBMcFRBdEpIUDZFSEZScU1jM0NPb2JvKzRTNkx1QWNKeHlRNi9KTmcrRGJzZHFMMmVRakZIby92UUY4YnU5TVZqclMwTTVQUElMLzk4UEtZWER5QnVMVFNOK2pMeFQzd0xpRG91UlFBYnhMc2NQZFBKT0VOdzkyMSt6Sng2MFZZcW12MXVjcCtjcmNnREF5YUFIOGFqTmNUSk5nVml6ZWNydVg1RE01L0tPRHN0ZFhwb0IvYVcvVFdwUWE5eXgrSUE0MkwxamR3Y0M4Ni9pb0MzbzRKK0ZVUGNQenI5ZEZ6REg4UERHZXo3Zy9GbDBqdys4b1h4SGV1T1g1bWlBeC9xMEIrRElsaGZQd0s0L2VHMGMwNHZiTUpCSDJmU092eDE0UGg0WnZYTXVWN3l2dWYrTzBYTGZmUDlpZkorQTViZitMWGhmR05SMFYrQUl6L2l4cnVvZjdxbisxL0NFNU9wN1A4SzNRQUFBQUFTVVZPUks1Q1lJST0iIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTMwNy43NjY3OCwxOTAuNzE5ODljMCwwIC0yLjI2MDE5LC0xLjA4OTQ0IC0yLjI2MDE5LC0xLjk5MzgxYzAsLTAuODcwNjggMi4zOTgwMSwtNC4zODI1OCAyLjM5ODAxLC00LjM4MjU4di0yMy45NDkyNGgxNy41Njg1MmwwLjEyNzgxLDIzLjc1NjQ2YzAsMCAyLjY1NzQzLDIuOTYzMTQgMi42NjM0NCw0LjA3OTE0YzAuMDA2NDgsMS4yMDQ3NSAtMi42MjU4NywyLjkwMzQ4IC0yLjYyNTg3LDIuOTAzNDhjMCwwIC02Ljc3OTMyLDAuNDYwOTQgLTkuOTI2MDIsMC42NDcwOGMtMi42ODAyNiwwLjE1ODU1IC03Ljk0NTcxLC0xLjA2MDUzIC03Ljk0NTcxLC0xLjA2MDUzeiIgZmlsbC1vcGFjaXR5PSIwLjUwMTk2IiBmaWxsPSIjZjU1NDQyIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48cGF0aCBkPSJNMzIxLjk5NzU5LDE2Ni45ODI3NGwtMTEuMTA1NDksMTguMzc1OTkiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2ZmZmZmZiIgc3Ryb2tlLXdpZHRoPSIzIiBzdHJva2UtbGluZWNhcD0icm91bmQiLz48cGF0aCBkPSJNMzE4LjA5ODUxLDE2NS45NzA4Mmw2LjU0Nzg2LC0zLjQ0NDMxbC0wLjI5MTA3LDcuMzkyNzZ6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjoxNC40OTM0MTAwMDAwMDAwNDoxOS42MDU3NDAxNDY2OTk5ODYtLT4=";
  const vector_menu_icon = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxNDAuMTc2IiBoZWlnaHQ9IjE0MC4xNzYiIHZpZXdCb3g9IjAsMCwxNDAuMTc2LDE0MC4xNzYiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yNDkuOTEyLC0xMDkuOTEyKSI+PGcgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIj48cGF0aCBkPSJNMjUyLjkxMiwxODBjMCwtMzcuMDUyIDMwLjAzNiwtNjcuMDg4IDY3LjA4OCwtNjcuMDg4YzM3LjA1MiwwIDY3LjA4OCwzMC4wMzYgNjcuMDg4LDY3LjA4OGMwLDM3LjA1MiAtMzAuMDM2LDY3LjA4OCAtNjcuMDg4LDY3LjA4OGMtMzcuMDUyLDAgLTY3LjA4OCwtMzAuMDM2IC02Ny4wODgsLTY3LjA4OCIgZmlsbD0iI2Y1NTQ0MiIgc3Ryb2tlPSIjYjgzNTI3IiBzdHJva2Utd2lkdGg9IjYiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PGltYWdlIHg9Ijk2OS43MDY3NCIgeT0iNDMyLjQ4MDE3IiB0cmFuc2Zvcm09InNjYWxlKDAuMjg5OTMsMC4yODk5MykiIHdpZHRoPSIyNjgiIGhlaWdodD0iNDAyIiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVF3QUFBR1NDQU1BQUFBaFBnK1NBQUFEQUZCTVZFVkhjRXdHQXdRS0JnWURBd01FQVFNS0FnSUZBZ0ozZDNjREJBTUVCQVVCQUFBSUFnSUFBQUFHQWdJQUFBQUFBQUFEQVFFQUFBQUFBQURiM3Q0QUFBQUFBUUJ5T1Q4RUJBUyt2cjZvcUtodkVCc1FFQkRPenM0ZUhoNWxEeHVLaW9waUVSdTV1YmxVRVJ3OU96dGdFQm1XbHBaMmRuWnFhbXFHaFlWSElpV3pzN04yZG5iYzNOeUxpNG8vRlJwTElTVkxTMHRaRUJsaVlXS1FrSkNQajQrYm01dDdlbnFCRHgyMHRMT2xwYVZyYkd5bXBhYWpvNk9BRVIyNXVibi8vLys0RUNXeUVDUzNFQ1hKRWluSUVpbkNFU2ZHRWlqdDdlMzQrZm4xOWZXOUVTYkVFaWl0RUNQQkVTZnM3T3k3RUNhL0VTZXdFQ1N6RUNUcTZ1cmc0T0NxRHlMOS92Nm5EeUxpNHVMeDhmSHo4L1A2K3ZxMUVTWDgvUHorLy8vbDVlVzZFU2JVMU5TWERSN3Y3Ky9MRXluTHk4dmMzTnptNXVhK0VDYmUzdDdrNU9UbzZPaGNYRnpPenM3UjBkS2dEeUgzOS9jQ0FRSGo0K1BhMnRxZERpQmdZR0NqRHlHd3NMREl5TWlIREJ1U0RSMjl2YjNZMTllYURSK2xEaUdvcUtoOGZIeHRiR3haV0Zpc3JLeDNlSGpBd01DMnRyYVJrWkowZEhSaVkyT2tvNlJtWm1henM3Tk1URXpFeE1TNnVyckRDaU83amk2SWg0aUNnb0pvYVdseGNYR1lsNWR2VnlkblVTZElSMGRnU3lLTWpJMmJtNXhWVkZSMlhDZFJVRkRBa3krTURCeWduNkM4Q0NFVUZCaDdZQ2hWUkNXekNCMUZOaUJDUVVBNU9UaTZBaGVBWkNtZmVpcCtDaGlzQUJNbElTQzBpU3l0Q1IyWWRTcXRoQ3lLYWlqdHo5UEpDU2lUY1NycytQaUZhQ25VYVhmNDV1bnE4dkkzTEJyanI3WDAvLzZtZnlyUFUyS09iaXB0Y0hEWmo1Z3ZMaTIvSFN6QkF4bk1QRTY1YXlzYkFnVzBBQkRKZTRYSEl5MVRQUlB0djhYbDdPMjhNa1BrbmFiSUtUM2NmNHJEU1ZqeTJ0MjhleTNCUVNxM0pEWnpOVGRuVUVxeUd5elBFQ2pneE1qSVlXN0JXeXpKbUM5eFV4YlZvcWlHSkN5NkxpZzJCUXFDWVJ1MlZDbVZIQ3FFTkRSb0N4YTRvVys4cW9PeWxsamk1ZXRTQ0JIWDBNQ2ZoVXpGdDVaOGFGK1hieG01bmk2RFRGTGEzK1ROd3FxZmoyK25jWGVvVUZ1bVBFa1E2KzBMOHNxYUFBQUFQM1JTVGxNQURoc3hGaEVMQVFNSE9DRlBQeVpZUnl0aERHbHhGbnNzcE4rUVhhalFMSlcwaExLL2ozeEs1MXJJNEVPcmJudklxOVR3MTczRDdZTFBxZkZqOXQ4cnVBc0pBQUI2TFVsRVFWUjQydFNZWFd2cTZCYkg5d3V6TytWd3JnUnBZWVBNUmJWN09yM1NsblpYdWk5dGIzcWpiTFNscHdSUjhTVXlLS0tnb1BVdGFlb0xKQm9RSTRLY0c3M3FoNUIrcnJQV2V2TEUyTTV3RHM3ZVoyYitwdEc4Wi8zV2Y2MG42WnMzMzE5YklJZmo3UTlPcDlQaDJuR3RhOGUxczBNekVpM2c5Mm96VGc2SEV3LytzSTJuZXZQMzFkYjJXNmNUb3ZLZzNQNjlrNU05dC92ekllbUk1RHM2T3JWMGhCTmJmM2lFKzdqZDdyMFRQOHpoOFBjZU9KSFQ0ZmdiOGRoeU9OK3g2UDBZeE9mUGJnenErUFB4OGZHK0Q3U1AwalN2QmhxUFlWSXRzWjhTVEdQVk8vWjZ2ZnY3WGpyRzV6dUV3NC9oUEx1N3V5ZW9qeDgvL3ZJTGVNanArSXQ1QmMzN0FaM3NjcjE3RHd3K3VUSCs0NFBqZmE5WGtpQXdUVlBIOUZWcnlzMGFxa21TWlpqV1JLdHJ0STlXZzhNQUVCSWFTNUp1R0RNZE5GT3E3WGI3L1B6ODU1OStRaTUrditmOU85ZU9BOHZvcjFCRTRBVXdnaHNSUVBaSnRRTUlSV3ZLR2tSTUFUZGxNL2ptdWw0dU14YU1HTmVMWlUzVlo3b3ltNTJkRmM4QXlqbVUxZTdlSGhiU08rZjJud2ZoTFVMd2ZNSmFnQ280T0RqUXhocmVMVG9Bb3BTSHkrVnlDRnFTN29jcnlYd3V5MFA1dGV5R01mY2RMdTlCTUJzT213aUU3Q0tSVjJaVkhhc0pTdkdRTlJlWDg4UFcvNjhzdGgwT2RBTmlPRDdZMTlEVG1GRzQ0MVc0R0lkZERNaC8weEQzV1E2WHk5ZUgwc2ZjUUlZeUM0N01BbVVJWkNUSjYvVWRmMll1Y2REdzg3MWhiQU1IcUFtMHdzRkJVNjZ0SlhVVkFlYlNpbjdBUGt5UG9JSDFlN0F1M0lrZnc3OXdZaHROTFRsdm1YMHhKTmhrSk9xNys5QnRBWW5MK1IxaGJIMXdVWGNBUHh4b2NIMXNDRU16bWJZMG1rRU1iTEdiZWlBVkNvVUhMdHZQTlQzK2p1aUVLeXIzTmp3bUVwVzFYUzhBSVkrNHZuMG53U0hqTFRqaTBPZURjUUZLWXNrVGhCWlkrWDh0Zml0Z3Jzei9wQUo4TW9YZkVvUEVXZG5zeEdqSXZIaVlUYUJ5RE4vUm50dURBL0MzOU1pUFRvOS9EMGpzMTJDUVFEdmNyelVBTzRPSE5RWXNPcVo2SGFhWG10Ui9SM1FFVFRaT2pFbmhwWDJZVjZobVZvTXpBWUV1NGpzODhidCsrRllrUGxDVDhNMTB0U2JmRCt3NW9lRHhZdysvWUl2ZURKZzBuVXhKM1RXOVdEVFhUUzFOVEZtQVZsQnNqbm1nbXpMZHloOVpZQTVsSXhsVjNYZm85cnUreGJQcmx0UGpQanJUMWViOW96MGJMd3hnbFVCOW5RQkNXRU13R3NGa0NuOTEyWXhXc3UyalY2d3NLbXRFVnBZak9uUnZacGRkV29NYXpwczFTYStlSHJwZFAvN1JYdkhPdjNlOEQ3VngvMWlnaTc0b2diWDR3Zk04L2xYc1BQRFhVZFZ0ZWJhU2JVWm9WcFRKMGs1bnlnNWZ1N0IxR2pzUmhNS0tlU2lEUS9aOVJ5ZWVQK0lPZElWUEh3OHpjQXQxdXB3dEkvWUsrSzBDNEg2bm0yY2M0VVp0elk1MU80M1BvY2JOQmZPSkhZZk9KVFlrOUNHNzlMb3pURmE4ampoYTNrLzRhSXpIRng2R21uRjI1Ti9aMnJ4dHVrOW50Y3owcFQ5ZlVaaStOQUhCS3p4ZzdPYVlSdzFOTTEvSlNCSVhQQzdCQTVOT0g0bit1R0FmM0pNT1FsWTFRalFrUU1Dblh1Y0o0TXpOdXl5c2lLeHFPbE9RcGJOZHo2YVBWeTczcWJxY2RFZGR4REd4R2orSHdPdGdEbUlRcHBpZkF1YmZHdmZOUjJkNGNEWm1zNW1pS0ZWVWc2bEk2aFE3cVBacWptdGhNKzFhaFdQZ1hXUm1HTHJPUUFFY2RCQTg1TndQSGlBems2blZhNmJUZFNTcnFnWWJUZXVQbXZmUTgyR2pkdkVQOTZrK1dZeTZML282cDJCYVljNHhBSVhCUGI2WElnQ1dlRVJnTUFnTUFjWE9nbDZwRHlxRFdxUWUrNExsZmgrMzJ1QlllR1lHY2hrVGxTWWlLZFFuTnBQWSs4cWFtZWZkWWVmMG41dFV5dGFubjZYdVd1c2pPNWdsTVdjYWpRQkQ0WkdjWUQ0Uzg1ZHVlTjF1RkZuVUhRb0drendqRVNBU3B0MHlDNUhpZVBySW92OFNHREpxRnh0VlBBZTNDbU9DTGI0KzZiTDAyRHhTdDZvYTduNDBVay9kcmcyTTRYUzM1ZWY1YWlpd3hnZU9BZXlRUVE3Y0RkZ0xPSVNWMFUyWHJ3bldLT1FXRTBTMWdSOWVPc3hBNWsvTERsVzJzY05SQWFFaTU0dEdHWE1pR1NpYkVTL2JpYTI1d2ZKb2tmRWUrVGN3eHM3dTJZTUpZL1ZZd0IzUm5ZSWZsckpKZ1pVRnRnV2wwZWkwKytod1RKK0JtV085a25vR3hVNGhzZmJBazg2dHdHSmt0Y0ZJc0tiQmZZRC80NW1oMzlwVVZPaVNqbVU1ZzJwSHhTZkRod3hhWkQ1YVdkb3lkRmM3LzdqQnZ5OTNkdnVEcDhYSTdJNE14QUkwSDAweUQvZERQa1NZL2RFd2xFYTcxU3UxK3NXcXdRWUJxaFVPWUtXaUtkNDUwUDl3WUN3bWltSTJLMlN6V2ZnaHhrbzlGTFVQQ0xsUlZWWUJTM1R1V2JYZEtzR092UllSZ1QxbVJKKzFrdUVnTThVYm5sUEptQ2k2OCtmSmJBTVliN1k4dTduWi9Ia0JMSmdaRUFTMDAzcGhBQ0RNY2RMOGo1elM2UFJiY092bGR0RzBBN01KTlkwT3Ivcnlxa3RhZlJJZ0FBRVNJaENGU2o2WlNnZWkwY0JWT3BudGxiRlZ0QmlXY3IvVG9aRE43amxHSHAxeUw0YmtrQmdpdzgxc096cWtNT2tpRDU3TitlSjVvV1kzZ2ZIR2MzZ1RyeEVOaHVMNWVUR3FQOHJzTFZtbC94N29CdldIZHI4bFZ2SkNySy9va0JYSlVJcHRDSnJTaW1OQ24rVytCMm5NQ2tLbGtrZFZRTEFRRHllQ1Y4RkVLbGtSSUNTUW1NMm5BaGRmUUYrRFloRUNOekRpVXJhU3IyU1pXMHlyS0xvRU56SFdHeTBSemlhSUplUUZ3SXBWaFNvS0pXbHlZWXBabkxPVUx1YUQwc1c1ZnlNWWQ1YzlhZklNRUFERTgvTjg4cmhrLzNFakZKTEJxcmRkN2dueFpGNXN0Ykh6ZFZnaVM3MlNJSWc5TkVJcEp1UkRpV0QwK3ZMaTV2YjI5dXZYMjV1Ym13c1F6bTVnR2VLK3ZiaU9CaE4zNFNSRUJaV1N2NHRlM3R6OG11enIrRURSMU1helRrc0kzU1h1UXBXc0dJc0JOR0pDZlFsS3NOTXF3UjNFY1Z1SnJRWWUyRjNBSXdCc21Pa3V6Qmk2YWprZDNoQkc3dGV3YUR6Q3FaNFF4YUNHVlRIR0hxV08wYUdVL3BJSW9jSmR4bHFRL3g3WVhNakdldjFPbzlQckY5dTliRDZYamtZaWtXZ2dtRTZFNHhpcnlHTHBnUXRpMkNTeVdCbmhSRHFkRGdhRE1FOG5VcWxFTUJDTkJPSXRSVkxoT1VMV2pIWXBud2hFcmlQQmNGNHdxMHBBYThHMXdDWnczVW95bHd2RmNRM3JJc0NEaG0zNDBsVzVQa2NjM1lGVVNnUXFtOEs0RXdXaExOVUJ4dlJlbzVFVEJ3WlYxUlhtQUFpbmNoY05oQVVvOW5nNEY0YnNZQWR0ektCbktKTFVFS0szLy9yeU5aSVRldjNHVEI5citJQUU3d25XUzhUallJbXYyV05Ed1o1VEVvVjhMb29sY25NZERRU3VVbUMzRGxTRHBKU0ZaRG9BalNRU3ZVb0JVYWd2RWxZY1dDS1Bub0RxQ3FaelNhd1lCRklxZDdCdFY2bXJHbU41c2xoTXBGWWxuMDF1QkdQTHRSdE9RbmNUVzRyYWJHb3FIeUFsRlZ4Ylp0MC9LK1Fpa1VROEh3K2xVcmtRdXkxWVd5bFZkYjFSYk9VdnYxeUdla1Y4L1MvVXU5aS9ucCtlbnY2OXBpZHczV0xlcmJPdXJJNk5ha3NJM2tESHVMaThqa0R0SlBHVWFJc0lBRXJmaGVMUWIrSjVybmd5aEVyaW1tUXFlSlZPc1lVS05KaDJGYm8zSDV2MXNhUzBSTUFVMzh3WkNFT0VHaFFoMiswR2RDVWNOaFJkVlpWZUxDdVNUekViZVZGSUJxT0JSQ2pQc3BVUHBhL1RZcmtsM0YxK2ljWWE2bUM2ZUkzZ2xaQUphVEd2TjZWKzVlcm02eGZzSnRSSkw5S2hkT0FxbUlwam00d0p5WEE0SEdJUWtnUWpCVVdHUlpoUDNzR1B1MVFPTjRlelFBUEhvRFlNNHpBSXd6MzNXajB4dEJHTWJZQVJFdG1ZMVMremN4YmJEYldtbHl2LzRkVk1mdHJLc2pnY3BWdEtTWkY2MDFJVzZVVkgzVktwZTlHTExHcmJHR05zUm84TVpoSmc0d0Zzd05nWU1EWUd4eFBHS1J3WmpCVGhDRUVpb2JDb2l0amtIN0N5cnpVa08yL3NOUkl0WmRIbm5IdmZpSjFVREtuek1DRmdlTzk5NzNlR2U4OWhKT0N4ak5nTHliUjkxT21acFF6QkgxWXdHUFNNZEEwTmphMkdYNUlhcEhzbUdiQjFESzJ2b1lRK1lwTEJIeTh0TGVGN3pvNUtPNkd1dGlFTXQwUmtkamNHc1JWdUJ0Sm5kSDdBNS9GTVRrN2lDMjF1YnRMamdadzBHZHJkblo0elF1U3hlVER1K0JiS0o2Q0ZOWXdxcktCSlF4cTJoMXB5ay9zL2hueVF3QXNadms3Q3dKMTVYandzdUcxejdORUVQZDN6eGV5dW9kc3o0SGE3WjVtQmtOMmVicnFIaWV5N0pUSjJsd0lMZnlKVnpKNWdhUUxWQnFZRVVERkd5a29ld0lDTTROMXZQbXhOQzhKb0M0VEt4UXk5RTRxWXpXak1nNUhXSnBxUHpHYndoVmJMQlRmRWF1Y0laYTQyWi9Ja21zNXNZdlZLSlE4RTJyVjVZK2luRmxieFAvejEzLzhOVHJ0WXBtS0ZUalpiTGhlejBRWDNiQkNmaHM5bURMajJEbmVkenRrQk8xb1FEYlJyZC9JYlNiN2tOSWdIZDRlenQ2L0NwVDJpd2RJd2hCL01sL0RjSWZKaUpud0xRUHhyWXhnM1JneWUwUFBpcTJmbFZWWk5sVFBUdmhGbVRxak1CRE1halFaUGJPY3dPam5XRmVnR0c0SDBGZHVFSzk1TFVZaUc3SmZNRk1DL2picy8zbTlsMWZxbi83aCttMDhYbnJPcUwzdklObGUyRHN2SnFDdG14OHFodXkyWVBGajFPTzFCTGxsSXNxRUIyMGdYNmhzVTdrd1hqejY4V1pMYm15Vkc1SXl0SEdpcHQ1MmlqWDIyOU1EcUhaQ251eUVOemE1bFRySXBTSXpQc2p1NEZDdVdDekZEOThSRTE5Z1FsQ1lDRXFMaTdQYTVkbmJzRkdNQ052ZDhadk5nYnh2Vzl1Q1BVQ2NlUWlXSVVsejQzK3hQTFMzaDcvM2x5YjkyNTExUktQYUlSUkYzUXRIUFMxdTQ1WnhKdTJLek5wczduZmFBTkkwa1YyQXhHelFFeHREYlNScGpuclhrRHRTQitXYy92K1hSUTAwRzJRZ1paUytiM0kxNWpFYTNDOHEyQWpEWjNuK0dPamtMYjIwQnNlem1ydHZRUGVLWjlYbWdmQWtFdWdOUXRvMk4wYW1HSmlaM0MydHp2dEFDcFBFeW5ITGYvd3BYN3JDZUxERVlVTWk2RnRZTy92bW9wWjJ1aDM5Ny9Ea1pMYUNYQ0V0a1ZpZUE1Uk1wVkhwaEhpSjhhTkpJQm9ITDdwNGJoVFJBc3FCU0V5OTB6R2xmaU9JRmx2YkQvaU5hNVBEVUFRWE1PMllVUzBxSE85R0ZXYnQ3T3YzOFpDK0IvUENOOE1PMy9sd3VzWFZRbUxZNW5YT3h3dXJhYmlZYUd3MEVFQVVhdXRQQUd1U016R2EyaUJpTzJNNGpicjF5WllDZndNOVhQOWVmUG14cE4vamhrOGZWNjg4blNRcHdXV0ZYaWJXMElCVlVTc3daazFCb3h1dytLQkM3blI1RGx4VDNiTUVRTFNmU3RPcWtySjlaVzNBVlpNdXRMRi9jN3F4R1hlaGZ6cUFyQTNySSsybUZSU2hJTzJjL2x3NHlrQ29NbnFBcmVYQ3dDblZNMUJhQThyNXIxRERwUmpGQXpnY25ydXhqU1NkMXB3aEdLWVdMaDUxazhxUjRYWXM4YlZFWlR4Ny84a3YxZWd0M2JDUmxZTE00TCt2czhUUGhjaHBTNjRBTnFtL25hR0JzZEc0aHVncnhNRlhhSjNyd1pJdUhlNGViSVlRMUJNOXlGSDNMaDJFWUZ5S2dwQzZEZmI1UTNzcGgrZi91RFI2VWJlRjRkK1l2Wm1LR29iYUpVYU52K3ZuSlNYS3puTjBCVDBwSHNRQ0M5VWVLT2hsc3ExemE3c012Y29JeXNvZWZyK3ZIeDVIV2xSR0pJSTZySWh2QkVXQ3dmbDVGR0R6QVFRRTg0UUdzVmpGQllHRVVteTlRck1CSHpMMkN2T05zTHpiV2RzT0dSaWVuMDV2WkxmOUxldXM3c1VqRG1QTGg3VkhpWkpxdDZqMXp3ZGhhSnJtS2E5WXNiZU9FMmY2MDFJNFFXanA4VzVpN3lXSHg2cnA2dk81d0hMY0c0eDdCaUJ4SEl0WDY5UlhXNDN1OHZaaW4va2RGTldnaTdJSHlMZ0N0YmJkb2FDVWhOQ1h6L25BeFBRQkZBbGJYM2VqekUwTmRSbnZNVmRoRWxVTk1JWUhUbGk3ZmlnOG50a0Y2SjZ0ODQ1TUZjdHdZeHpXTzJMY1Q3anpNOXNLeHMvT01qbkJ1djVMYVNsMWQxMnMxeHdiWXJXQWNyNit2ZzdnQXg5VTJUZVB3cVFwWm81ZEdqOWhkQzgwcy9KZlRZZnVDZTh6Z08xbE1ua2x4NnhlRVRrdTRTb0p0cHRJZkttMUx2V01HbGhvRHVBM3U1N2l3ZDZ2WUFoZTZyamxGdng5Q2ZmN3FHbEE0bG4rTnJ5emZIb2JEc2VGd3JCK2pQbGpEbmZzSk5jYWt0amNmWE9OREpCWE9oSGR3aENFQ3pFWml1MnMvb1JvL1VVenJKR2hrcDZUcTlyUG1XcVBwQm5tYnhDLzJLQzh2NnRYYWNqdytQTHl5dUhoYkdCR0FzYkd4REgvRzRhaFY2eGNYbDZnOUVGK2xzaTJOckJHT2xOZ1hUQWs4aE5hZ09KYVN4NjZQMk1yd1MrcFdqNlRnM0UrSnpUVXBhT1J6Nms2L1grcTFzazRybkJGYmowZVhseGNYMVZwdE1SNC9QejhmWkRBY2Q2Q001Y1dWZVB6WE9Qd3hCdVNTT2tZVnNXWEtQd3VITU13SFJCaVEvSTNaSEpxemtLWll3b3JIeTJPU09LM0VwdDVZOE1rcG12N2lDQWNmVE1CVFlmZU1RRlEzRnMvUFQwOVBMWmErd1R1QkVXRXdpQVpvYlhBNHZyaXhYcXRXa1FnR3B4UnZGaXVHRnduSXR0Z1l2UUVqckVDaEdyWEljUjhzU1lOLzlBOFB4TG13bkFUckVoRUtjandRSHVPd3Zyd3kyR2RwdDFyYkxjVGlMcFVCTUZhR2dVWGZPUnFHSWdCU3IxOWZRMkJOS0NhSTVPRkQwQWFESVNZK2tVUk9qU1RIVlNGSklyWE5aMG01eUZUQ0lFMXh0N2xFRFBVcWVjWWdDT0wxYTQxR080NDBCQmdiQ09QUlhTaGpCWVV4T05qWFo3RllyWEF1WUFKSWFuSWtEY1plV1k3aE5QQkRJSkJyTnJYRlF6TUhJWTRSVmlvSklYeEt1dUNIaU1HeEhEOUhDaWFUYVdwS013Nm1VQWJBV0g5Ni8wNlVJY0FBR3NpakhRek8wd2RucVJFVGdISjVGZVlkZU9ZeDZDMllFeFNlMHRSSEtBSlMwcGJQVHpNaTlGZjI4YmQ1OElYRVNneVlGbXFMS3lCYmkzVmNxOVVBQnpCVWhSckdjc3N3SGp6OFIyTmxFSTMyZHV2NHVHWnF5cVRSa2tvRzQ4U2tWaWNvcUpYTHEveVZPQjZodW1jK29oYVdYc0wzd084ckttTUpHaFVCOGVBSUNSQURnSUFVRU1JcE9jWHIxMTZ2dDZlbmg3SFFhaFV3TUxVdTMwWVpCQU9sSVljaFNNT0NOTWkwYUJxQ2Nub09YQ0RHTGlNWERDcjErc1UxWFBzbDJxdkxWOUtRQjg4Q1RPYmlVQjlUaDVCbktUNWMrdW1YTHk1a0FCd1FGTTRaZ0JjdnZQMW1yeGtnTUVFSWRzY3dtREtPRlRDR0ZUQ3NBZzVHQkhob05IZ1JQR3FSRDZFNmE5eXFaSFZNemwrMitrV2RXNjBxL0hKdEVlTTNKb2h4OEFTVEY2Mi92eDllWnJQWiswVVljTVczanhrM2xkRWNCaG00elpUSjFFTVg2bjJOQi91RWRrcDJqdGMxU0E4S0xnNU51bGs0aG1zZkZ6L0NhVDR5VjdSaURJRDdmc0ZOL3g1Ti8xNlAxdHZiMjluWmlTaFFGejJtN3dyajI1VEI5YUhSc0d1QmNON0R6SXRYMndsWHJ0ZmhMZWowN3p2QWREcmQrL2M2SFh4RmR3Zlc4WDRHckFQZTFESFRNVU5mQzZiajl3NTN6MS9FQVVpUUxKckFZRmNrd0NENmQ2a01xTHErRG9QaE1Ka1lEaSt5Nk84bkdNUUM3bTNtRXg3czA1ZHNSa1FpMFpERDZPOFhZSmliS3NONlJ6QnVLaU0rL00wd21ESVlqVjZTaDQ3MGdNWUYwTnc2dUlZVUxBUWtmeXlNRzhwWWlYK1RtM0FZNXBzd09BNFJ4aWYrRXY4ajl4SUdvN2UzT1F5V1VKVXdNSkNQTjRJUnVTTmxLR0ZnemZWN2xLR0NvUmUxSWRjQXgvRkpRb0V3Q01qdlVVWkRHT015R0xldk14NTlVUmxxR1BRa3Z1NG1qV0dvd2R3ZERJc0tSdVRwbjF1YUErVXd4SUpja1ZDNHJ4QVVLeFRuVnRGcHNOQ1lrdHhGRklkSWhFVlNuZVF3a2hqd0F3RVFBcDBlUC9UaXpiTzdsd0lGOHhCdmp4ZEtETk1VbFRqa0hWcmgrZkFsSzZHSUl3dEhxekR1UGZnN3dZaDhCUVlXNWxZMURJMENobGVDb2Vjd2V1VXdDQWNnWUhyUUNaR0NVT2kvRG9QVld5SU03WGVCUWNvNGpueGRHYUkyYnNEUWlEQjZ6Q3Bsd0dQdmtHY1cvcHFSd2laM0VNRXZrS1lBZytQd1VoNFJZR2dGRTFqZ1F2S09ZUENZMFJDR1JZU0JpMWRLTFBEU05sU0dtZFZkeXNDaFZ5dWpNUXk5RW9aYUdiUW0rU05nUFBpaU1pd3FaVFJ6azZrcG9RZzFONDhaL1A0RmhjaUVvVlBETUJPS1RyTmFHU1lWREswQW8vMzd4QXhJS0lzeU41RkNCbE1Hd1JBY1JZSWhCRkM0QTFFWnZZMWdLT3J2aGpBSVI2Y3NZdkFLUXhZemtJUkNHZTE4WVlKVnhtMWcvTkJJR1NzU2pEN0Uza0FaTWhnbU9ZeitKakJFVDVHcnBKa3lSQ2ZwYkFaREZqK1ptMWl3NHJvdGpIdjNtOFlNUm9PZHFsM0NvVWl0R2trWi8yZm1XbUxhU05Md2FKVTk3WDJQMFY3M2tqbk9hVlFHSElMQkROZ1p3d1pzajJPWXpZenlnSm9RWm5BQ3lTUTdtVmNlMGlRVENjMml5SkVQRXc0V0oxL2NXa3VXR3N0cUJiVzYvWkE4SURoazFkS3FMejVFMmdQUjdsK3ZkdHZ1TnNqWTJjMGxtSWE0NnF2di8vN3ZxeXBudENNWUZqTzg4NWFZZWpzSjZLVHRENFhDWFRNRzJzb2swV1daL09GOXdZeUVBSU51Q2s4M0xIa3pNeWdjZzN5dkp4WnJRVU9BTWV3TWhxVVhMY3hvdUN5M3h0b21vQnlOd0FEcnJBRjdtWHpZcFFOdE1DTmhZMGJJdnR2bEFFYVkxaTFsaHFkSk5JNWdCczBxUWtxOUhickpwSnRtT0hlVEZzMzRzRXRtL001eW9BbW5NckhERVd6MVhjMWx3b1A4bURNWWRrQ0dXbTNHbUFCalVqUVRnZ1pEWkhTeUZZeHdrMllFZWdlR0N6TWN3V2hycmtkcWhnV0hBeHJ6RFRmT2lURnNLeE03TTBhZFRGZTRJelArOU1jVE11TjQyYVNtYVh0ZFpST2VUbWltdDlkSlA3SkpsMkIwNkNhdDJZVHlvcUxydVlyTmRCVXJSYTB0bTR6OXI3UEppWmh4N0d5U3pTQTBVeG5nN2FTUVZUTVpWVC9RUmp0a2s2UHR1TmZGam5lZlRmckFqUFpzVXBFUVFxL05lcEtDb2FtUmlLUy9rdmZWQ3BUMTVQOVJOam1aWmh5UEdVRVZzSWcreEhnRndJaHB3QkowK0t0aDdGNlhpdThvbXhTT2wwMjZac2I3cDQrZFRiUUlUUDlDQ2h0UUorR0NEaSt1S1JnREdwSDl0WjVtazNHbmJGTEw1dFJzNlZqWnBHdG1OSVBSbWswQzlteFNJWmYyTG1Kc2tsSGtTY244aEhFOUVZdFYwWHFvejlsa3NxQkxzQmJ5Mm5HeXljbVlrVHdxbTlBL0ZJeXJHQzhSQWMyUkY5OWpaUmxLV1VWM0RFY0hPdHllVFk0RXd5V2JsQmZKRzg2WWlXTmtrNU16NCtoc29wSGhuTU1Ld2FJd1ExN2N3SFhBb3BCQlArQjRUN0xKdUVDanBiSEdTaEs3VGZyU09FNDJPYkZtSENPYlNHdzRSTHVLaUlGaGd2R0NyMy9CWm4relNaYmZyTjNHOFdOa2s5NHh3ejJieUdROGp4Vml5QS9vMko3aE5CQkRSMU83dU43WGJQS1p6TUM0QksxczhPaHMwbE5tdUdTVFBVcU5qVlVZUkptTzdRSUJBM0NwZ3BDZU9KdU1kY29tbkJsM01HZEd1SC9NNkpoTkJ2YXN2WEU2cEM5K3M4QkE2L1hZUVJYTnZvRUY2MjgyS1JGWGd5Nm5zQkxvWXpaeGFLM05ZR2lWdkp6TDZlVzh0aGZjbzJ5ZE9nZ1A1c0Yrd1plM2Z5MERGcTh4Vm9KOXppWUUvZG5uR0tmN2wwMk9CdU5BcjhJb1psRlV5c2hhc0NaZmdrSDU5RXFGTVdQdXBnOUZjLzhBNzlHYVRheldPdFNUYkZJZ3Jmd0tXRHgvUDdQSm1kTWRzNG1lc1gxS1lrYXY3UjFlOUFFYUdXb3pvdlR6Ti9jM1lZemh2cDZiRklwbEg1S0FGMHF5cjlua1RDZG03T1Y4VFo4WjhhbmE2dTY5RWZ1M0h2K1VnakV1SEN1YmVMdk1KcE5aU0VYcUxyd1BheVcxNGtHNW5PMUROam5USVp2c3lSRXg1K3NQSGx5Y2c3OXoycHFSK3ZuK3JiOWU0QThndDJFbE1XSFBKc085emliNm9wUjU5cEs4RCtoRkxhdEwwTlVrS2FPNVpaTVB1bWRHMGpXYmNHRVlXYnkzc2I2ZFN1SHRIKy9OeWROaDA5aDZlZmNKQitNNVZvenBmcCtiNks5MlNTUmM5bmkwckNyTlJtN2Qvd3FoeU91NDN5bWJ4THNGbzRObWhQeDdUQzltYm03U3oyVENjUERXMDI5TmYzZzZYVmVVUlFiR0E3QWE3WHVndzY3bkp0MWxFMU5SakxRLzV0RmtZblhlMUZQcmo0ajlTenRsazNqaWd4TnJSbnMyWWNTWWUwRStwcXJVNittbFJOS3NHemdOaVdBaGJiN20vU1NWN09tNVNTbWZCVDBvdG03Nm1lblZJSmpkSEs5TXBmN1c5OFVtNkhaek5sbm9GVFBhczRsT1ovc3RnY0pjV1FNN0hnajZsOUtHd2ZaQWVRMmhwM1g3dVVsaFp5ZXJxeGxWemNuWllzZHNzbE1xRm92NUV1c21jazR1RWpBS2VWVkNVVjgxVTNZOE45RzVKVmRXUW51Vk90aGVKd2ZhVTJaWVpVS3I1RXZTTEpKcmpZT0M0QUkvSytCMWNoTUhHdWNtcGJ3dW9RaVZYVjgxVnk0MnVmRjVxSGVFOGd5VUVtdmFlUXBHYVJGSkdVQmp2SXordytLcGxHcy9OL0hrNmFOSEdDZElJNGtyUnR3cG0vU2FHUXdNTXF3b2lMaXg1SGM2TjFHcEcwWG5VbWxSSlRzRUNtaUNoNzlkdVVuSHJlWnRhQlRwTDZoZWVrKzB5T1o4T2JuaUJ6Q291ZDlmSGN0TlNlWERSL1JKNUkybjdkd2t4eG9iVnFqTkdIREpKdDB6NDlRWjkyeEN4bnVmOE1MNVRoZlBUbWpENEZXeUE5WWMwSGxGbEhiN1BIMVdMVnAzdXZqMG9lQlhMU3pJVmxrYzBLRXdvU3V2VUZVejhUcXpjNWVNY091NUNXOXVkdzE3Tmhsb3RlUGRNNE9Ba1hZeFhXVEFYNFBUZHJuVHBYRVQ4a3dKMHFPQ2tqd1RwZTBGdUdRbWVlYmUzK05nOE9sL0F3OUJOWExNdlk1c1l3Vk1lNGxadS9zUlZES3drZVpiRjF0bXk3bUpVS2xiU3FoVE5qa2hNMXpPVFdDZEVZeDIyZTFPVjVXTjdWTzhRc0hRNlpUT2djYlVRNTVodHZ1RG9tOUNGSXdkdHZqb0JsQmhmcjdFcDNVTm9BYlJLRE52djRnTzY5Z0lqUE9ITjVSWTgrNjRMajQ3ZmR2c1pNZjd3b3dBS1ZHWW1ldWRMajYvODdoTzduU3hUVXIwTXl6OUlEU0dIVjRJMTR4UkFnYUwvTkdQNFNtNERVNGI5QXZHYXlDZ1BQOUVieHRZOFk4WEJCaDR5WFp1TWpFUnExb1o0TTYvK2dFRzF3eG5adWdVakJYWE8xMWlwYkFCZytWbGNCNklzVXo5cDBoNFcya0FRMER6QkRJNE5GZitpbFFKVkpFZ0VkcUNkeHMvSzE1ZXdXazdNMkxGaUlYRzVkMjQrN25KeVpqaGxrMnlGSXkxOWp0ZGcreEdnbGhmck1CWVZXdXRUZWE3K0RmUXVqSkdpRUUxQXFXd0FqVEo4K2xlcEZYaTVSdEZ4TkhVd1grS2w1c2NETkZhWlZSNUlORDRwajdObVZGcnl5YTlaWWJJSmhvZHZmdWRMZ3NNUFByWkFmdC9FWHpiR0ljb0ZsN1ZZbnRvYUo1VEFlVFRoTWJTVkNWZUwrZlFKNkM4SVhEaTRoZFRMV0JVcFdUSzRzYUd5YkFvNXdiOHJkbmtSQUxhcWhuVzU5UWtzanlOYzVQV08xMDJNRWI1aEs3QzRuSnIzUUFqSWFoQWRtY0N3QXdPeld4VGxSQmltSUFGcnlnaUwvSEd1UW5VNGF4czRBUCtxMU12bERVeURrM0tEU1I2VlNZMlpqaWNtOGhFRDlmYzduUjVjbnpMQitPSmltaXpNQU9lVGNRaWJvQks4SitjSXZKcFZRbnZKVU1DVTRDRzdQb0ord0x5NHJmZDZZcVZvNXFpV0d5OFNzLzFnbVZVTVpTV2M1T3VtZkhlcVE3WnhLOU5RZDlNdU43cFVwbnNmUXBnQ0MzOUdpc2lkQzFhYzB6djhDOWZNUG5rMEtEdlFHdTkzcDJxOVpBb1JrRXdhZ3NyVGRsRXlpU3c2ZEZtZUQ3RUpDSnBWVFZCMmwyUE5PUDNaem9kRlZUUnlKYlplcWRMaUVhaDRTSkhxMXdndDBXVkRBc3JjUTQ2QktmQzFDYkdRMDFWWXRpcUJCNU9UMEl2aVRLSXZ3TGFUQmF6VmpZcG9ISWRyM25ZQ3FEb0hEbllDK3UrQXdNdjljcU91ekJEZ0hFQWxXeTQzZWtTYkYrSGJvSXMwVE01TWZJTUhmUWx4Z3VjMjUvRDJ0dXFoUGFTWWE5c3ZhcVBRNW5vSEl6blVDVUZ0V3BsazRKY3c0YkhNNmhiSlJZTzUxRXVpWTNlQmJWTzJRUXFVVVdYdDVlZFAyOFM1c082QUxNUU5KamhrakUyTmlSek1MNEhObVNzUW9nM1Y4bUMxeXNPVVgrRW1qbDc5cXd3SktERXhtUWV5ZW02eUNhMWFaejJlR0txK0xjVVVNK3FaaWp4bnRueDkwNTEzQkFtM2ZYZVA1MnppY2FIRFZFdUxWSURkQUEvTDVNTTd3a3AwRXlyRUJSeWJzSmZqYVJvTDVHRmpRV0pBRERLamI2VEtLZ1NhS1lsb2NGMHpPTXArS3pkUmsyZE9UQkJNZDRSR0FGL0FKYi9TY2dwbTFpNnZnRzFYbXFBd1hlNmlrdy9vMzhEcUlwV0w2a0RNYkw4aU9FeDdTV0NDVC9BejVITkhVbHNrbUFEK29xY3BnY3lvNFVDeVNiaG1HZXdiTDJSbVluQVkyTzUzWTczQXd4NmJsTGJSK2YvUGVDUVRTcVNpR2xZbVNoeC9md1l1aU5qQmgvME5WaitjTmFhWUx4aHhSSEFGUFo2aFlDOHhFb013T0FJZndUZUxWbVVwSnFpK0NHYkZQTFpJcnZUVldTdForUTcvSEEvb3E4b1NtTGczWURCVHRRcW42QkxiOXZsVXhNZDhDNnNVV3lVei9BakFjWndsYXJncGVkaytiTU1xanVnSGw1TFBxRktqRVpmdmM3TVdvbXo1aWxSRE5XWE5hR2pBRE1BelZ5RjNPbXFzWGVkZXJ6OTlDb3FyeXBLMmltYkpQcVJUZGk1ODhGZkVKSmJzMGxOR0l0N1FJelF4R2dqcGpBd0tCbWlGOEE0S1lQZUxOdXQyY1RHL1B5OEFKRld5WHcyYXJYblZlWmF5VGYrRHI4V1VDTnlVakdDUkRMbzl0bmJtTmpxUXA4L2ZEWlhCYjFRVEtkemt4UFk4VCtmVHFjNzN1a0tIODZneFZ4K3o4YU1ZRkhuT25aMW14QmpZbFNJeHZQL2tuZCtzVTNjZHdBZms0QnBVcVZLU0R6c1lROVRwYjF0ajN1TTQzODBzVk03MlpLMEpMQVFicXZiUWtORUJpV0lTU3V3UDhDb3I0eUdiVFExVFVKWHhDSXMzSnlVV0lzQ2dsUFA0aFExQWU0S1NUbHBPZXVDWC93d21RY3E3ZnY5M2ZseXR1L3M4L21jVnRzaDhrK0pmZmU1Ny8vZjkvczdGWWE2Wms0dUNuTFdPZDN0VXRTY25vVVBEM2Y1YjZYMzZoRldUTmV0azVENXJzLzNMSFpuTWxkSTBFWEMyNi8rZlQrdGFlUDVsdDN6WDJlSHNVNXZ0bTdpV0RKMkFvd2E4eVpkei9lMDlNM2NlZkJsdjFvUS9yTC8va1BOUExaZ2hiUWJpK1BhZFZ3ZWppQ01lVXpiOXArQmxEeGZES3YyOW1CWnAraElpWno0bG1jTzZkOUJmREtIZjdXMzdTVDgyYlBGdmtWUFZtc0hhbC9jZysvVmQwamZYbkhmKzQreXc5a2g4NTR1NXpDK3E4T3c3dWtLNTdCRyszQnA3c25uRHg0OHVIVS9yUy9Bdm90VmU5Skp6NnJMS0cvZHVJTFdFMC83OENtc2VYbjlmbXI1a09ZQU9uMkxMVXZhZ3ZXTjRiVmJNMm5OWk93OWZqWWNtaU9nZmc3UnlPU0ZtYjZsN2l4cGdBSEJpQ3d2N3ZzbHJtMzJ0TUU3NzMzOS9LbkpES2hJcjBWUFYwT1NVYnVuYXlYM3U4UGtqanljV1p5QmU2eVp3UDBnRjZBazZsakI4cDFYaU40OFc3NjFpTENPNGlKc3RwZlVnNG1xdndyMjgwNUx1ck9ZeFV6ZVMrOWVTaGZyT204c2thLzczcnd3ZWUzaW1YUjZiaTJqTlFNaGpmWm5meno3NGJXTGw4K2MrZURVaDNmSm10WjBkNy9iMVhHVURDMkZyOWJHMUx2MitNd3ZYdFkwVmp0ZWVROVhIZk5oYmNUQzg4Vi9UdTRqRmVHV1BTMDlYLzNwTHA1eE4yR2hGY1kvL2RkOFMzbzUrM0h4QmZhazd6elplTG0rTnF5c256L3cwUi9POSt4ZStqcWZLZW9JeVUwNjg5bE1CbDRSUHhoUW1QWjB1V0V6cXZaMGRVL25McDdiYjBDeC96aTJJZ3pudWplR2IwNDhPdkQzMzc5emVGZDYvdDVqdkh2WmFZKzZ3T2lqNW5ZZjZzRnJUUytEQzFqRXpjWjcrdmIvNmtsT3ExeWRmbU9YM3U3UjB6WXoveHdzQXRwTzQ3ckp5SlhCM3NoMExwZWJIalhVeHQxZE4xRmgxSjQzNlJ6SloyNzg1ZkxwZzRkLy9WWmZ5OEVMWjFFc010Tmh3N3hKYkNTWHplaEwxTm5jQ1gydGxmSjk4ZkhicjdXOWQ2OHpEejZUZW42ODdiVzNqMExrT3Z3NllmSG1wKzhlT1BEbjk4Kzk4MnJQcnNOSFAzajJEN1FJM1RHbjh5YURnei80a2NNNHc4UzFXc3pDaitZemszZi8rcHNESDEyYnZFSFdvck1qcldXejhLTXFqa3cyUDMwaVl1enA4aC9UdGxjR0ZoU1YxYjUrckZlRVFBa205WDJZNGMrdmREcWZOM0VNQStNTTIxTUZuYjNUcXVwcTErdnhHbWJob3hzOVhaNXd1Q3RhUG0vU21zY09pNXpheHBUTDRnc2NXOVJEOFJGUTA2RWN2bm8ybTgrTmhodVpOM0V1R1R1dEpjTmtGajQ4Y2l5WHkrZEJjYWRIR3AyRjl3ZDV2ZEZWclFnTkRBUklEMU5JNzlEb2NESnZNampxSE1aTE50U2tORGZ4aHNQZS9zWm40WDE2b0ZZc2dyZ3pDejg0K0RPSE1MYVd3ckNjTitreVdUZHBkQlorUmk5elJHek1tOWllaFc5TU11ek9tK0RSNmQ0cy9PY2J4VUJYWitFYnNSbFdhbEk1YitMS0xQd0dESzNLQXduclVPMTVrM2I3cy9CdTJJek5ub1duNW5VdGNYY1czcmxrYksyRXNWbXo4SXQ2QWMvZFdYaFhKYVBXTEh5L083UHdsRm9NdXpBOFBGTGZMSHl0ZVJNM2JNYW16OElUeVdpN0FWcGlZOTZramxuNFJpVmpFL2JwcXBnMzhaR3F4MEhVa29wNWswQWpzL0ROOENiTzkrbXlPMjh5bjM0WmZVbTN5N1B3emlWanErMEkxTGpsb2RkcW42NUErU3k4cjhxSXhlcnpjNmR4dmJYNnZFbnBYbmFlNXVZbUw5bk1UYm9xZDlBdGw0eDY1MDE4bUx6bC9NR2dtV3hFRFNNbkcxcytsa2RkcnVZbWRVbUdEbU9pSkROcFlKOHVTSU43amEzMFFDSmdWQmFDQWpmVG5aaVlpQXlVd2JETVRWeVNqQ3F6OEVhRFViYjFJN0Z3RG1iaGpjTkl1amNKVkZvT1ZwWmwxaWdaVGN4TnBtM2xKa1VXWFY3dkNwemNpZ29qNHBtSWtMM0FZM1hsSnBTdmZESkxoUkhYU01RUkJBc0h2S1lzS2h6SEtmTEFoRUV5dnVIY1JBOCsrMldGV3lCbmgzTGhXU0czVGFYUmdSS05JQmdtYUM0WmpIb1FFQXh1dDR5YkxqTUVCZ04vR2dqRTQ5aStJNHFLSW5HQ0pFZmpySkpNSmVIZ1pIZ3pNNXZ4VGVRbVd2NE9MTGdVT1JRNTRnRVU1TGFKTXRZZElQNWtqZlpUMnpUWjd6TUVHbVJEVU1vNGM2TFArZklpSERJTE1pRnlTUUd1dnlDSUFJTXJKT0V0a2trRjBGZUVYZDlRYnFLRkdkNFZKWlhpRklWTExjaGcwMFE4YVhMZm92RW8zRkhBQXBmRjhqeVB1MHpqdGZOdzZTQUtCQUpQRGxIa2VleWdoZ1BFQXI4SEdFd0lDTkIwVWxEWWVJZVlwQVdPa3poZ0hKVzVwTUsyZzN3b3JCRkdNeUxRYmJiRGNSVkc2eWNnR0lvTVprTlI1SWtKT0ZOQ0JtbkU0UzVLOElVWVluaTRqaURvQUMvQndVbVN5UHR3ejNGZUVyUkRaQmhLbEFSTzlNSHZDaExQQUF2QUtzQi9Bb05PY2hMb2ljTEdZdkFXTW5nVGdDRWJZRFFsTjlsYUo0d3VnTEdnZU1IVGdUK0pSRVRRRmpBZHNnSVhFU1VpWFNod1BDUFR0QVF3R0pGT0ZPQmZBaTdYQnpCRXVnRGZ3QTlvZ01GTDhKM0FNenlISHhsZUtOQWNYRDhuZHFCa29HWndLQ1V4V1VqS3NSaEt4b0FaakZaVEdGc2RWY2UzbGVRbXVza29aV0ZNV1Q4Qk5WRld5R2I4Y0dKS2lnTmxpY0M1MGh6YkVaYzVtaTRrbFJBdjZEQkEzQVc2UU9QTlJ4aUNSQTdlcDhKSVNDQTlDY0FYRkFHR3dBa2dMS3FhSkZHQUFBWlJFeGxVS0NXVDU1bG9oODVqSXh6dlJnTTZOTkp3MEhYRjhJUVR3NE1zRERCMEdtQkFGMEJQaUhlZDhJRDlFSkZMdTFMZzVBNlFESlIwUVpSMUdFQUJiSUpRVUJWRFNBaXEzdkJFTWhJQ3lJZ28wUWlEbDhqbEM2Qm04WUFtR1pxYUZBQlNNcVd3cW10dEhvd3l5VEFhVUJNWXJkaVUwS3BhVVBDdXFzM2daRWpoOFRPUkRFRVN1WUlFdGtHRGdSQ1lWWVJDWUJSb09CSTBwNnFKSUJFNkNBUHRKeDRnRWtvQTFVUkMzNnJJcWpjQmEwS1VwQWpEb0NsbE1GeXdHVVkxK1cxbE9LNExCajV5b3F0L1JWbEExNHFPZjBCSndYa3FpcURhREdBaXNXRDlRRHFNTUJncGtkQmdDT0Fqd0Urb2tpSHdva0RUQXNLSWd3RkYvNEh1RkNTRFJnQkpnQVl3UkxEUTRIRWp0bUc0SkJtMVlCRGg2Tzlhd1pnUXZNbEFaQUxFSkpsS0VkOGFBeGh3WVNHV0EyTmdvU2E2elVBWUNZSDNvK0VvRU1sUVBRMXhyUUh3TFBBMUJuWWtHR2ZiMi9FUlNBTTZqUDdOa0F6ZG0vUmEyZ3lNUWVIanlrby94dU53aGhCMXBRUTg3UmpZRElEQnh1R2FkUmdKdElvMEdFcStLQmtjWGlaeHFRa2FmVW1Dd0FpQlpLQnZKZll6SUVQd0JYRXRHOVVlVTRBdEdzV25JSG1hVjgvWVpydlNwY3BGcTU2K3ErVmdEOURBZ3lVUktLdEljREY0WFlKSVlBaEFJN0hoV29zMkErWEVENkxBTTM2Unc5K0ZDSlNYTVFCbDJRQW1lMndVUGtlTFdhc093MlBRRXEvN01IYThXQThNdzd4ZU1ZV1BvRFBCWEkya2FaaGJNU0ZJTFVRSUxpSG9Fc0YzYUVFWGhVRVhoNjVFZGEwVVJxSStCbjVINWhFR21CYk1UT0lJQXovSHNieWpMcmFTS21nOU1IN3FLTTc0WHIwd1dpdkxmaVNKVjJ1Z21ITkNOSzQrd2tkOWVnT3Z4dU5hYXNKci8wZ0JVTnVFQ0lBRTFmemR1RzVTUklGcUVpMkQ0YWtPWTlBaGpPL3NOTUFZdElKaFNFMWFUV3VnRVgwSmljQUl4WXRaSzJQSVVpbDhITkFxUS82VFRBMStyQ2F0VE5VYWFNa3F2S2M4VStzeXEzUTVnN0hkbG1TMEdueHJIUVhoc3Mzc3FJMm5GVmp1dWVNS0RNZVNVYWVhV0VpR3JiSmYyYU4vS21FRUhFbUc2emJqV0owR3RDN0pLRnMzc1liaDFsSkJnelpqczJCb1NKekRHR2dxakIwT09uY2NxMGw5KzNSRm5mZDBPWVN4NVVWWFlFUy9UVEJHSGF2SkM0M0RHSWpZWGpleDJQYlJvbk9uQmd5djI1S3hyUUtHeGJxSjVTTTlCdXkwTVptc205alltaXBxM2Naa0tobEhHaldnVlNYai93ekdsaGVxcjV0MFd2ZDBlWnowZE5VUEkxcXJEN1F5enZoaHc1SmhWaEN1MXNaa0tobzIycGdha3d3N2JVd3UySXovSVJqTmtZd3FQVjFlaTU2dUdqRE1uVWxWTmFuZTA3VjVrdUZpVDVjZHoycmU3V2NqemloZlVXdStaRmpEc0ZJVFV4aFUwMkU0VnBPU09BTXJ3a09XTnNNV0RLMjhVNm9tMVNYRFh4Mkd0WnA0M1ZhVExhN0JVRzJHYlJoKy83Y1BSb1ZrT0ZZVFp6Q0NOV0RFTE5xbHEvYUJPbFNUN1dXU1liRytXSlNOZXRSRWY3eHhzVjNKV04zeCt5MGxJeG90aFdIUG0zU1gySXlmdUNJWnJzTlFxOExhSThCSkJaUmhpcy85YmhhTVVZY3d0dThvRDhlSHFzQXdWUk9QaFRjeFBQaWF3b2VpKzBMUkdKbktpRVJEZnZJRGZSdjJxakJpbXljWlpnYlV2RVc0bG1TVUIxMEVSakRvUTRtSWRRNnRyNit2clQzRll3Mk85WkZlRDBvSUZRb0dLMXhydFBTb0NxUFZSY2xvSmd5MG9OUXFFNGl0aE5jQnc2VkxZOWZIeHFZK214MGJHeDkvK21odGZTZ2NDVkNybEQvVUNBeDNiY2FQSzJBY3NZWmhhSm91cmpGYWVoTzhSaENManQ3MXRVZGoxMi9lSGgrYi9lZlVwZGxVYW56cTVzTE5xZG1wUzQrT0hlbFlYZlVGeTlXa2xFU3hQWGdUYk1hMjd6Y05SZ2pVb0d0ay9lbjQyUGpVN1p1ejQ3TzNyMSs2K3JmYk42OWUvUzh4NXhNU1Y1TEg4WVVjc3RtcnNNekFzbnNZMkdFRGU1aGxkMkhDSG1MOGswUGIycTB0TFlPUU9PdC8wWUNLWXhJMWgyQVdnampweTFUeFdJck9TcjBXVW9VODM2djRyQ0RPU3hIQ1FqeTB6SGl3YVpYR3Z1akY0d2dhOWxmZHJkMXFPOXUyTGxzS0RYcnhmZnI3Ky82K3Yrb3FxV3ZiVmdSK3RKdCtWS2xycFFRWTkrOFhPUVY2MWNyNDFSZm53d2hlQWdhVVNIV2diaWRCbEdKRWNVV3BFSVFTZ3dtTUNSVjJKT3B4bTZGRU91eXZhcSs5VWhpWFVNWVhGMUpHWmNGZVY5SFp4SDhFbzMyajRXR0NTU201aTVTanBFUlFIZzduM09PdXBGUXlKTGpMYlpSNDFMRFJmbngwUEJBNEhUL3pqdkgvVlVZQmpHQnhaWndMQTV4eklyMHJiRSthUkVuUHNsM2I5ZlRwaElnRjN3NFgyTUFVTE1UekJJaGpZYVBLVjFQVVFFRnZoVER1L0UrVlVYRTVHQVZsY2dKR2JYdGdKSTBWdHptZHhhN25lQUNEVzFHOVV2Q2RpbnJZSU1nd2laZnlrSkd1cTJrL3Qwd3VEZ09VVVZHZU1xNFZoeEUrQjBaaG1SU2NTc2pEQ0FBTGYrMUc5M0NDdWd6YUtaWGNzamhVaXlUTWk2UXlQRUFoRnNVVVk4WWRHeG1VSkVZVzJtdjkyVEk1dlhKbDBsQUFvL1cvS3FNOEdMOHVFVVpsaVRBeUJscGQ1WCtRd0ZRaXd5QWdDKzR5aENrWXAydWxvcEZvOWpDUGl6RDBXYTBRNW5HU0dQZUJiOVJjRFl5dmYvdUhNcFh4K1dkcC9URjhPVERPN1NhZ2kxMENBRENSdHVlNUZJRkJTQnRqTzVLREVVbWxPRFlSajZZOEF3RXRnUkpocUJSL01SaUJQSXd6S2FNQVJ2Z1l4cU9kY21GVVhQdnNwMkl3bWtzb2sySXdZUG1xRjhJSnBHeGlFaGVhaHkycE5FeDQrdzNzYVE2WlUxMnBxRzNNR25ZMFpTbmxRcjFJbVc3ZUtLYU00MjdTVU13eTlPWDg0Q2xsUFByNjQ1L0tobkhySUgyMU1LcXE2dElRdWFFMm1OWUZBV05RUkFFTUZNMWFCcnlBaXhpejFJcGF0cks1cmhRYnB4dHJxd05Gc3ZpRllld2MvUG4zRmVYbGpHdTN2dnZwNGNPSG1UM1FDOEk0NlJsSGQ1RjgxZDFwcEJCMFZKZEoyMUdHaktRaTBFeVVTVEl3dEdGWU5pUFk0S0FMaEd5TGdtd0VTYnowdDE4WVJ2QUVqUENJUGkxOStQekx2NVhiVFc0OTF6UmVabUdjM2VvNmplTTBqTnUzVDhLbzJRZ01Kd3dDbVVwNUZPd1RHb25MSllWME5XdDRubVBwVHNLVmJSTUQyNDdMQ09GUkQzSTZwbWkzN2tWdHpTbTdLQWFqMEQ0YmM1ZXk5RllYL05YQVl2encrZFROOG1EOEVzcmt5ZFIzaHpzdlgxNEd4djFqR0g3ZlFsMEN4bEtYQzgraVNBcWxwTEFac3pneU1XUU5EcG1ESzREQnNDRmR5Z1MxbzFHUFFkdGhOQjNjOEpYZ0djVmhOTmRsaExGeitIVDAyYzFMS09QcE4vOENHc2N3Sm9wODJGcFN6dEEwZkw2WkhlZ2M4TGhPeEtHSTZJN2lRZVNNV0xaUTNMT0ZVRkp4cnBoQUpsTE10VFdNaU9QQ1RNc1N3MFZoZEpjQ0l4bE82czlha3dmUFJxZkxWWWIyak9kUHBwNDlPZmo0Q0hDVXBJd2lnVHhmSmxXMXc3dE1Dc2s5d1IwS0l4a2hSUEtJanVGV0pBS1RPNGpDbFlnd2htZE5lSkhFMXBiS0dhV1FSTHQ5dnVMQ09BOUc1dCsyQnBOMThOVThNUmMrWEpuczc1aWN1b3huUEgvNmJQcGJLSlZ4MEVadUQ3UjhHQUZ3VDRLcHg3R3dHS0lnQklTa2xjbmdxUWpGTHN4cEVwdFlFc00wTVRRZDVtbEw1Y0FDMGQwSC9xcUx3MGdHa3hrTFRhNXZiUS9zRDR4K1d6YU1pZ3lNYjU1TlRrNGRmQVFySGg0NXRTTjh0bEIremtCclhsUkMzREpOYWd0RFJGd1lUcFdBNGQzSndJZ29qTGpEbVdFaWxnbGlCSUlwendSU1RqRE0rZlJodzBieENmNFlSbXZoMGljeEs1T1Z5V1F5T0QrZlhGc1pIUm9iNkpoK1BQWGxieXArY2IwTUdEYysvK3MvTll6SDB4MlRVQ3M3NCtQalI3ZDhMd3lqdTl0ZjNRQXpDVlNCelJWMm80NGdUQWlDbUpPS09JN2xZbVJITFlrTnBPQVh1cm5DY0pMTllSWVhNTzFEMXJnUURGakpaR3Nsa0FpdXJxMHN0KzN2ai9WM2pKWVBvK0ozZi95SGh2SHQ0K21CdG83dGc0OWhmZU5rSWg4MGlsam8rVEJxTnVyU1JMcktobHBBQWg0ZjZTMGRHRW9pamg1Z0RXYWxPSUlzWmt2RUJQUVQ0dW5na2Jsb3dCbENPQkYrVWVQLzJUSTVwWXpNam5BeXFWR0U0bnVkYlFPWGcvSEpYd0RHbElZeDJ0SGZQN3E5Y3BnY21adWJDSmZxR2JsL1Q1VTk0MWF6OFNDaHVDdVU3cHp3dGd2TWJPNmlXYXozZEtCbHdFelBBSmF0QVNHSzZIRStUem5VTUNURHd6TyttdEpodENZclkzUHpyYXRiN3pZN1czcERQVU5qYlFOWEFlUHg1UFQwNk1EUS9sREg5c3JXeDJSNER0Wjg2VEJ5UjBGckZuWVNYdFJ4YkdxWThManc1ak9sRkpvbG5sTGM4aVJCbE9nTlVGZkFQSUtrM3UzSkRTc1dETFZDb3AxZ3JhOUVHSTJ4Mk54Y1RJdGllN01udmhRZjdPeThRaGhhR1FOaiszdjdIZHRiYSt0MXpmUGgrZVlDRm5rY3JXZU9QK2JLeE8rZjJVRmdsaWtQK2dXbGxPbkdDdW8zbFNPWjYzbkNOT0ZIUXJsNmZOUFo4NGdGTEVkUklXbTZ1YW9FR1BDaWI5akdXcE9yV3l2TExVdUxTMzB0b1o2cmd3SEM2T2pvSHhob0d4dnE3Qnpybjk1ZVdWdXRtOHZvNHp3WUJiMjFJWHQycHlad0o0MjQ1VmdleEFZcVhBWXhRck9BOFJYeWhSTFN3QzZERkNhQWpCTEhOWkpkZWtOVXBrZE93Z2dVZ1hHbk1mYmhRMFlVVysrV04zdjY2dXZqZmZkYVFrQkR3K2kvQkl3YkdnYjRaMFlZd0tJTmFQVHN4ZU9EYmN2dmdNZDZzbTVlQTVtZnJ5d0JoczhmVEdQR0tJeG8wQ3lrSWxSbHRHRVM3bGt3aUREQ1hFRUlaQXFxQklleHJSQ0dBMkdNbkFzanQrc1hnL1VoRnJ1enZycTJCZVV4dUxUNC9XSjlWMjl2NzVYQXFEZ0JBMUNNRFkwTkRRMTFoZ0JJNXliNHg5cDZFbERNeDg1Vnh1MzhRYVphZi9NdXhqQm5VSXpna1lsK2JrcHRGMFBxU2xrZVRDbFNCdzhHK1FKRDJNcXpzRFFNRjF3MU1WSjl2akpBR0JwRzQvdlZ0VGZ2bG52dUxpNHUzVzNxNit2cjZycDNiekFMWSt3U01LNGZ3ZENXMForRG9WbDBoZ2IzOXZZR1EyT2J5eHJJYWpLWUtabTVHRUE1ZVM0MmU0Y3greGZYQmlaMnRWVUlhaHA2QnhRa1lCb3NFbUZJUkMwRmVRc2dZV0k3SGpHZzhVWlBDRU0zWDBrU0R4WjhaemU2R21abVhyMzZBRXRMNHUwS0ZNZnJlMDFMd0dLcHZ1OE1qSTdIVXpldkRNYVladEhaMDlrRFBPS0xpNHZ4MENaVURBQ0JtbW1NYVpGa1ZtUEJKY1k4ak9GZHBXQTJGUWJZaEtJTW1hYUpQRWhiaHFLR0hZMVFFenhFY2c3SlUya1kwUUpwT05wVkV6c0ZNTUE5OVczQVY2OW1Zak8zNzcvL1lYWHQ3WnNmdHpkZjMvMGUxdUpTZlZOVFg5T1Z3cmp4eWFkSFpaSlhob2JSMHhNS3RiU0VXZ2E3K3VMeGVHOVBUaUxycmJxanpXa2NkL0twS3dlakdtQklLVnlIRThqYXJzMk1XUXg5UmRqRU5HWk5PNVZ5SVdSSVUzZGRwcnpUeXJDaGluYUg4ekF5S0Y3Qm1tbDQvOE8vMzc3Umd1aTcrOVhpNGxkL3Yxc1BxMGt2amFNTGFBeENPK25Kd3BqTXdyaGVqakkrelNtajR4Z0drTWpDQ0FHTTNudngrQktzZUZmTGF3RHlidVUvdkoxZGF4dlpHY2R6NXcvUVQ5QlBNdEFiU1JjVkJRVTFrcEJOS2piZVJOUVZOdTBha3VKQTJHUUp3WW02NEJsbWwwRTR6S0RTR2Nvd00rNTQ4dExNRGlGNzBiSUoyVGJRNWlKSUxSZ0NKWkJLMUtnWC9UOW4za2NqMlpidEhyK1FpMkJiUC8zTzgzYU9yVWRNRWpENWs3K0lDLzArTWpQakYrOVZTVkpOS3FIUWcxbU81TWhpWDdRUlNrWFJIZlRReDV1bTBCY1JZajBYelFwMWI0TWd3Wm9lU0wzLzJZTnZHUUMySG40S0NxVEQ4OWUwTXdxMTBqNlUySzhWUWhSRXcxY2pDZVAyb2pDVzhtQmNZU1RJakV2cnRLNWRneDdZbzFoUFZxOHdKTy9lL1pXWS9PMEYrNzJ4aHo5aWYwUGl3Y05mdlVmSHdic20xVlE4YnhsUTN4TVUzckdSU3RDNkRrelY3SG1pcUhxT2FqQUdPdjFXdmM1U3E0b1MvZjJ2Ly9EZzA1LzgrTVdMNzcrUE1PeTllZHg1OXF5S3JWRmtUakF0QUNPcFJoNk1wYk14NDhwVm40UVA0OXExbFpVVnFOaXVWRjdodlZEQWJsMTlBMDJZSjk4UWt4ZUljWGdtdi8zZDcvOHBBQU9DZ2lUamVVYTFxZWs5RitXNHB6cGFGeFpvdkdPYXFpSUtsRTdRbnFFVXhmKzBDWWJGbzYzLyswL3AxWTU5Q0MvMzloNC9ycGM2UmF4T3FWNnYxMXF0QWx2bGNrS05GSXpMcUxyT3dvek5MSXoxOVlDRkQ0TjlhbGZLVDZBSXlRcGIyK3Q3ak1ucjU4Ly84dWpSdTI4QTVqMHFDRWxEUjg3enRtdFptdVVZaG9wb3Fucm1ZSURzaVRTQ0hoNTlxNEVIYnlESVFpVEJvMGhxOGVwUS9NK2ZYNFBDeTcwM2J4N1hHMVYva1JLbGVnMG9XakdLbUVYYWpBU00wNWlSQXlQWUk0RVovbXF2d3N4S3VkQ3ExZmVmaGF0VGFqMStzN2YzOG8vLytLK0Z4c3h3TFhTa21tN2JCZ1VQVmJVTjZrMU1kTzgweFVCSnFwcGRHN3ZGc0NHR3FtcTBZMnhKR2tvN2h4eTN2RXdmeTRTaENTV3c2cVJGRmtaQ2pTU014V1BHaGZ5WTRXY1N3dUN2RUVhYjN0cGdVY0hPTGJSYXRWcXRYdC9IVDl2eFhlNTA2djlHYWFGWXFDalFocG1JQXJiRml6eDZFVTlpSTBCa1cxSHA5L3VpWmVEQld3aWE2UFlOU05QckdySTBkTFplY1Z5MTJxVFZhRFRZbHl3eEhQaFdyZG94ekRoRnpMaVFiNGFmVjdNdzJqNlFBRWFaZUJBUk1LR05qUkJYcFJjcVVTVlJzWFRka214ZFYyVWJWWWNrMkhxWGFnMVVZaDdhVlZGUmtHb2syVUcvSWlpMlp0c2FRaWphVm43b2ZQNk1xeGI5MVFsV29FWnNobytqNHI5TmJaTXp5Q2IzTTJaY3ZSaUVpeEJIdUVmYVBveEtna1dML0tBZnVWTnNjdHNqK3dEVlpSZFBlYmRyMkpxc3VnZ0dXcmRuV3FoR0pjdVNBUUVsdVNTS2RGOUZVV1EwTEdoalhWZFNoc0pvYmJuYUtFWXI4cUtlTktOUW1HSEdsWTJOYzRvWkRNYktTaHBHWkVhd1VVSVlvRkduemRMazFpYnFVRUJFTkdSREp3QzhoSkJCc3dza1V3UUxRYVVqRldySjRBY3ZvV2lYSlZWekRWVzJCT1ZBdW5tUlM3QmdjcFE2Q1ROYWNTNkoxY2pBK1BuMndqQ1dqZ3RqSlcxR0pXVkdDS1BCWGJzcml6eFBNS2plMW1RWlZRWVY1WWliNElHWUtTSFgwRHpEa2xHSXlLWXVDNnBuR0RKaXFYUGdmRjNoaXNXanpNaUVqRmt3Zm5EaHJNeUl0Z2x3c1BkWWpkVjRteVROS1Brd1NwK1BobzV0ZGczSm92bW1ia3U4S0FveVpWUEowMVFKUGIxaDBiYlJkVk9WM1M3YUZFbVFEY1B0RHZTRDBmVjZGa2JhakNoOGxpdWhIUXpHQ3ZYd3A5OG1TM05oQU1LSzcwVWNOQkw1SkRBakNCcjR5WXZWNWF1VEE2b29OUS9iaENZV3VtbWdYelZkaDZlcHArT3FnaU9qYyswT2VxWm45elJKUXRtdTBWOWVHdWpEeVlkR0JLTkRiemxtSkdDVTQvZ1p3RUEyT1llWWtZR1JNU01mQmlYWUJsZmYvYWpUZ1NIOWhTYlhaRWVIbm9rbXhKWHBhTUJ4WllXYVdWNURMd0pJa3NLT2thak8wRFg1RnJmY25HRkdMY2NNdjloSXd6Z0xNKzVQd1NBYUlZeDRtMFJtQk5tRTRhaUZadURuNTRxYms3R0p4OGJ1SFhpbTVzbDBDZGJWTlVmemVOUWRncUxhamlqZ2s0QjZYYUVNbzFPVDBuUHRtNXRSWHAxdFJoUkFBek5Zb3hhMThKZmpPbVB4bURFSHhzcDB6R2pQQ0tBRW8vcmtMcDBZd2dXVEhqTWRuUWwwZXNJTGhtbklTQ0NDaVo0TUNWVUNIYVd2U0liTzVobTlzZnJacXdTTUdXWkVGVmM1VkNRMXo3aDhxa1p0NldRd2NtTUdZeEhBYUZTNVQwYnM4ZlZNbVpJSWJGRDlxYkNId29OdXRlbGQ2czlFQ2NVSXlqQW5tQXZyS3ZKcW9zakltbEZQd1NpSE1JSnRraGdJbno1bUpHZWdXUmp6WWthOFRRSVlpQm9mN25wam1tS1ppSm5VeWROSW1DYWpqajVnQmJwbk9RNktkcW5iMDlDMXliS05ZRHJReDZPdFdxckl5REVqRGhubGhCam5Zc1pzR01sdGtqR2pFS2tSd1dnZVRnNmcvVUMzTFRveGNGVFZVZGxrMUJ5ZzhCQUVHVzBiT2pocVhneTZIVW1IQytqemQ1QkswbUpNbVpFSFkrWTJPWG5NV0RveGpCd3owakFhWFBYZXlFQWVNVzNiOHl3TEgreXpaN3U5UVJmZGlPcWF0a0hEWWN0RWJrSEhvcUk3TVViYkhOZk1NNlAwZnpYanErUzVDUTJFNTIrVDloRm1BTWFUTFhuY2MybHVRMHJRb282VmpZQzdydTNZbW9XTzFkQU1MRS9sNlZScE9McU42Tm1ZQ2hrenpFakV6eUMxbmtYTVdEbzVqQ1BOYUZhNUsxL1pZN29XekRzMCtMTnBRWXh1Y0cxY282TnBWemMxdzZXYkt5SS9IRXE3Nk4yYkdUT0NwaFZmZXNxTVNzYU1NNEdSWThaR09OQUk1enIrbWphalBNT01ScE1yYmt4a20ycE9DeVdINmJwc3lPbmZla1JWU3J1RWhSUWtXeFZCUXhTbG5jTW0xNHhoZEpKbTFJOHlvNTBMWTdHWWtZU3hkaU9lN3FSaEpFSm9KWWFSVEs0QmpDWmdMQmUzMGIyaUUrUFJucXU4VEtNczNiUnB6bUZwUFlQM2RMQkFGMCsvV0NBTW55cDNMaTl6WEhXR0dWTXhJMFpCWmxSbXdGaHNuakcxVGViRHlERWpCUU5tTkRsdWYzdkMwMlBsWlZsVVpJTUtMVHFFZFpCTUVDWjRyYWM1S0VNa1ZPYmZpY3B2TmxDc1ZWTXc1c1dNU2lhYm5CV01PVEhESDNVZHl3eFdqaWZNd0FQak9tdGZLaElOTER4QlJNdXVxMzNCUWkzT1M0SWllYUpLOTZSNU9td1QrMjlwOE1sUU5LYk1LQjFoUnVXY1kwWWl0ODR6bzFMSlpKT0VHUVJqdWJpMjg3YmZQOUJOMUZlV1J0V21hdlg3amlFOWxVeGdRRzJ1U0QxMytOM28xdFZxQUdNNlpwUm0xaG1GNENTcFhRbGdCUGN6VHBOTkx1VEdqSGt3bUJtc0lKNW5CcjMwOGVyZFh5cUMwWFVVM3RaN3NNR1QrMzJVbkU5NWdvRXlTemd3bmJkZlhPOVF2RGlKR1RHTXBCbFRNTTR5WmhDTWxYbG1SREJxVVE4Zm0wRTBtczNOTDM4cnVtTlpSZTNwaUs1TFUxQkhVZ1JMbExzRDNiSEdCNk03TjVyRXJab3lvNU11UUlPdU5Ubk9LQmZtbUhGdjBXM2ltM0h2Zm5DTEtWMkNKc3hZalhGTW01R0MwWXhnY0Z6cDh0Wk5UeDRPeDkyQkp1dXU1Tms4anlncXE1bytIb3J5eDhuOXd5TG5zOGczZzlTSTY0d0VqVUxDakd3QXZYZTZtSEVNR0t2UjRjbVVHZkhjTDIwR2V6WDRHN3NUdWlQc2FwNnJJYlU2a3FkcnN1MGFnamlhM0Q1cytDODVXRTJhMGNtWVVjK2JkQ1hOT0NNWUYrYVpjZkZTdGlzNXNSbWcwYWhkdlg4SHNlUEFHby9ITGdvd2JUeTJIT250Rjd1YjdVNGpmRDN4SERNNlljOWFyNWV5SjJyUmtVRnV6RmdZeGh3ejF2TmhaTXlJVHRiOGs1TkcyZ3oyUUo5c1hMKzdNNWw4eExMcDAyVHlyNjE3bXg4YWlSY1RuNDRaaVpLTEhTOUdJYlFRc1NpRU1TT1krcDFyekRpR0dTMC91UVp6UHdhRG1kRk13R0M3WmYvd2srdWZiZTN1N0h5OWRYdjd4cXRHK2pYbVo1dFJTbTJVTEl5bzVzcURzVmcyMmIxMU93MGpPbTFkei9Sb2lYbEduaGswQlowMkk5Z3VwUnA3Sml1RlZyM1lUS05JbXBHTUdDR1B0Qm54T285c2Npd1k3ZkF0TE1lbnpaZ0hnNTJ0VC8vektET3lNTmozS3hUT0pXYUVaa1RiWkMwSHhveVFNZE9NdU9vNjlxcG16U2o2SCtFK0tkVVR5Zlc4elppQ3dXNW9YRndQVW1zc0JqME5NOHdJRHd0WXA3WVlqTWFzR2FoZmFNUnF0TTR6WnVUQ3VKU0EwUTYxb0k5S201M2VaTXc0QXhoSk14Sm5yU3k5MXFJQitiUVpaNWxOZkJqQm5ZUlVvYkVlSGNBbkFrWm03SmVKR1F2RHFHYk42TVNsUm14RzRUaG0vUENVTVNPNnVoUEJDRTdpMTlQWEVUS244SkVhQzhCWW5ndWpFOGZRVW1CR3NFdit4OXU1OUNhT1pYRzhkNmw5cldiWmk5N1ZkNmlrVkFrUXFzaURGQk1nNUtGTUJZalZKWlFzcHFWQm1rVkxzeDFyZWx1clllRUZDeVFXSGlGajJiSmtnU1dueE5PV2tKQzk0QVAwUjVoejd2VVRUS29DSktTZVVhVVMvL0kvcjN2UFBmZjd5dmg1VFdYOEFBd21BQ1AxY3NxbytNcWdWdUpMNDNGbHJOVFRoVEQ4SXhaQkdHNUdIcFpHT3F5TTY3bmQxblZneEpjckkvZkR5dmpIMzM5ZW96WlpoT0htb0c1NTRnVVVOK05LT1owN29SMDF2MUo3YW16MVlFUVlTbUsrMys5N3lsZ2RSdEJuTE1BSTdCYzRBWVY1dEhObmJSaFJocEo0S1dYQVI3eit5My8rNngzTENzRW8weTdodTJEclk3Q25LeFhxejNDM0NsYUZNWStpNGh2S0VtVTR1eVp6alR0cndFQmx1REErTDRGQjAxRDR3UlNwb1R3VGpNQWE2Rnh3alZhR3QxRVFEV09WUTg4THlyaHlUNXhRT3psZGFCSU81aG1MTzJycktTTy9xQXgvRVRSQ0dXNXBzZ2xsNEd5cUlBd3Z0bnJ4aEVvakNNTnJCSTNlYTEwWlJxRlFpRlNHMytFV29ReDNvWXZ1T3p1aGRXVVlyNWZBdUY4S3cxVkdiRlBLT0krRU1hK00zRkpsUk1CNHN4bGx1Q2V6cURTY2h2cEFmQzI2VG1OK3J6WHhMTXFJTDhDNERzVVMxMHlDTUZiM0dWUVp0TjNQODZCQk93bTVEWnB2TUkvdHRhNEFnd2JXRUl6S284cVloM0Y3ZDdvUm4vSFRLakRTait5MUxzQTRYd1ZHMEdjc1YwWnFzekMyWG9WaGVBY1lnM2JpOWRTN3BySzRWZUR2cUsxaEp2bUlacFVnak91Z012ek9SMm9tNVkxRmt4QU0vd1Rqbi8zK3JYTU1oOVlvUVR0SkwvUm5oR3VUek5zZnJWc1hsVkVKTFB3RllTRDd3Skxmb3pCVzhobS8vQkVKQTJuYzM1emM5dnNNeU5EZlR3ckRpSzBGNHhFekNiVWtoQStjWEMrRlVWM2JaL3p5eDllZ3ovQ2R4dW05TkpPcWZWSHNNN2QzZDM2UlVsd3NUOXh0ZUEvR2szQzRNSHd6cWNUbjkwMnk4NGR2ZkNOQkZnNk1xeTlmUHEvaE03WUN5bkJqNnhVOUQ5K3ZQaGlHclpMcEZIalV1bCtrVGZYQjhpVGx0WUw2YmJFcnczQnIrRW9vRXcvazRuNVhMRmJOem9GbkF1UFVnVUZHUnF6aE15SmhvRElBeHJUUm1CQWUxZkl0dy9UcGdkbzVHS0hWbmVkUVJpNFhkSitwVk9BOGdhZU1DQmhQOXhtZU12NGRna0ZvQUl4Sm8vSFg1b2NwbmM5UXhwUHhJbk1iUEpvMXA0eEVFTVlQWjZCUkJYd2dsZ1EyVFVJSHNoaXlTMEFxa3dBTTRqUGVyS2NNRDhaVkdFWVR4MmMwUGsxQklLQVF5YXFlTXNGVVkwNFpQb3luZUZBSGhuTmUwVjBkZDFqRVpibmk2WUowTUhrdzZERjQ0akkyQWlOQ0daNEhwVEJ3N0E0bDBrU0ZxSmJJaFBPdWFHV3NBR04rT1lPODRFL0VURndiQ1IzSElqWnljUkhJdWRaWHh0ZWxNTUJuTkQ5UkhQajYwRHdhekZycHVST01rY3A0dXMvSUY1eURySjR5VUJhWmJNOHljeFVuK1F5ZStXWWNYVkJoNEVGT1A3UytJVDVqYXhWbGZQMW5CSXpxL1ovM013T256TGhEbVloQXBzdGg1TmFFa2ZkZ1VDT0o1ek9aaEtrcVl6NGh1MjA3bElSSXhqYlFqYTB3akM5QlpXeXRwQXlFc1pob2xHKyt6Qjdzd2ZTRGZ5RlFzK2txZzRsV0J0MTV6cStuRE1keFZ2S1pkay9vNkFwZmtkMjJIU2U5UVJncEo1SVFJM0VTME9yVldqQmV6Y0VJbDJvM1Y1YWtHbUFsSDQ1d0VGRVRZWWdNVTR5QU1iZHprbGxER2M1R1dyemRHMnVkdW00VEdEU1dwSmxZUzI0eE41WjFrMnFKcEVaRFdaeVE1ZUNRTWw2dm1vRkd3Y0MxdnhQTXRrNGVwdUF0UGh6aE5FRklPMmF0UjJCVUhCaUZWV0NFbFZISnRDVmxYNi9yZFFGZ1hCTmxRS29sdGhnZXA5N1lENnAxSVRMVVJrNDlHRmRyd1loVWhsK2RsRS82dHdSR2Mycll4cVFaZ2hIc2ZvemFVOHM4YldrbnJJeDRoaGYyOVlQOUdvSGhLQ01OTENSaGdOUGJ1SWt0aWVrNVpWeGQvZnJaaDdHMW9qTEl4a2tvNjZxNk1PNElqTWJrd2JMd095S0p3ZWFkVkdDek5hU01wMnlxUmNGSUFBejdrc0l3NHhsWlR1QW5rbHZXZURBaFUzOGFqUjNiNm91RUJja3kzS0wxdDlWaHZGb0d3MU5HR1dHQUpGUkc3cDlhVnRWWitVdkZydDNENmJHb3VyV3dBV1YwOVAzOU9pZVlpVGdZeUhVc203dTJCRWlLdWVQanMrTXpyakY5S0xjdWJ0RjliZ2dHVmNidkN6Q3FIb3dUQndaODVpS1VKMFZhdDZhY0VUeGtDTTc2UG1NZVJpTGh3a0F6TWEyWnhDZXlMVmxTemhydWZaZzdYTk9BRFBEQ1o3RWhaU3lIVWFZd1BnR01HNFNCdFVtUklaT0lUay91R0JFblptV0RQcU95WWpRaHMxUUtia3NHZmpDQmNWbmIxbXpiR05pU0xHY3RtMnR3WkRaV0U5U3hBMm85eFM4akRPUHo4eW1qN0N2anBrVVhOWXJwZmhvSG1hbGpMRmJNZEpidThOQVNudnFMd21MMzQrTzFHa1dSa1F0NWttNVZjbTNUSENyN2RUTFZyMWJYZFExZzhNSzBBUWF5TTUxTXBqaFhyekVWckJhelFSaGJqOEFnZlc1QlpkemlnaGZvSW1YaERNUUpmRkVEUTVqeExUa09TUkdCa2ZFSDVzQTMrd21yb09jWktNY1MrY3g1SmwrcFFBNCtWaFN0czMrQUYwTnQxN1oxemdBWU0zQ2RvSXVwUFp2WjArYlJUbU5IaVlEeDI3cDV4bmRoTkQwWWQybnhaS1pNUUtwNkEwZVc0U0JLeUpmaldXU1JOVTJ6M1c0bjhsUVcrVVM3WFFrL05IaUd6TnlpZWFITjk2U2hPb2FYT3V5MTg1bjRlVnNkMU91MTJnRzlKZXZnRW1EMFpCNk1CSUlxaExWVVN6S21qWjNHa1NFOUo0elA4ekRLODhvbzl2dXpRYlBCN1RqaldvSEhSTEN1WlZ6MWswMFZIMmdJajNUK05wOHo0Um1IRWp4ZWdicUdRZ0llRzE1bXUxTHdTRlRhdmFHZ2FOK1NPTHp1Y0tRTXpVTCszQngzOUZycHdMMHk3QUJnV0xJS3dqam16bXdlL0JTakRoQUdGQWNNeWNVeEdkOWNOUG5YNHpCY1pkemRpa1hKQVA5Rko5TWY0NlJTanJzMHBKd2N6MVV5dk5MQjRXdmZCUDV0SHBTdWpYQVFtekJzaytlRzl3Z2F2aFQzUGNEQ0hBcmFLTG43a1MzVldIaXIxVVpDci9EV0hJLzBtbnY5RDg3TjI3YjVtSUFzR2dNMUxjZGFNZmdpanI0SDQ2ZG5ndUVwNDZKbDJkUEdFUjFicTlOeGgvQzdNY3ZLY1lpR0duemg5YnF1OFpCTGYrdlc0YTNiWmJVeFR4NWJHYkZkOHZxYnBwcFVHKzJoMXNYUmIxMldMUjBlZ2poMC9VRGd6OXVnRERBVHFveU9wdGdQa21rWitoa2tGellQV1doTTVCVUtRM3c1R0tGb2NnOHdpa1Uwa3VZUmlmT29EZTc0M1JuaU1IcWdEVkJHclZZNkxOV1YzbENyMWRuZFpISjNGd0N3Z29uZmJQaERjbS92ZjN2d250SFlKRERNOFc2ZC9LdmRqNGQweG5aSkg2azVDb05JbzFZemhudzZDNFl4MFRFTmZ5akdSSUJ4YnplZkZ3YlpldjQxRXNZbkIwWWYvOW80MmtGZFRHeFZGUWFjam9OQjlVdWJ6OGdPak1PYU5sYllMa3V1elVyaXMyc3FQd1Jac0N5OWR4TGYwM05nSk90czE1dnlpRERxQndaZlVSWE5Wa2I3d0lPRHBDc2h3My85ME5FeGxLaGlMQVVwWDltQkVUU1Q2Z3ZCY0pYUkZ5MjcyU0JCZmpDMnhEUS9NOTV4N3k2M09mMVNoY0Rvd1BnNDBwSmQwQVRyM0R3SWxpSm9YWGJQZjNYWk1YRWJiWVNSQk1laUdkcW9VOExiV1d1MXpyRFNreVNlNWhuMXVzREU1WVJzS1pjSUF3ckZXQnBnM0JBWXh2UDVqRVVZNVFWbGlET2pDY3JndUNQaHR0WEt5dURKZEc1Nys1SUQwNGlmdXpEd05yV1ByQWNENzFVRGlleTV5a0FZU2c4UGNMYkJURWJLR0ljYjlvYkt0enJlbWxZcmphL2prS1gwRU1ZbHFVM2tuR3daN3dERzhRQmhwTUZuVUJnUVdrK1dLbVBEMFFTa0VWYUdLR0pjUGRwcGNvT1pMSXRaK0tsMk9BNWhnS243TUVyb0taTHd5MjZTM0NRSVlCem55VG93TkFsZEtIaFZRWUpZaTVsSmpoZEttRnJVYTRLWmh6eWw1eXFEd0pDMGQ1d0hReFF0akNaVDIyb1ZYeDZHN3pOVTlKODdXRCszV3VsVVdpVGZzdTNMN1ZyTlpqSytNdGlPSmdpQzV0OVh5aWJmYTVCVnZxZmlZTm5SRUdHMGV4THZaMlREVWFsR0hwK1BaK0tac0RLa0FZR0Jac0trV3d3SnJkT0hxdmhTTUc0V2ZZYm93amdUK0phWVRvT2JSODhHTUxickJwOHhIUmdsTUFPcG5ZUEFtV1NkT3lhN2U0ckVtME50cit2QVVFbHd6ZFA4Njd5UWE3ZXpRNjFVcDNXcUI4TlhCb0hCVFZTRUlaOUMwblhVbU14T3hRdkN3bGtCcFRCKzN6aU02a0xWQ2pCdVBSalRoeE1DUTVTTEVQTnc5cmcra0R3WWJGMGplUlhHVTZLTDNlNTdSY3JUdklJbE1MNk5DMTdpQlpucWVBeENVa2FIYzhvNDhKV2huWEgvcCsxOFh0TmEwemcrdTg1K05uUC9nRHQvdzkybEtYaU5FMko3cXlQUnhGcHhqSTNPRWRHRmdvSXBKeDQ3cDZJbFRvVkJWN3B3NFVMSWhjT0lFVVZHakpCSWpMOUFDTHB3TzVtQmR0TjJjNS9uUFQ4OEhtMlNhc2QyMFJZYXdpZmY1OWY3UHUvelFHaDlmb21Id1RWTWRrNkxXTUk3SldXSU1CTDBxZ2ZDOThBNCtKb3lBRVlGWWRoSzJ1azFENlBYM1JKZ1BNdmwrbWRtS0QvTVZ5MENBN3hIcTByQ2g2Wk1rZzBKaHNFenJFS3EydDRoWTVUSjJra0ZqSUxvUVBmNXBHdGNxVlhVamRGcDhmUm1ndCtTM0Vya01GYVp0djBWR0lMTFVQaU1YZDZCWXZWOGVRakswQUlNZGZYNjRzbGpoTkhRbkJFWU83bGN1NHVsSzBpamZxN2lZWlNGbkxNUElIN2VsbUJBcHRyYnhsVjBtSXJuQ0F5Rm1aQ1RMaU1mV3ZmNWROdzFIZVR6cC9CSFoybDNJYzJJUzhyNGJoa29md1o2ZUxDUVoyQm8zWno1REZ2SkpzSm9RdWJJSytOOEIzS3FGMWk0bnBVaGpHQXcyZTZMVHJJdGh6RnN0TjVoTmk2TzFuNm1VSWJnTTdhSWF5cGlZYmcvYUV3dkJ6Z052amdKZFRvU2pOQ0IvakJFL1g5Z2hKWXB3N3VMU2RjdkNFT01KcmFTYmlyQUdFa3dDcXE2RWthdkswVU1nQ0dhaWFtL2pkRVhjcEtkWmh1S3VpYnU0SnhYUnI0dzRkQk1YTlBySXRiSmtJU09idkw1VGN5L0tpNExmNWxHQ25ncjVFaHJ3bmowNDVFRXc2NDg2VHFjanlZQW8rTWo2WGdSODR3U0tvTVVEYnpQRU0za1dXRm5Ec2JQa0lJdWhRSHV0QUJadStvY2FsVk12UHF0QlFjS2Y1dHdIa090Vm9KQ0RRK0NOemR4NmpzeDFISEp4VjhVZ0REMERvbzlDWWZjQUlNSnIrb3pIdDBKZzQ4bUkwa1pPS3QvT2lxZWJrSUpmK21xUWY1VHFlRlJwY0tCRnBvVGJnWUQ4aTdNc1piQTRPcnZvRXhUbmJmckRlNU1ZOWlvTG9SV3ZDcG9kWFdtSWFmVzlrZEZpQ2Zrem1UenRKakhpd0lMZjgzcWRYa1BmT0dqTjZ6UEhZaUxNRlk3OWp1Um1jbmNWWUdZam85bXlzQVNmZ0I1TVB4a0JsVnR6YVl1a2RTUXdHaFZheEtNTXFkUXhqd013V2RVZTZnTDFYbjlTa09PUWJ1OW5LaU1taGhOSHVkZTFxZlZmbjhNNFRSL0laeU01NHY1UWJWVGNRcFhTRTZIM3M2Y3ZJa0dRMVFnSGxrZEJwakpTVW9KUStZeTlKM2RTN0lCaDRmaGRaWU9HNlBpTC9zZzA4SFVWcXFWdVBKKy9na21YUmV6cEl1SFlSWmdiQytIMFREc05iYlBlZWZxd1dOQWc2a1AvMXRRaGdUajZjc256ZXZyRVo2QlZnZlBpOEpuTkttNjFCMG4wTkE3dEVaM09NeEdrK2x3d0wwbWpEL2NEZU93QThuZXpWOU9NZlVGTTluMWRsempTUkV5RGJDVVFhTTZucFpIRjg4QlJxN3dzbndtMWlZS1pXeC9CUWFVckFSR3UwR2VoS01IeVluUnBPWWg5eVprM3cwZWRXRXBwS3RPcmtmNyt6ZWo2MEZqWENrNW5EaFB6V1d4QnROdjA1bWpaSmF4dSszeFNHUjFuNEVPTkNYekdlNzVXL2pEUSsvdXVERVozRUJSaERDOFhtZW5BbmxYRVE5MzhqZlgxNWdrN3dPTVF1RzZxM2tvRENUd1Y0QlI1bUdvK2pnOUFxclVWemtwendBWXcwYnpBcFdCSnZnWS9YV2x3azB2NjZTL1RGZnBrTllNcDBVZEN2L2puMy9MeG82T1V2NEFnUkVMLzdDNk11Wmd5SlRoRS9xbGQzMjQ3ZVZ5NnVzZ2pGMVg1UUFiMzU3dm8xdEhiNFl3bmx6azhVcFVEc05ndmxjWkJJWktsV3Mxcm9aUXdUY0xPU2tEcldscUdraGdjbVF2Vk80QzRuYXRaQ3RWbk54NFBPWXNGY2h4RUliREczTDdvK2wwTk1nY0g2ZjhjWUFSajhUWUgxYjNHWGZET05UL3I0THJiNnhqdllYc0xuRG9TaUh3cWVEUzkza1V1QS9vNGpFWTlUZkJBR1dZaUpsc3E5N3Q5T3JsU1ErU3JpWXUvZUdWb2RtcURjdE52RERJNVovZ2tUTkc4Z3F1aklEZmFyNVJ4ZUhhdFlkUDBvdzlTQ0VNTm1FbnlsZ1hobitwejVDOU9MSGdEYSt3eDZHakkwMlJlV2s1RWhoMWE2cEZNLzhhRE5XQ21iU2hhdTIyU2VXaUFodzd1T2VtMTJxK1FtVk1yZ0FHU0dNOGVZcnJaSExONjhtVXE5aEkzMDVIMitGZjNPQ3RyMjQza29adjMwOEhtT09qVklxTzJ3T1JvSitIc1VwUGwxd1pnVVZsNlBsWEZsNUh4K1VWWWJncXBWQmpNT0liQThqeW0xRjlxcTV0SVl5bmNoZ3Y1REJlS0dCQWFJVXlqcFF1TytRWU5OY3VnOHZFVFZDRHFzZWdNVzF0YWNhTmNoMzdVcXFjd3lhODNCUStwSjNMb1hOR2t1OVBrbEhhenJ4SnN2NWdBSUtKQ0dPbDNzY2ZrM2ZBMElzYmNNVE5ML2l3MCtubzhEZU1OemQ0Yy9LeTJib2NlMm9lY20rU0E3dC9WZGhXd3BnemszTVJ4bG0vVjhCRVE2V0NRZzBJVnJ1OWk2ZWdrSHBWWThCbTJGcE5NK1E0VHFlcDFXcEd0WFlPaG91WWlTTnc4dm9vbWZMYkV5ZFJKbUtuMW9YeFU1cVlTWUtjZ1M1L2ZqTmJkc0x2d1lFOFZOdlJqNmY5OHFRK3FKY2I0NkVOKzNnMTByM0puK3NTakhOTVFSVXc4QWp3WjRCaHhzTnhLTk55VUtsZDVPb2NCTmNtTHYvcFFqVkNwakI1eUpRdThuaVJWNGJMcFpNcncrV3luN3hPMjYxME1FNHp3VENEMFFSaC9IRlZuM0V2REd5YUlqQkVaZUEzZ3EzVGFqMzQ5dXFZYzRCUE14bU5KazF0MkNlWGFLOTZSQmxtZ0ZFbkI1K0Y4NTRJbzlIR2cxQWV4c1lHMTYvamZkck9UcnRWdnRveWM5MXV0WHJGRFkxaUE3MkhiQWt6MmNSM1dDSUxVUmt1S3YzNmlBN1NBV3VFVGlYWmtBekdTclhKRWhnTHJ6bDM1NVFoOU5KcnlUNGdvVUVEZTNjMEhqVlg3WFp4SlZCM0tNRG9JNXplZHJzdUtRTnh0WHF0RmprRDNmQmNnVnVBVDc5Nmh0czh6S1JSbzdZMW0wZ2xIMWVtbTlFUWxVRmwzcngrbldaOFBpYjk1ajBib3RaWEJpdURzZkRxV1Q5RGdlbXZWNFFCTkd5a085Vm9uSFc0bVl4bjhCa096endHN05GNHNjZFY4WU5YMFFLTUlmd1ZiNS9GZjlEZy9pQ09HNTd0NGRCeEFsZFkvc05QcEpwTkVSRmZic3FWNGJTelIrK1BzNVRESGsxR000azF6ZVFSRHlORzJ2MWtyemtmQUVOcXB0ZEtQY0llczlpVllWQk1JVExQZGE2WWwzUm9tR1VqZGpUenlwakJVQ3BEVHlYb01Cc0xIQVNpYVRZVy94NCtneFY2SCtkZlpzbmVMOHBoZUMyS2FRbmErWWxNZklmYkEzdmNEUGhMTmlSV0kwZUIwaERuRGkwb2c4Qnc2SzFVeUV2RjZJRGRuODNTQW96c1dqNERZWUNkQkFLQndQeDBBSEdLeHNKS29HVXc1cVpHUExUaGIvNFIwakpobUpiNkRLRlZXbXVKeE4wTUc0N2JZNWtNWDZpSk1CNnRvQTBCQm5hckJDTUJoWjJRM1I3NmI0Q3hvSXg3Y0tBeXpMTkhTQjUrOXBMb01XUVRxUmFWUVNaRk9Ld3Ntd2huMlVROGxrblJFYnRjR1N2QStMMW9KcEZFbUpFL0xKaFZhaElNZmp5OVl0emgzV1p5bnphVXlsQUtReHlQb0Y0MEUvaWhPQ2s2bW1FU2RKWm1tR3c2U3NjRGM4cFlvVFpKWmxFWmZpYjg1VGJBWHowcjVxc0lJMFZFR2hieWZVakRkM1JhV1Z1czUxdVZZZGd3S0pTaDBXam1Zb2swTjBNR2czOWJvYlZRMldTS1RqRGhETTNReWIrL1RWRnJLdU4zUDZVQkJrT25icjk4dUVVUGFsOGVUK1pnT0dSejNIVHJLTVB3ZFo5aFVnU1RPUmhrUDRIYUVvZ2VzOEVFbllGYUxYWDg5dCtzbFZyYloyUlpPaEhHY1owcEVNWjhQQkdIbDgxZ3lBYkdMaXJESlBRSWIzMmptWWhQc2p5ZXU1UXhYNlk1TEM2THp4OWxZMHc0R3MxbVQ2TGhHQlN0MzBFWk5OakloMzk5dUkwUVpWQzRBOXduajY2NGxOSzdESVpDR2VKNEtqTHVVR2dUTnR3bkRINlFuY0pNVERPWGdjOHJ4SmMzTW1VUW54SEpzckZna003UUNUK0RLT0xmUVJsaHY1OEZhWHk1L1JpaDVMY0ZNenZ4ZXIwUFVzWnNPb0RZUVA0Z0dBcyt3eVFvZzlmR2NtVllISllJWmhjaGlvRU1Jd0x4TVBJOWxJRTFQRXNHMjM2MFVwUVY3MklvcVpGSnpMc1Vxd2VGZ0tKVWh2UXlTeFRHUTJIc0xVWVQvSm9lK0VvYW0zcXBNaXpPZURhZGliaXRibXNrRlFXUktLTEpDc3JBYUlJRk1NRDQ5ZGRidDV0eWY2SSszbjcyZlFyeDd3cjBRdDRsWDB1cE0rTGJQSTFSTFl5bW4va01FY2JlV2pBSTF5M00yczBnRWZQR25sRzdKQUcxN01Zeko1bTR6NXFBa2pXYU9zb0Uxb2ttandEZ240Z3lHT1lXN2VURHJkMGQvMHg5L3M5L2IzMmZ4TnVDMllaakFZYkRwY1BaRGZ4VEthMWlET2JXS2o1alNXakZoWDE3SGwwb0VBbUVkQjZUYmZiaVd5ZUR3V2I4djNGMlBxR0o1RmtjVDZjN25XUjZacmFIdnN5eWMxa1dwdWNQdTMwWUdMcG5sNjFqekdVdVNsQkRFZ3F4Z2hvTFNRZ0tLZERFUkczYktLMGRyWlRHZ0ppaURBbzJVYkFiVWlBWmN0bERrYnUzT214ZHJKSktKV0QxWmQrdk5Fa3ZEWlB1K1YwU2dxU3FQdlY5My9kK1pmM2VqM1FuODV1Ym1XeDJKK3AwL3VFNlkzeDhZbnhrNHR1ZjRrRlVaNkFnZVNjbkFyaDJMc3ZkOCs1S3ozVzlEN2gxZVdpaTZPVnhxOGMyYTNiNkM0WDRWbjhhdlNCdUxMSDRvUEhPNzNyRy9BY3dybnJLRE5ad0dwK1o3cThWUXM4Mzl2YVdNa2s3ZHVNWm9CRmpjZStDZTVsTWVna1hrY2hrMHB1eFVEb1lDUHpodWNuNHhNVEV5TVNUVEFIQkNCc0dtZ29FU0xsMXJnQU1xa2NRUTJWQUpybWV1bHJkSG9kMUxicXoydWwwZHRMeEpONnpvWlVWSnZzSExabG1yaXJ1MjVWaExKMmZuNE41bXRGL2U4Wms3MUZPcUNrdk9xd0FnK05laEJkOWppdGxVS29MOUhpMkNEZUdJRHlPQlR5Y2owYlRtNkdzZitnWmYvMTYvRk9WZ1ZoTWpvLzg0enRRUmpqaHo3NkRzVVU2dlJwSXBLdDBrNnE2NGhxbUUySUYyY1pnTEU0dCtKZE9lVUVVR1lFN1hNcUVTUXNvMXdFVHpKdmxONlliRnIvVGMyZm0vV0ZNK3dlNy9qZzgrRllwOUdLWDR3UlJhalpiclpiQWI0ZE4wd1lMczNsUjY2ckhVOGNHRFBlQ1pkbnFUWlNpMlhnaGY2Mk1wNDhtUGgzRzVPVGtCTURJSWhnb25aeS8wd0plNTVZbUE0dHVWMUZVcTlGcXhrcHAya3B2Q01OdG5vcnZjNHdraVVBREJ0MTVGUXVGZG9LMnVXbjdOWTFCZi9VWjBQdjhiUTBTcm42YjY3bW1mTE1ZbGMyRU1wc1hxeDJhWnBBa09JN25XRm9TK1hYY1lVY3dqbjhsdWczZFE2anFnZ2V0Y3JDNHJkNUlNSjhQRjBJN2hVRTVIbno2NkJPVmdXUXhPWGwvY3ZMN0h4RU1xRmtpb0F3NVJUcEpYRWN3emk5ckdtRjFVZml5UlFVdVBiU3lHSVo1d2ZtOExsNmU1RmdPN1dqT0NEeVB6bmhwellZTisyQUNpaG1mQjNlbXd1R3dQd1h1WjNxdk96M0tOajcwbUdMSzQzWTdZR2JpczZKWFRKSXBmenFkTW1OWVlwZEQvdzhGQjhPd0xNZno5WEs1bm1zSjI2WGxHZFQ5L2MyeHFyUjFWVlprNG13UkxYWjJXd09wU0RRRGNmTGJFTVkvdi9uRXhEbytZQUhqODE5K0NnT014Rm9rS01zQXc0c1BZQ2p0YzFudHVYUlpwL1JHVzE4K1d3QVVGcXVkS093THRhcHhqdWkwT1FGdEtpaXdNUkt6R3d0d1VOaFBrNFZYZTd1VkNsdXA3TVhpcnB0Ry9EWXlBQldkTjVCY2k4U3owWlFQTTYxRTl6YVdOdmEzMmZwcFpnWERTaHdqc2lBNGxnZklhQy9vZ3lKWEwvTzBXQXhSR0NydzNrd0JERTFyWHlxcTJZT1dMa0pLaWFRS29mVlFQaDgweXZIVXMzK2hOZjRmRDJQSTRzN1kyTmdYUXhncE5DSkpLRUFEbW5LdUtGMUFvL2JJN3FXaTZZMmE1bjV6M0hNRERCOFpvc1VtQ3lqWUhNUHhBMTN3akZDSno0R0xRbEVBZDl1WkJwbm5JSTVFdE5OZ1p6MktYK2tpc3JweEVic3dScWR6dU9QQmJQRTlqcUZSdkFuY2FnQTd5L0RTQ1lpTnIzTTBiWmduVXl6Q3dUanBZSWZFekE2THJ1bHF0eUhMalhZWHhZa0J3eG5NaDBMNWJEUWROQjd1Sko0OUh2bDRZY0RucmxqY3UzZnZzeWZmb1RCSlJOYU1sN3FjcEJPRWNYNnV5Q3F1NHoxVnVRUWE1MjBkVjFYS0RRZjNrYkdpeE5UTGRicDJkSUNFRENqZ1pBVnVQV0NDUUprMlliYXRIZVN2VXJOYXJUWmJseExZYkNqd3F3R0RqUEc4TUFnQ3VNei9WaExZNGpxSG9ERjBUaXJ1aHJGK2pCZGJOSTlRdDA1b3VyTzB0TSs4TGRiTG5GZ0ZaVXlaZGFXdDZCcTZVWnBPV1EwWWtGOUxzYzFDY2kyZVRTQVlxY2lmSDQ5OHREQlFGcm5TeGIzUjBidlhNTGFNcDZDa0U5SUpXS2lpOXltWFJZZVNRNUdWY3pnRFJiTkFrUHJ3VEZFRUdQemJCbDFaVDJkZVZIZ2dBZHBnTXg1czJnNGxRbUtiRTQrYW9KbzZESTUrMjJpTDNIN0NqcXJKZUVlVWpMMDZHWENjcXNqczRNU2UwQlNNRHg0VStTam15Wi95WXFQSkFXc3B0NUgxVW1TK0loYnJkVmFzUmduTVJzbnR5NGFzZGJ1YWFuRmJsbEY3R2ZqcERVS0FVQ1NjUFBwR0xmSHZwM2NCeHNSSDBiaGhBY0lZZmZEZ3krOS9OT1lta2JYaDgzR25EdHdCaG9ZVGZUQnRWZXZLU2xkREN0RXRaOGd6T2t5T0wvUE5ockNmNnZYSWNLZ0QxeTBjOEljbER3WW1zUGFjRjVzNVEva3NoSHVkeXgzVmdFYmNoMkcrVFY1c0g0RWRvUENpRWFNVXZzc1hjMXk1ek9kRWR0K1ArZkRDSHR1cTBRZ0cvU3JWVDhaakVDNWx2aWhjcER6emR0QXN1SmtNN2trZHYxbTRnaEZJK0oxV1l0QjlLTGtWL3VHYlVYUjlJUCtSMitxdWNhTzhBT3MwZFBIZ3k2OGVmUDV6YWFDTXErZmpKSldVSWJYS0d0NG5WbnBuUUFNZHZ3MkdTaDFicDl6SkMwRml5M1htaEgwZXNNOWdKcnl3eW5MQTV6UkRZWE9ZNVJYb29zcHp1V3JycU5hazRUckxYT3Qxazk5RDZTWnp5alNQZ0NUNjQ5c2FVOW4wRXFFS0N4OC9aWTZZL2VBQ3FNY1UzbUNiQi9VNkkrV2VGd292S215UkJXRTAyWkRWNXJPQm02dTZrZlYxeWpQb3dnUXduRnVCRmN2ZzlXQm5jaTM0N09zeHlKTG9sdDhtanYrUEVXQng5NnVIdjZBU05KSzYvckxBbUtoQlNkNGxld0NqcDZMYm9jZ2FsQi9xc1hYQnZKam1SSVlEaDZmcHBWRGNueVQ3Sy81MXZuNFkybkpnbU1OZkVkbzVqcWxLQXZoRzdXVU4yUXVvU0dKWFNXeVd6RlE0NmVVSk1wbFdXNnhrcUhtVE9WbzVrQ0J5eEU3QmpabDgyRncvelVvQWd6NnFzbkFFcEs0NkxUSjdRWjk5eWdIRmhhcWhzNEhUVVQxbTQrMDJxd1VQT0NrQ05TeERNQ0xCdjQrTzM0R1NZY0xBY1h2WitUNkx1M2NmUHZrNWFDem12RkVHVE5iMHBJYVVZYUhRMFZGNXJoS3FScDFaTFI3N1ZneDh2bDduV1lIbjlqc1g2VklrRXMvc0ZIQ0h6NFI1WTZ6WTV2aW1SSyt1ditqUXpkZU5JcnIwazlmaWFSWllRVjVtWDc2bTYyWDJkWTNiSk5IdVVJSGZjbUt1eUFnaDNHUjRqcTlrd0dDYlJRZ21TTndjSkZ0aE85dWZ0WG5NaStZM1VHRW9LSXJsQVF6MDV1TUtoZHFzR1RDU3FkUVAzNDdlSDN0MC8vNzQ1TWZBbUJ3RXlaREZaMTg4L05QZlN1Z0x4cldicjVGSVk1ODlBaVpxUGRVb1J5SFhhcTRlQlJXT3hXMTJKRjlCUWdCLzVBZXBsYStzeDcwdXNBdTdDZk52RjVzSEhIZkVia2Q2Z2Z3dUw3MThlUUFsQ2RlNEZGWWo2RDIyL0dHelhhMlhtWnAwNkVjVGwvbCtsaGFLT1VaSTkyY1JqTmxqQTBhWlp4bk8rUGQwVXhKMjB5NWpvZ1l6TkYwRzFjSU4wdDBlai92cS9lQkJXei9TRzBDenRNY1B4dTZOM2JsdmlHUDhGc080WWpHQUFTd2VQdnpMajBGL01ESE1Kb09sV1FZTkJBTkhhUVJaaUVhY0RXY25EZ2RSV2dKdi9FOFpGUVJ3OTZBbWo0VjdtQW55YXVHdzJXSTRWcUpEL3lQc1hFSWFTYmM0em0yN2NhWmJwNTIrTmk2YXUyb1l1bW51bmFhbm1VWFBvcFltR3pjSmtoaFVncWprWVpBRVNTQkMzb25teVZUTW95cXZTekJGbFJpSXhFQkdtRUN3Y1RPTDRON1Z6YVkyTXpkNHU0WGUzWE8rcXJ4c2V5YUNpS3ZrbC84NTUzL085OVgzV1NsbHp3NkY4K2NUS0kyMVNsMFVRbGhlZmQ3aVRRTlN3czB4a3lCZFhLOTgxVUZsSkdVWVdvQUJ0S0MrUVBDdzJLWnhPMlhEa2hKYitGOE04RzRnaTE0YnJ6YzJWd2VuN2NqUFYralhuVTdYaSsvdTNidDMvOEhmTVZLUXh1UmZCTWtZaSttWnFabW5yOUYzQlVlVVllay9aYUcyWFgvNEFOSUVIaCt1ZTZ2b1FUZTEydDY2TCtjcENCY2dqaGJhWjRnWGMxbWpvTGFWT2I3ZVJHRmY1ZVpCQjl1TzkzejM1QVJkVS9PVWZ3OXhzaEpQWlcrYUFLTlI4UVlrR0M0Smh0dWlHQ2pqREpYQmNSMjhNUHRxbnc1ZVVrb3k2UHJGOXNmdklJdmZyL0dVQnR3UjJ6OTZDR0RzNG8zdzl2S1BMeDg4UWhxeU5MNnNqVnVGNUJzU0pETlRVN1BQWDRWeHdDUHZwUi9idmJPaDdsbXYvL3UvNnc4UUtMMGVtcHg1VmR5ZHRzMnJnM2tQMCtMQk9FTmhoSytRQ2MxVGlsOXB2bDduVzV6STdxbHdVVVNuMzROSU9RZmZjSHpTaWRqQWx5T01PaGFMaWpsT1lGejZaQmhiTW93OEtxUEdWUnNjTDVRT2NuYTlWckV0cjVvc0dLR1YxdXhlcTFYRHc4b0d6MWNBQzE4Ky84OXBzQXYzN3Y4VmpjbCs4aVFKUXhJR3dKaDYvUGpKczFmNWROZ0hOT1RwdUtYLy9JM05abEQzZXJZUGYreWlRRlpCR1p0R0c4UUlrNHh2cjZ4Wm9rbG9ZQ3NjaUxyVDVRdEJKYVdsK1dxZHIvRlFLSjBLekFoVUFpcmxTZmJ3c0hqUzJYRXNVU3NCQ1VaV3JPeklNT3hYbmVJSWpNczBnY0hlVkx3NWUyTDkwK1gyc201SjNxcGlraS9mR1p6UDFjOFpHOGdpNGN1SDNuNDMvZWdiSW8wSGNxRGNIU21UbndXSkpBeUFNZmNtUktkeHhTRGdHSWNoVDNkMjlaQTZEUWFTTU5RSmN3M0NJbUkzd3Zlc0tlOWt6cHZzNGVGRmtlVlM2OVJ5aUs5WHdTU2RkemxQZ0V4MkZ1eWx6Z25rZ094cHh4elFVcFRUazhFd3lZNHBBeE9vQkdOWjE1TmhpTm4zTnRMUktMU0RmVHNtMHdKNXhOZTBPZ29EY094YUhNNm9MMDJIZm53NThlMjNFbzIveVFYMkRoaVRja2ZTRDVLQk1BREc0NmR2a2trNmhON0w2WUNPK3ZhVEJXb05tUWhqSWRObzFhNVNDMlROTSs0QVdDNXRZcWZUQnVOUTQwV1JjVkVyNWFQemFnWmRRcVBsTmkyak50YjhmUFdNUDJUYmtqSVNNb3l4bkRFR0k0UTVBMDBYd2xDdURjNitWUFczUEpwdUtRT2Z1b0UyMkpXbWsrbDMweE1UQU9PUkpBM1pia3orR1l5aE1HUVlrRFRTN3IxUW5vaGpuWno4T0FyRG9ER1NHU2hhSE5XcVpZOW5PK2dBOW5PK2VEREg4Q2R0OU5PTkd6NjNEWTFKNVFiWXRNNVBXY0c5UlVZNytWaEQ1R3FnakgwOWFDbHhRR0JBRkpTY2cycFN6SEJTQWxVUzA0WGxocXNlTTNSY3ZiWTBzb1kwd3FJUFEyTTBxbTBXUnlCaEQ0ZjIzT2tYM3orY0lEUUdPZlRyTzUybzdEMWxGbjFoRUJoUFp1ZGVoNU1IZmpxTk9FQWNVcFFNWVF6MlFNS1BhanNJZGJXR1RvTXY3WmhqWE9hMGlUQ2FWZDdkbzdaU3JIZ0tZY05WMit5Rk96Ni9USzJFcjhRaTE4cFUrUlMwcmlzSW85NnFjZlV6d1U1R1hKWmtoZ3lKU0duZHBwYnNIN3NON0ZQUFJmN0luTFl0aml0amNPOE0yUkNBTTlrTnZTTVJ0THZ5OUY2RS91SGRTeG1HbkVQdmhrRlFmRFdTUGNkaGdEUkNTYk9IRHFYejRMOFM2M3BTckc3QmtNenY1cG90eldIYmppV1ZZelBOZGpXTHRxcGFiUUdNWGw3by9ydUNIZjdwYVpFdjVHM1VTazQ0TC9KOHNja25jUjFFZ25ISXRSc1hkQS8rc2VpS1ZicGNsdVhwSHJqUFJjWFdBZGVzQU53YXoyWTdQS2huU2J2MkJXWGdNYTJhWFVjaWFuZVZRM1RFNjArLy9mN2g5RU9FY1VzYVgwM2VxUXU1Yng5RWlRVGp5Wk81NXorRVUrWWRQOEVCQnN4aDJaVXM2RzFsYUl5YnlpMlBQTlhoV3gwMms0RnFjdGc2Ym9zdFdybEliUlU2N1hZV1IzWHQweTUzNVErRnpHeVZiVlZFMW90S0lEN2pGRHFiWmp0NzVmWTU3ZWtJZTh6V01pS2YzdFpSaWsxWGhHT3hOVU8zbitsMlNuSHFDOHJBc21JMTZCMkJxQ3VjVDlNcGN5RVZmdnY5MU1UMHc0Y0RHQU5wM0lZeDVqMC9nekU3Ty9jbTdFcVZkbEp1eElIQmd1cVFxOG1JTXZDWGNqTjhCYmFUekhWYTBwQ3lsbTJMSE9PakZKUTJ4M1JQcS9qVnN0V1RHeGJudVpWempxOTMrWndHWWVpVG5BZ3VySmF0QWlLbUVPTTd4U3pmS29xQ2o5SkJCeC81clh1R1BUNkhJOVp1aHQ2Z3RQTjNLZ08wQVIxYXd1Y3E1ME8wMitPTmVjSS92WnVhbWU3REdIb040a09IZ1RJNVlqR0dLV01rVEFERzAyZHZuRDUvTEJieEozT1lTVjMyUk54aVUwdlBFNnRIbEtIUkxLZzJraGU4aklMTUtyTm5UYkYxa1ROUTI5Q1pwc0JtMVRuczByT05lck54Zkp3bC9RVjh5Zmo2TlgvUi9RL2FiZTY0VWNHeEI3U2wvRm1YQmRjQnl0QzRXMksxaXg0Y2xmY2JFelpSd3hOeis4b3dtVlR6cXMyTnJYZ2k2Z3VYMHpsNnp5ekUvRDc3dTM4QmkrbXhwREdhUTJVZS9ZVHhPWXd4R3ErQ2RyYzNWa0FjSUk0eTR0alMyN0N3YXRSRFpXaXNScE0yUUNlVDdyMlBWekZFMHVsMHUxMU9jTzh1NjVTZzlXQUJ2dnQybHNSOU5nT3ZMRnNSK1lKTEpRMUNIYVdPV0sxZ01jYk9BeVRBOFN5Z2NsMVN1TnBTQnNsQnEzUDE4YU0vNlQ0SVdiU0t0VEVZWk4xLzA3aEIvR2E0bkUvbmtxbWRHRk5JMm45Q0ZqTW9qSWtKb294QmRiMEZZM0lJUTBvWmQ4Q1luZnZIcTBTUUxqQ3hIWStFSTB5U2g5Nm1sbUdRWW9JcmE2dWIrSTQwdTNGZmFNL01rTTl6VkNnYmw1ZHhIWW1hdDhkYTV6K2ZuTE04Q1gyZUs5WkZUc2ozOTM1ZXBobitwbDBoZWFGMjBZTFUwT2gyaE53Q3BWTW9kWlN6ZEhIaFRZVmNBYjBhcnpYVURzOGJsOWZUNExmVnRoV0krbHdTQ24vRUt3amVrTlArYm5acVJvb1NZcnR1d1JpV2xENkxyMlZoeURCdVMyUHUyUnU3czV5S0NZelpJNlVPTWpVUE9DQmNyS3ZTWEVtK3ExTkYzdUhscXNFU3Q2ZHBkNUlPeDFjVkNyS010RXpOKzd4ODUrYjBwRjF2bkowMXpzVnVoemU3VFAzVkFwMEphS0NXSUVTeVhVa2RIcGQxa2NLakhpbGJPUlIyN0dwVVdyS2FyMUJxMTRZSDBjTmZDeVkxTVZqMkFZcUNjTVM0ZmZIODg2ZFR0MkRjUnhnRDQvV25NTzZReGl6UXlDZGNTUy9EeEx3SEEzWDRvaGd1dXhzR2VibVZiTkVndTZXWEZPQXdsVmI5dXVYVEVueEtlYlYxZVVVWmpBaXNlRk90NG4zT1lqSEx2STlxUjliUlBvVVBZdGxNc1pqcGtpaTZpdVJ3UnFiRC9Wd0tyVW1sSkJlNkx1TEJka3F5Y1Z6ZSs3aGdNb0xWUk51TkpEQnRwdlpMd3BHd2t3dkczejVIWFJBV3c5SjZGNHpKeWM5Z0VKL1JwekUxa0FabzQvV0xhQ0w5UGlZSUpmT0JIK1dCK3hWOGVPc2M2a050SFZ4b01kaXRNcTlkd25jOVBBWVRuSlBDa0M4Y1FTNGhLNFRDZTVkMWZNVlZaNDBtOTJPTUlEQXhzeWNVTkNnV3lVZkhCeXFVT3BERDZFWnBBZ05lODV0cXpCTjJuOHNGTE5LQVlpOVNZSTZPWW43WGV2VFZzeWVQcHo2TGtqdGd5Q3dHRS9GQm5JeEpRNmJ4OU5sekVFYzA1Q25CT3kzczc4bUZsb1NMTTc0RjVzT2d0aHJKQlNmOWl4aEJJTXIvZDNjMkwyMXVXeGcvMXEvRWo2ckI0RUFjT1Fsa2NDV1dPeEh1SFo0NmNhS0lzUlFKb2tHTlVwUVFRU0htd3hpVGFDQnFRSklnT0t2L3c1MlYvajFuZW1kM3JiVy8xbjQvWXRQVG5sUHV5bWxQdFpxNmYzbWVaNi85dnZ0OVkyQVFEWWlIUHk0cmplSkQ3cUhjYUdhT1ZqODZOeVQ4NS93VXRKNHB3WFArZC9zajN1Vk83WlZHR0dMUGp0Z3VCNEMyVjdkUUVwZllYUUVJNFk5YzZ1Ymw1ZVdwM0N6VjNzMy9JelNtV0VoaHVHRVFEVDhZRmcydERZalJoVWkybEcxVW54NEJSK3ErZkVmeVFIMEFEK2pVejA5MlFTRmJiRk1YYmV2aXlsaCtUMGtKUzRiYnd6L2VDOVd2dSsvemFHNzRLRzY4dnZ4SlNJSnQ5ZHYrZmZWZzR5U3hnN01vZ0JBazBCK2R4OCtnaXZ0VzdXd3BpaFlaVXk3Und1Z0Zoa2lOZmc1RE9HVm1kbTZoV1RyTHRuSm95SnZVUGZSaExjR0QwaFFQQzZKRTF2WVBWdVU3YlB4dWJYRVRHNWsrcm91OThiUTFvY3NHSHI1VkJUY2tpUFA0eUdON1pSVkNRcHdrcTJVS1l2cTRRbEdrNFNmNytuS1R1OHFjVmFMejRkREV4Smd4aVJKR3J6Q2MwaEJPZ2VTWWp5MFdTb1dyWXVxR2ZGMEZ1N1NNWGZCWUtiMEZIYWdFdXBBdDNOUVVGNXIrcEc2aUxuZmZzRzBZcnAwWjdGMnk1SjVSdkxiZzAyWWNvaks1ZFF3TDg4UWhYbzJvVUZUYVFPSWlsd0lTTHkrUHFZdG1KZ09xbUEwakNhZEpHSXlnTDR3aENjTnBGQ3MzWnNJemMzUFJadjJzMEx3Z3Q5eDAwdmZsQytoTUJaQmFpVTVTSTVSVE1jM3NKL0dld25GMkgzWTJSQTlSQ0l1b2ZTcHl1elR1VkFBMUpPbGRHTmIyZG9uRkxla0NVTFNGSmpvM2dPTHpUZld1WGE5bkl3dUFZc0toaXluQlltQmd3TzR6dkdBUURha05BY05vWTBKckE3d3lGN3ZDemZXdGNocmtBZkdSRnJOTG0rU2hyOVhCWTJJSlVTZTdHd2VybUtZZmVucXZWa3hQM0wrV3hET0VSMkJCNlBLU0szRVF5TUV4QXNGakZkazJicjlJNCt6eDllVXhEYUtvbHlwUlFERWRVaXdtcFM2TVNiUkx1c0tRczZ0TlEybEQ0Z0N2ek0zSElzQy9WbW1VMDA4d0VUNCs1YSsvME1xbFVvQnBZT2ZvZkc4aktkNkJCa1NOTnpZNVZHY1o5amFPdDNDUEtGNmhKQk5SYjVuRk4yWDlJQ1pqU01ldGZUb0poTGRFT1QxRnVvbTlnKzFOaVhNOXZwRzRMV1d4NWE3bVVSS2dpWFN4VmNuVXNoRXd5QXlTWUxwd3NVQmhlTUlJQnNYbUZDME5Nb3J0Rkk1akJ0UUJVUnJOMXV1bFFsdndlRVFlMUtzRERsakdKZU5xRzhyNisvZytaUDVacVZTREtyR0x2T2dNREYzREF6UHlpbmo3czVYVnJiWGRjN29uREVWQ0xRTlZ3OHZrZHM3MzQzaVFnOTRIZkhQbDVMYldiaFR2VTArUGdrU3EySGlHK1hocE1RWlpFWnBnc21EWnlWaElHTUdnVXhtYUJzRVlZTEZCTkRRT204YmN3c0xkY3gydnRyL0M3SUpHNlRNa1NLN1l1S3JVTHMrVHk4WVI4VFc2ZHJCT1BIQndnb3FPbHIwMWJPSlhrbmhUbVBNandGQ25MNFd2TE9CK3B3enVBN2lGem01ck93Nk54ZTRSU0FKQjVKL0FHd1FpZHdmL0p0Z0RTTXpQaE1PaDBJUUhDOHNqaWtVZzZLVU1Kd3pTUnIrMGlrNk9DWU9Ed21NaEdzbldMM0ViWFF0ZkpWVEl6Vk8rV3I2N2VzNUExNFJUeXRiVzJnbTZ1eVNTSDZ0Q3Z4ZGt1M2FTM0k0dnYvK3dlYkJMTi95QS9vbjZCbWdjZE1GSEZmcUdUS0hTYkdFdlFjNTRBWDlDTjl4b1oydWx6UE5pZEFIOGdWSEJaVEZ1TE9MUWhSQ0dnV0Ywd1dFd0dsT0dodHNyVWgvUmR1YjBDSThyVlZxZ0VOeXY5UmxNMHhGZENLMWhxQ09DYW1LMW0rMDJqWTk2dGN2VHhNWW1YbWZ6Zm1YM0VQS3dJUHJJWnZNS3F0VnFOYUR1b0M0dWl1V0hYRFdkNm1DdkxrQjAwZzkzcmVkc3BuUlp5elNKUkJoV1VhR1FiUkhKZ3VjRk40ay9ERXNhaklZV2h5ZU8rWVZZNVBuMEpMbTZrYmpNTmh2RjNIV2VUSU9OU0NlVnJ1YStQSlRMeGVKRjhRSUtCb1lEYkxXdXhOb1hBbVlQQWdPK2w0NU5BWVFXRGg4R1g0VGhmOG5sN3F2VjYzUXEzOEdnaGhuajYxZkVjSTFyWnhBRXFMSmVlSTdFZ0FTaUNJVnNGSUtGTXkrTVN3SUJGcUFjaHBTR29zRzBJWEZNdW5Cd2ZjVGVMWlVTRVArSm5iTWFUSGQzeFlkcU9vOERJQ2lQTnpkUG5VNG5uMCtsMDlmVmF2VStCMnNUNEhOSDJnRUhVTGZRdU1PWEg0WVBvMC9sWWZ4UE4yQThlZ2JTQXMxYXVZc1dVSUFNb2Z0dUxTMUdZMElUSVh3NDAwSzBGL1k4MGhVR28wR3pxeTBPb3FFbldRdkh0TUl4Q3p3SVNDUzdzNU1RdDlHN0ZlZHVSTjZyZXNSTWdYcDZrbWhTcWZRMUZMejQxMmtCZ0FoZzlueldFRjZrSzY3TERYRGt5UUZtN1I2c1U0MGtvTFJCSkFyTlF2ZGFPaTlZZkFhOCt3d2ZHbVpXa2NraGNZUUVEbTBYb1E5MFRDeTYrRnc2UGQ4NDJGNyt0TDEvY25pTHMwMjVtdW9JbWJ5WTRlRURmK3RTRkQvNTlQMERKSEpwNStRZ1RwZFdiSy9WbHlLb2lEa2dRVUZob2JBdDR1RVIyWEQ1d0RBelNwK0Y0NDBsanZGeG5xU0tSOWp3VUVnV0FFaTdkTG03TFhhSmZ6ZzRnbGZ4Q2t6dzVaN3NyMTk5VWVaUDhtUFNUaWVQY1lPdGZ2TVpraVd4dHJuK2NYMzVlUC84OWwvdkFNVGM3S3pDUUNCWWx5VlY0YktJbmxPSGhyeGhhQnJ5RUEvaGNNNHFVMHdjSEFmbklZR1FZd1FSY00xUzdlUjQrOE8vMTVkWDE4N3BSQjhkZk1Gd3VNTXdoWXpFUkczUXJFRVRScGsrQlZIU2tLc2R2S29XR3E1RDJwVlZFbnBBWjJCSmQwd3pFaVlzbEVNc0ZvTnVGc1BEWnYvME1INW8wNUE0QmoxeHNJbkZnMGVZS1lSY014K0wvZlBkdS9aU3BvYWJybkVKZDRZTlZRbWJEbXk4U25RWWRTT1pQTjZGWnV2czdFejhwU3BxT1o0WEZ5T1JhRFNHR0VBUHN3S0RrWVJsRDkxYVNCSm1hZVppRVRBc3JKUE9BYXNSSFZMWllkWnRhbDZ4Mnc3bUYwUEVjbzMwRFdRSmhrazBHb2tzTGk0dXRiUFpwVXkyVUQrRHhqS3h0cnFNNjlOUEt4dTRWL01VYUJTeVM5Q1dhQVFMa0ExekloMVVUWWN0Y3poSVNIK0lzTkNyMUVHNUlCa0ttbTZMeThJTnhFSEQzWFM0c3RRV2lDRXlJMlV5T3lPTWcxTEJuZ1JxQVNzR1ZZNWVBSndsVVhMME1Id2FQeFFob0pKZ05RWVhDWmtVNDNxeEx2ekJIV0wxV2tIZm5UdE9kVWdhZlZvYnJPc3dFNjNnd1IwamlNaFpSc3RFeXlVczdTTXpoV3FlNktpYW8vSGpReEdRTXNCbjQySEpyTUUwWVZKVCs4TnVMdm9zV1h3YkRKTWNLa24xTVIvaVlicFNDWVFwUkxsRy9lZzBEQU5rUm5sSTBLRVB3dUlEVjAzTC82YW43VW5ES1FndENZYUNpY0xaYVBVTXd4SUhuMWxzZVFBUWNveU9rQW1iQ0RXRlRpenFseGx5MlA1TU9Hd2hDRTJMMXRMNGdvZUVBS0duajM0V0ZiWkJiSXYwQk1ORWgrQXhhUG9PenNOTU1Fb2lrNVpJaUlvRXcvWFN2VUtxdFE2SmJ6WlBOaWIxb0RNQ1g0NFJtNFRMSDdybk5Mb0k5Z2lENFhDMlljb3UvZjFhSWN3enlqVk1Kb0xLaEJwY3Q1cFEvNXZRK2Nnb2FEMllqSkFjMVB6QlVaaUcwOFhpVlJqRERoaVNoclB2RUYzNnFJNFBRMlJjRWhFempXSXlaalBoY0t5SFZ4a0dITU9rN1F3TGhHa3JPQW9IaTBDWEN3dXNSalFZY05QZ002MmVYSVJBTkpJUmZKQnF4eVVVTmR1b2g0RWpIbG81WTJMWTVxR0hQNGJmYmpQUWdoaFJGTVRrWVpLQ3RWaW0remFITDJpQTNXRllQRHh3Y0xjSUhnd0k0cEE5Q0hlTk1jNms1dkpxVFhJUlRQS1FCQXFLd3dqWGc1YkVLQ2VoUTVPekNBWlkrVjl5WWk5VExMY0UzZXF3QktKblhKMGlrZ2lUQ2VxRXRPTEE0MTNqVGdiakkzWStNQktqbzA0U0EzNGtIQ3k2WHFuSFlUaHdtTlpqY05ETXRpN0hXRWhNdUlvSjJJRGhkSVNieHBrSlhBQWNHS2FZTlRRRjkvVGh3Y0ZpOGRyMUpnNGNIcE50bjhIaE1veURpTW5XL2hHcnhpV2NjZGZvaFJFc0JFd0tpb0t5eHR0UkM0VWpNNGRjSFpaZHIxK3pONnlXTHY0NFpHZkt1akhMTVNaV0paUitxM0IwSS83VmIvMlpBSEF0S0FxMk5kNG80em9pMDRPRVdwY052NllMSHFWdWlYaE10bGFFcU5kbjFNbkVJWk1lYXFwZklYQkRNSW93VFNZL2NxTlJlSkVZN3YzK0dhd0N6aVd0cXptMWdEQWlCZ21PU1hIQllickhMcEZOR1R0b0NEWUl5eGlhQkFzS0c4VDNEUCsxeXhvZHg5R0g3QVFaR0hBaGNZZUpWb3I4NDF2K01GL3c5dTJVV3dnOEtHMXIyS3B3NWNTUGd1QksxcUFIRFphb25BbW40dEFKakJJZm8rNlgvZTJvL0ZzMWZBc0FoMkN2TzN3WEg0RWZwd2kvYWNhZEhvYUluMDVHZTYwM2ZoekU4dys2T2t4MjdqVFl3NlR4WjJFRVBMcFRBdEpIUDZFSEZScU1jM0NPb2JvKzRTNkx1QWNKeHlRNi9KTmcrRGJzZHFMMmVRakZIby92UUY4YnU5TVZqclMwTTVQUElMLzk4UEtZWER5QnVMVFNOK2pMeFQzd0xpRG91UlFBYnhMc2NQZFBKT0VOdzkyMSt6Sng2MFZZcW12MXVjcCtjcmNnREF5YUFIOGFqTmNUSk5nVml6ZWNydVg1RE01L0tPRHN0ZFhwb0IvYVcvVFdwUWE5eXgrSUE0MkwxamR3Y0M4Ni9pb0MzbzRKK0ZVUGNQenI5ZEZ6REg4UERHZXo3Zy9GbDBqdys4b1h4SGV1T1g1bWlBeC9xMEIrRElsaGZQd0s0L2VHMGMwNHZiTUpCSDJmU092eDE0UGg0WnZYTXVWN3l2dWYrTzBYTGZmUDlpZkorQTViZitMWGhmR05SMFYrQUl6L2l4cnVvZjdxbisxL0NFNU9wN1A4SzNRQUFBQUFTVVZPUks1Q1lJST0iIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIwLjUiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTI4OS40MzM3NSwyMzUuMDExMDljMCwwIC0xMi43NDUwOSwtNi4wODk1MyAtMTIuNzQ1MDksLTEzLjAyNDY3YzAsLTQuMDA0ODMgMTEuNzY0NywtMjIuNDIxNjkgMTEuNzY0NywtMjIuNDIxNjl2LTc0LjE3NDUyaDY0Ljg5NjA0djc4Ljg1Nzk4YzAsMCA5LjU1ODgzLDkuNDUxMzYgOS41NTg4MywxNC4yMTU2OGMwLDQuOTg5MzkgLTkuNTU4ODMsMTUuMDc2NjMgLTkuNTU4ODMsMTUuMDc2NjNjMCwwIC0xNy41MzEzMiw4LjM4NDQ1IC0yNS44MTA2NSw4LjU3NDk0Yy0xMS43NzE0NCwwLjI3MDg0IC0zOC4xMDUsLTcuMTA0MzUgLTM4LjEwNSwtNy4xMDQzNXoiIGZpbGwtb3BhY2l0eT0iMC41MDE5NiIgZmlsbD0iI2Y1NTQ0MiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjAiIHN0cm9rZS1saW5lY2FwPSJidXR0Ii8+PHBhdGggZD0iTTMzNS44ODA2MSwxNDguMDA0NzJsLTQxLjcwOTM2LDY5LjAxNTQ5IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMTIiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPjxwYXRoIGQ9Ik0zMjEuNjE4NzcsMTQ0Ljk0MDY4bDI0LjIzMjg0LC0xMy41OTdsLTAuMzQxMDYsMjcuNzg0NzJ6IiBmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMCIgc3Ryb2tlLWxpbmVjYXA9ImJ1dHQiLz48L2c+PC9nPjwvc3ZnPjwhLS1yb3RhdGlvbkNlbnRlcjo3MC4wODgwMDAwMDAwMDAxNDo3MC4wODgtLT4=";
  const goldenRatio = (1 + Math.sqrt(5)) / 2;
  const sqrt3 = Math.sqrt(3);
  const gammaConstant = 0.57721566490153286060651209008240243104215933593992;

  const runtime = vm.runtime;

  function cast_to_array(array) {
    let object = null;
    try {
      object = JSON.parse(array);
      if (!(object.constructor === [].constructor)) {
        object = [];
      }
    } catch {
      object = [];
    }

    return object;
  }
  function cast_to_object(str_object) {
    let object = null;
    try {
      object = JSON.parse(str_object);
      if (!(object.constructor === {}.constructor)) {
        object = {};
      }
    } catch {
      object = {};
    }

    return object;
  }
  function cast_to_vector(array,length=null) {
    array = cast_to_array(array);
    let vector = [];
    for (let i = 0; i < array.length; i++) {
      vector.push(Scratch.Cast.toNumber(stringify(array[i])));
    }
    if (!(length === null)) {
      vector = vector.slice(0,length);
      for (let i = vector.length; i < length; i++) {
        vector.push(0);
      }
    }
    return vector;
  }
  function mod(a,b) {
    return ((a % b) + b) % b;
  }
  function json_stringify_censor(key, value) {
    if (value === Infinity) {
      return 'Infinity';
    } else if (value === -Infinity) {
      return '-Infinity';
    } else if (Number.isNaN(value)) {
      return 0;
    } else {
      return value;
    }
  }
  function stringify(json_object) {
    if (json_object === undefined) {
      return 'undefined';
    } else if (json_object === null) {
      return 'null';
    } else if (json_object.constructor === [].constructor || json_object.constructor === {}.constructor) {
      return JSON.stringify(json_object,json_stringify_censor);
    } else {
      return json_object.toString();
    }
  }
  function convert_angle_units(angle,from_unit,to_unit,relative=false) {
    let degrees_units = ['Scratch degrees','trig degrees'];
    let radians_units = ['Scratch radians','trig radians'];
    let full_circle_units = ['Scratch full circle','trig full circle'];
    let scratch_units = ['Scratch degrees','Scratch radians','Scratch full circle'];

    // convert angle to degrees
    let degrees = null;
    if (degrees_units.includes(from_unit)) {
      degrees = angle;
    } else if (radians_units.includes(from_unit)) {
      degrees = angle * (180 / Math.PI);
    } else if (full_circle_units.includes(from_unit)) {
      degrees = angle * 360;
    } else {
      return 0;
    }

    // convert degrees into trig degrees
    if (scratch_units.includes(from_unit)) {
      if (relative) {
        degrees = -degrees;
      } else {
        degrees = 90 - degrees;
      }
    }

    // convert trig degrees to scratch/trig degrees depending on to_unit
    if (scratch_units.includes(to_unit)) {
      if (relative) {
        degrees = -degrees;
      } else {
        degrees = 90 - degrees;
      }
    }

    // mod degrees
    if (scratch_units.includes(to_unit)) {
      degrees = 180 - mod((180 - degrees),360);
    } else {
      degrees = mod(degrees,360);
    }

    // convert degrees to degrees/radians/full circle depending on to_unit
    let newAngle = null;
    if (degrees_units.includes(to_unit)) {
      newAngle = degrees;
    } else if (radians_units.includes(to_unit)) {
      newAngle = degrees * (Math.PI / 180);
    } else if (full_circle_units.includes(to_unit)) {
      newAngle = degrees / 360;
    } else {
      return 0;
    }

    return newAngle;
  }
  function stage_width() {
    return Scratch.renderer.canvas.width;
  }
  function stage_height() {
    return Scratch.renderer.canvas.height;
  }
  function convert_coordinate_units(xy,from_unit,to_unit) {
    let width = stage_width();
    let height = stage_height();
    if (from_unit == 'Scratch coords' && to_unit == 'JS coords') {
      return [xy[0] + width/2, height - (xy[1] + height/2)];
    } else if (from_unit == 'JS coords' && to_unit == 'Scratch coords') {
      return [xy[0] - width/2, -((xy[1] - height) + height/2)];
    } else if (from_unit == to_unit) {
      return xy;
    } else {
      return [0,0];
    }
  }
  function var_id_from_name(variable_name,util) { // copied from SharkPool
    //support for all variable types (Cloud, Sprite-Only, Global)
    variable_name = Scratch.Cast.toString(variable_name);
    const cloudID = runtime.getTargetForStage().lookupVariableByNameAndType(Scratch.Cast.toString(" " + variable_name), "");
    if (cloudID) return cloudID.id;
    let varFind = "";
    for (const name of Object.getOwnPropertyNames(util.target.variables)) {
      varFind = util.target.variables[name].name;
      if (varFind === variable_name) return util.target.variables[name].id;
    }
    const ID = runtime.getTargetForStage().lookupVariableByNameAndType(variable_name, "");
    if (!ID) return "";
    return ID.id;
  }
  function var_name_exists(variable_name,util) {
    return Scratch.Cast.toBoolean(var_id_from_name(variable_name,util));
  }
  function get_var(variable_name,util) {
    if (!var_name_exists(variable_name,util)) { return 'undefined'; }
    let variable = util.target.lookupOrCreateVariable(variable_name,variable_name);
    return variable.value;
  }
  function set_var(variable_name,value,util) {
    if (!var_name_exists(variable_name,util)) { return; }
    let variable = util.target.lookupOrCreateVariable(variable_name,variable_name);
    variable.value = value;
    if (variable.isCloud) { // added from TurboWarp's Scratch 3 code
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, value]);
    }
  }
  // get list for variables menus; from SharkPool's extension (see top for credits)
  function get_variables_for_menu() {
    const globalVars = Object.values(vm.runtime.getTargetForStage().variables).filter((x) => x.type == "");
    const localVars = Object.values(vm.editingTarget.variables).filter((x) => x.type == "");
    const uniqueVars = [...new Set([...globalVars, ...localVars])];
    if (uniqueVars.length === 0) return ["(choose a variable)"];
    return uniqueVars.map((i) => (Scratch.Cast.toString(i.name)));
  }
  function bulk_math(array,operation) {
    if (operation == 'min') {
      return Math.min(...array);
    } else if (operation == 'max') {
      return Math.max(...array);
    } else if (operation == 'sum') {
      let sum = 0;
      for (let i = 0; i < array.length; i++) {
        sum += array[i];
      }
      return sum;
    } else if (operation == 'product') {
      let product = 1;
      for (let i = 0; i < array.length; i++) {
        product *= array[i];
      }
      return product;
    } else if (operation == 'average') {
      let sum = 0;
      for (let i = 0; i < array.length; i++) {
        sum += array[i];
      }
      return sum / array.length;
    } else {
      return 0;
    }
  }
  function get_illion(n) {
    n = Math.round(n); // ensure integer

    // skip all logic and say "thousand" if n is 0
    if (n <= 0) {
      return 'thousand';
    }

    // convert n into a base-1000 number with its digits in "sections" from most significant to least significant (in other words splitting 1234567 into 1,234,567 where you would write commas)
    let sections = [];
    let place_value = 1;
    while (n >= place_value) {
      sections.push(mod(Math.floor(n / place_value), 1000));
      place_value *= 1000;
    }

    // call "get_illion_short" for each base-1000 "digit" and combine them into one string
    let str = '';
    for (let i = 0; i < sections.length; i++) {
      str += get_illion_short(sections[i]);
    }

    // add the final "-on" to finish "illion"
    str += 'on';

    return str;
  }
  function get_illion_short(n) {
    // See this for more info about the algorithm: https://en.wikipedia.org/wiki/Names_of_large_numbers#Extensions_of_the_standard_dictionary_numbers

    // return one of the basic 10 illions if n < 10
    if (n < 10) {
      let small_illions = ['nilli','milli','billi','trilli','quadrilli','quintilli','sextilli','septilli','octilli','nonilli'];
      return small_illions[n];
    }

    // get each component of the illion
    let possible_ones = ['','un','duo','tre','quattuor','quin','se','septe','octo','nove'];
    let possible_tens = ['','deci','viginti','triginta','quadraginta','quinquaginta','sexaginta','septuaginta','octoginta','nonaginta'];
    let possible_hundreds = ['','centi','ducenti','trecenti','quadringenti','quingenti','sescenti','septingenti','octingenti','nongenti'];
    let ones_num = mod(n, 10);
    let ones = possible_ones[ones_num];
    let tens_num = mod(Math.floor(n / 10), 10);
    let tens = possible_tens[tens_num];
    let hundreds_num = Math.floor(n / 100);
    let hundreds = possible_hundreds[hundreds_num];

    // apply marks to the ones component
    let markable = ['tre','se','septe','nove'];
    if (markable.includes(ones)) {
      // find marks that need to be applied
      let marks = {
        '':[],'un':[],'duo':[],'tre':[],'quattuor':[],'quin':[],'se':[],'septe':[],'octo':[],'nove':[],
        'deci':['N'],'viginti':['M','S'],'triginta':['N','S'],'quadraginta':['N','S'],'quinquaginta':['N','S'],'sexaginta':['N'],'septuaginta':['N'],'octoginta':['M','X'],'nonaginta':[],
        'centi':['NX'],'ducenti':['N'],'trecenti':['N','S'],'quadringenti':['N','S'],'quingenti':['N','S'],'sescenti':['N'],'septingenti':['N'],'octingenti':['M','X'],'nongenti':[]
      };
      let applied_marks = marks[tens];
      if (tens == '') {
        applied_marks = marks[hundreds];
      }

      // apply them
      if (applied_marks.includes('S')) {
        if (ones == 'tre') { ones = 'tres'; }
        if (ones == 'se') { ones = 'ses'; }
      }
      if (applied_marks.includes('X')) {
        if (ones == 'tre') { ones = 'tres'; }
        if (ones == 'se') { ones = 'sex'; }
      }
      if (applied_marks.includes('M')) {
        if (ones == 'septe') { ones = 'septem'; }
        if (ones == 'nove') { ones = 'novem'; }
      }
      if (applied_marks.includes('N')) {
        if (ones == 'septe') { ones = 'septen'; }
        if (ones == 'nove') { ones = 'noven'; }
      }
    }

    // add "illi" at the end of names such as "quadraginta" that don't have it already
    // the only ones that would already have "illi" at the end are covered by "small_illions" at the start of the function
    let str = ones + tens + hundreds;
    str = str.slice(0, -1) + 'illi';

    return str;
  }
  function get_abbreviated_illion(n) {
    let abbreviated_illions = ['k','m','b','t','qa','qi','sx','sp','o','n','d','ud','dd','td','qad','qid','sxd','spd','od','nd','v','uv','dv','tv','qav','qiv','sxv','spv','ov','nv','tg','utg','dtg','ttg','qatg','qitg','sxtg','sptg','otg','ntg','qag','uqag','dqag','tqag','qaqag','qiqag','sxqag','spqag','oqag','nqag','qig'];
    if (n >= abbreviated_illions.length) {
      return '10^' + (3 * n + 3);
    }
    return abbreviated_illions[n];
  }

  // ######  ##  ##  ######  ######  ##    ##  ######  ######  ######  ##    ##      ######  ##      ######  ######  ######
  // ##      ##  ##    ##    ##      ####  ##  ##        ##    ##  ##  ####  ##      ##      ##      ##  ##  ##      ##
  // ####      ##      ##    ####    ##  ####  ######    ##    ##  ##  ##  ####      ##      ##      ######  ######  ######
  // ##      ##  ##    ##    ##      ##    ##      ##    ##    ##  ##  ##    ##      ##      ##      ##  ##      ##      ##
  // ######  ##  ##    ##    ######  ##    ##  ######  ######  ######  ##    ##      ######  ######  ##  ##  ######  ######

  class SoupUtilsVectors {
    getInfo() {
      return {
        id: 'souputilsvectors',
        name: 'Soup Vectors',
        color1: '#f55442',
        color2: '#b83527',
        color3: '#edbbad',
        menuIconURI: vector_menu_icon,
        blockIconURI: vector_icon,

        // BLOCKS -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        blocks: [
          {
            opcode: 'tovector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["0","0"]'
              }
            }
          },
          {
            opcode: 'twovectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'threevectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },

          '---',

          {
            opcode: 'twovectorfromangle',
            blockType: Scratch.BlockType.REPORTER,
            text: 'unit vector with angle [ANGLE] [UNIT]',
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              }
            }
          },
          {
            opcode: 'twovectorfromangleandmagnitude',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector with angle [ANGLE] [UNIT] and magnitude [MAGNITUDE]',
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              },
              MAGNITUDE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              }
            }
          },
          {
            opcode: 'twovectorfromslope',
            blockType: Scratch.BlockType.REPORTER,
            text: 'unit vector with slope [SLOPE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              }
            }
          },
          {
            opcode: 'twovectorfromslopeandmagnitude',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector with slope [SLOPE] and magnitude [MAGNITUDE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              MAGNITUDE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              }
            }
          },

          '---',

          {
            opcode: 'xofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'x of [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              }
            }
          },
          {
            opcode: 'yofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'y of [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              }
            }
          },
          {
            opcode: 'zofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'z of [VECTOR]',
            hideFromPalette: true,
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0,0]'
              }
            }
          },
          {
            opcode: 'coordfromvector',
            blockType: Scratch.BlockType.REPORTER,
            text: '[COORD] of [VECTOR]',
            arguments: {
              COORD: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDS_MENU',
                defaultValue: 'z'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0,0]'
              }
            }
          },
          {
            opcode: 'dirofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'direction in [UNIT] of [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              }
            }
          },
          {
            opcode: 'magnitudeofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'magnitude of [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              }
            }
          },
          {
            opcode: 'slopeofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'slope of [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,2]'
              }
            }
          },

          '---',

          {
            opcode: 'setcoordofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'set [COORD] of vector [VECTOR] to [VALUE]',
            arguments: {
              COORD: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDS_MENU'
              },
              VALUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              }
            }
          },
          {
            opcode: 'setdirofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'set direction of vector [VECTOR] to [ANGLE] [UNIT]',
            arguments: {
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,1]'
              }
            }
          },
          {
            opcode: 'setmagnitudeofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'set magnitude of vector [VECTOR] to [MAGNITUDE]',
            arguments: {
              MAGNITUDE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,1]'
              }
            }
          },
          {
            opcode: 'setslopeofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'set slope of vector [VECTOR] to [SLOPE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              }
            }
          },

          '---',

          {
            opcode: 'stagesizevector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'stage [MODE]',
            disableMonitor: true,
            arguments: {
              MODE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'STAGE_SIZE_MODES_MENU'
              }
            }
          },
          {
            opcode: 'currentposvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'position on stage as vector [UNIT]',
            filter: [Scratch.TargetType.SPRITE],
            disableMonitor: true,
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDINATE_UNITS_MENU'
              }
            }
          },
          {
            opcode: 'currentdirvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'direction as unit vector',
            filter: [Scratch.TargetType.SPRITE],
            disableMonitor: true,
            arguments: {}
          },
          {
            opcode: 'gotovector',
            blockType: Scratch.BlockType.COMMAND,
            text: 'go to vector [VECTOR] [UNIT]',
            filter: [Scratch.TargetType.SPRITE],
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDINATE_UNITS_MENU'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              }
            }
          },
          {
            opcode: 'setdirtovector',
            blockType: Scratch.BlockType.COMMAND,
            text: 'point in direction of vector [VECTOR]',
            filter: [Scratch.TargetType.SPRITE],
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              }
            }
          },

          '---',

          {
            opcode: 'vectoroperations',
            blockType: Scratch.BlockType.REPORTER,
            text: '[OPERATION] vectors [VECTORA] and [VECTORB]',
            arguments: {
              VECTORA: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              },
              VECTORB: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,1]'
              },
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VECTOR_OPERATIONS_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'rotatevector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'rotate vector [VECTOR] by [ANGLE] [UNIT]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              }
            }
          },
          {
            opcode: 'scalemagnitudeofvector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'scale vector [VECTOR] by [FACTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              },
              FACTOR: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '2'
              }
            }
          },
          {
            opcode: 'normalizevector',
            blockType: Scratch.BlockType.REPORTER,
            text: 'normalize vector [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[1,0]'
              }
            }
          },

          '---',

          {
            opcode: 'convertangleunits',
            blockType: Scratch.BlockType.REPORTER,
            text: 'convert [ANGLE] from [FROMUNIT] to [TOUNIT]',
            arguments: {
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '60'
              },
              FROMUNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              TOUNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU',
                defaultValue: 'trig radians'
              }
            }
          },
          {
            opcode: 'convertcoordinateunits',
            blockType: Scratch.BlockType.REPORTER,
            text: 'convert [VECTOR] from [FROMUNIT] to [TOUNIT]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,0]'
              },
              FROMUNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDINATE_UNITS_MENU'
              },
              TOUNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDINATE_UNITS_MENU',
                defaultValue: 'JS coords'
              }
            }
          },

          { blockType: Scratch.BlockType.LABEL, text: "Soup Vectors - Variables" },

          {
            opcode: 'vartovector',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [VECTOR]',
            arguments: {
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '["0","0"]'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'twovectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'threevectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'twovectorvarfromangle',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to unit vector with angle [ANGLE] [UNIT]',
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'twovectorvarfromangleandmagnitude',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector with angle [ANGLE] [UNIT] and magnitude [MAGNITUDE]',
            arguments: {
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              },
              MAGNITUDE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'twovectorvarfromslope',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to unit vector with slope [SLOPE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'twovectorvarfromslopeandmagnitude',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector with slope [SLOPE] and magnitude [MAGNITUDE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              MAGNITUDE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'xofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'x of var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'yofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'y of var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'zofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'z of var [VARIABLE]',
            hideFromPalette: true,
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'coordfromvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: '[COORD] of var [VARIABLE]',
            arguments: {
              COORD: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDS_MENU',
                defaultValue: 'z'
              },
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'dirofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'direction in [UNIT] of var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              }
            }
          },
          {
            opcode: 'magnitudeofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'magnitude of var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'slopeofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'slope of var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'setcoordofvectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [COORD] of vector var [VARIABLE] to [VALUE]',
            arguments: {
              COORD: {
                type: Scratch.ArgumentType.STRING,
                menu: 'COORDS_MENU'
              },
              VALUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'setdirofvectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set direction of vector var [VARIABLE] to [ANGLE] [UNIT]',
            arguments: {
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '90'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'setmagnitudeofvectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set magnitude of vector var [VARIABLE] to [VALUE]',
            arguments: {
              VALUE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'setslopeofvectorvar',
            blockType: Scratch.BlockType.REPORTER,
            text: 'set slope of vector var [VARIABLE] to [SLOPE]',
            arguments: {
              SLOPE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '1'
              },
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'vectorvaroperations',
            blockType: Scratch.BlockType.COMMAND,
            text: '[OPERATION] var [VARIABLE] and vector [VECTOR]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              VECTOR: {
                type: Scratch.ArgumentType.STRING,
                defaultValue: '[0,1]'
              },
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VECTOR_OPERATIONS_MENU'
              }
            }
          },
          {
            opcode: 'twovectorvaroperations',
            blockType: Scratch.BlockType.COMMAND,
            text: '[OPERATION] vars [VARIABLEA] and [VARIABLEB]',
            arguments: {
              VARIABLEA: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              VARIABLEB: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              OPERATION: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VECTOR_OPERATIONS_MENU'
              }
            }
          },

          '---',

          {
            opcode: 'rotatevectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'rotate vector var [VARIABLE] by [ANGLE] [UNIT]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              UNIT: {
                type: Scratch.ArgumentType.STRING,
                menu: 'ANGLE_UNITS_MENU'
              },
              ANGLE: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '45'
              }
            }
          },
          {
            opcode: 'scalemagnitudeofvectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'scale vector var [VARIABLE] by [FACTOR]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              },
              FACTOR: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '2'
              }
            }
          },
          {
            opcode: 'normalizevectorvar',
            blockType: Scratch.BlockType.COMMAND,
            text: 'normalize vector var [VARIABLE]',
            arguments: {
              VARIABLE: {
                type: Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },

          { blockType: Scratch.BlockType.LABEL, text: "Soup Vectors - Higher Dimensions" },

          {
            opcode: 'fourvectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z], [W]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'fivevectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z], [W], [V]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'sixvectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z], [W], [V], [U]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'sevenvectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z], [W], [V], [U], [T]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              T: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },
          {
            opcode: 'eightvectorfromcoords',
            blockType: Scratch.BlockType.REPORTER,
            text: 'vector [X], [Y], [Z], [W], [V], [U], [T], [S]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              T: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              S: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              }
            }
          },

          '---',

          {
            opcode: 'fourvectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z], [W]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'fivevectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z], [W], [V]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'sixvectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z], [W], [V], [U]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'sevenvectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z], [W], [V], [U], [T]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              T: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          },
          {
            opcode: 'eightvectorvarfromcoords',
            blockType: Scratch.BlockType.COMMAND,
            text: 'set [VARIABLE] to vector [X], [Y], [Z], [W], [V], [U], [T], [S]',
            arguments: {
              X: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Y: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              Z: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              W: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              V: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              U: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              T: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              S: {
                type: Scratch.ArgumentType.NUMBER,
                defaultValue: '0'
              },
              VARIABLE: {
                type:Scratch.ArgumentType.STRING,
                menu: 'VARIABLES_MENU'
              }
            }
          }
        ],
        menus: {
          ANGLE_UNITS_MENU: {
            acceptReporters: true,
            items: ['Scratch degrees','Scratch radians','Scratch full circle','trig degrees','trig radians','trig full circle']
          },
          COORDINATE_UNITS_MENU: {
            acceptReporters: true,
            items: ['Scratch coords','JS coords']
          },
          VECTOR_OPERATIONS_MENU: {
            acceptReporters: true,
            items: ['add','subtract','dot product of','cross product of','multiply','divide','add Scratch rotation of','subtract Scratch rotation of','add trig rotation of','subtract trig rotation of','add magnitude of','subtract magnitude of']
          },
          VARIABLES_MENU: {
            acceptReporters: true,
            items: 'getvariables'
          },
          STAGE_SIZE_MODES_MENU: {
            acceptReporters: true,
            items: ['size','width','height']
          },
          COORDS_MENU: {
            acceptReporters: true,
            items: ['x', 'y', 'z', 'w', 'v', 'u', 't', 's']
          }
        }
      };
    }

    // CODE -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    getvariables() {
      return get_variables_for_menu();
    }

    // variable category helper funcs
    run_in_place(func,args,util) { // run a reporter function against a variable and assign the new value
      set_var(args.VARIABLE, func({VECTOR: get_var(args.VARIABLE,util), ...args}), util);
    }
    run_against_var(func,args,util) { // run a reporter function against a variable and return the value
      return func({VECTOR: get_var(args.VARIABLE,util), ...args});
    }

    tovector(args) {
      return stringify(cast_to_vector(args.VECTOR));
    }
    vartovector(args,util) {
      set_var(args.VARIABLE, this.tovector(args), util);
    }
    twovectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      return stringify(vector);
    }
    twovectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.twovectorfromcoords(args), util);
    }
    threevectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      return stringify(vector);
    }
    threevectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.threevectorfromcoords(args), util);
    }
    twovectorfromangle(args) {
      let angle = Scratch.Cast.toNumber(args.ANGLE);
      angle = convert_angle_units(angle,args.UNIT,'trig radians');
      let vector = [Math.cos(angle),Math.sin(angle)];
      return stringify(vector);
    }
    twovectorvarfromangle(args,util) {
      set_var(args.VARIABLE, this.twovectorfromangle(args), util);
    }
    twovectorfromangleandmagnitude(args) {
      let angle = Scratch.Cast.toNumber(args.ANGLE);
      let magnitude = Scratch.Cast.toNumber(args.MAGNITUDE);
      angle = convert_angle_units(angle,args.UNIT,'trig radians');
      let vector = [magnitude*Math.cos(angle),magnitude*Math.sin(angle)];
      return stringify(vector);
    }
    twovectorvarfromangleandmagnitude(args,util) {
      set_var(args.VARIABLE, this.twovectorfromangleandmagnitude(args), util);
    }
    twovectorfromslope(args) {
      let slope = Scratch.Cast.toNumber(args.SLOPE);
      let normalization_factor = Math.sqrt(slope*slope+1);
      let vector = [1/normalization_factor,slope/normalization_factor];
      return stringify(vector);
    }
    twovectorvarfromslope(args,util) {
      set_var(args.VARIABLE, this.twovectorfromslope(args), util);
    }
    twovectorfromslopeandmagnitude(args) {
      let slope = Scratch.Cast.toNumber(args.SLOPE);
      let magnitude = Scratch.Cast.toNumber(args.MAGNITUDE);
      let normalization_factor = Math.sqrt(slope*slope+1);
      let vector = [magnitude/normalization_factor,(magnitude*slope)/normalization_factor];
      return stringify(vector);
    }
    twovectorvarfromslopeandmagnitude(args,util) {
      set_var(args.VARIABLE, this.twovectorfromslopeandmagnitude(args), util);
    }
    xofvector(args) {
      let vector = cast_to_vector(args.VECTOR,1);
      return vector[0];
    }
    xofvectorvar(args,util) { return this.run_against_var(this.xofvector,args,util); }
    yofvector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      return vector[1];
    }
    yofvectorvar(args,util) { return this.run_against_var(this.yofvector,args,util); }
    zofvector(args) {
      let vector = cast_to_vector(args.VECTOR,3);
      return vector[2];
    }
    zofvectorvar(args,util) { return this.run_against_var(this.zofvector,args,util); }
    coordfromvector(args) {
      let index = Scratch.Cast.toNumber(args.COORD);
      if (args.COORD == 'x') {
        index = 1;
      } else if (args.COORD == 'y') {
        index = 2;
      } else if (args.COORD == 'z') {
        index = 3;
      } else if (args.COORD == 'w') {
        index = 4;
      } else if (args.COORD == 'v') {
        index = 5;
      } else if (args.COORD == 'u') {
        index = 6;
      } else if (args.COORD == 't') {
        index = 7;
      } else if (args.COORD == 's') {
        index = 8;
      }
      index = Math.round(index);
      if (index < 1) {
        return 0;
      }
      let vector = cast_to_vector(args.VECTOR);
      if (vector.length < index) {
        return 0;
      }
      return vector[index-1];
    }
    coordfromvectorvar(args,util) { return this.run_against_var(this.coordfromvector,args,util); }
    setcoordofvector(args) {
      let vector = cast_to_vector(args.VECTOR);
      let value = Scratch.Cast.toNumber(args.VALUE);
      let index = Scratch.Cast.toNumber(args.COORD);
      if (args.COORD == 'x') {
        index = 1;
      } else if (args.COORD == 'y') {
        index = 2;
      } else if (args.COORD == 'z') {
        index = 3;
      } else if (args.COORD == 'w') {
        index = 4;
      } else if (args.COORD == 'v') {
        index = 5;
      } else if (args.COORD == 'u') {
        index = 6;
      } else if (args.COORD == 't') {
        index = 7;
      } else if (args.COORD == 's') {
        index = 8;
      }
      index = Math.round(index);
      if (index < 1) {
        return stringify(vector);
      }
      if (vector.length < index) {
        return stringify(vector);
      }
      vector[index-1] = value;
      return stringify(vector);
    }
    setcoordofvectorvar(args,util) { this.run_in_place(this.setcoordofvector,args,util); }
    setdirofvector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      let angle = Scratch.Cast.toNumber(args.ANGLE);
      angle = convert_angle_units(angle,args.UNIT,'trig radians');
      let magnitude = Math.sqrt((vector[0] * vector[0]) + (vector[1] * vector[1]));
      let new_vector = [magnitude*Math.cos(angle),magnitude*Math.sin(angle)];
      return stringify(new_vector);
    }
    setdirofvectorvar(args,util) { this.run_in_place(this.setdirofvector,args,util); }
    setmagnitudeofvector(args) {
      let vector = cast_to_vector(args.VECTOR);
      let new_magnitude = Scratch.Cast.toNumber(args.MAGNITUDE);
      let magnitude = 0;
      for (let i = 0; i < vector.length; i++) {
        magnitude += vector[i] * vector[i];
      }
      magnitude = Math.sqrt(magnitude);
      if (magnitude == 0) {
        if (vector.length > 0) {
          vector[0] = new_magnitude;
          for (let i = 1; i < vector.length; i++) {
            vector[i] = 0;
          }
        }
      } else { 
        for (let i = 0; i < vector.length; i++) {
          vector[i] /= magnitude;
          vector[i] *= new_magnitude;
        }
      }
      return stringify(vector);
    }
    setmagnitudeofvectorvar(args,util) { this.run_in_place(this.setmagnitudeofvector,args,util); }
    setslopeofvector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      let slope = Scratch.Cast.toNumber(args.SLOPE);
      let magnitude = Math.sqrt((vector[0] * vector[0]) + (vector[1] * vector[1]));
      let normalization_factor = Math.sqrt(slope*slope+1);
      let new_vector = [magnitude/normalization_factor,(magnitude*slope)/normalization_factor];
      return stringify(new_vector);
    }
    setslopeofvectorvar(args,util) { this.run_in_place(this.setslopeofvector,args,util); }
    currentposvector(args,util) {
      let vector = [util.target.x,util.target.y];
      return stringify(convert_coordinate_units(vector,'Scratch coords',args.UNIT));
    }
    currentdirvector(args,util) {
      let angle = convert_angle_units(util.target.direction,'Scratch degrees','trig radians');
      let vector = [Math.cos(angle),Math.sin(angle)];
      return stringify(vector);
    }
    gotovector(args,util) {
      let vector = cast_to_vector(args.VECTOR,2);
      vector = convert_coordinate_units(vector,args.UNIT,'Scratch coords');
      util.target.setXY(vector[0],vector[1]);
    }
    setdirtovector(args,util) {
      let vector = cast_to_vector(args.VECTOR,2);
      let angle = Math.atan2(vector[1],vector[0]);
      angle = convert_angle_units(angle,'trig radians','Scratch degrees');
      util.target.setDirection(angle);
    }
    vectoroperations(args) {
      let vector1 = cast_to_vector(args.VECTORA);
      let vector2 = cast_to_vector(args.VECTORB,vector1.length);
      let vector = [];
      let operation = args.OPERATION;
      if (operation == 'add') {
        for (let i = 0; i < vector1.length; i++) { vector.push(vector1[i] + vector2[i]); }
      } else if (operation == 'subtract') {
        for (let i = 0; i < vector1.length; i++) { vector.push(vector1[i] - vector2[i]); }
      } else if (operation == 'multiply') {
        for (let i = 0; i < vector1.length; i++) { vector.push(vector1[i] * vector2[i]); }
      } else if (operation == 'divide') {
        for (let i = 0; i < vector1.length; i++) { vector.push(vector1[i] / vector2[i]); }
      } else if (operation == 'dot product of') {
        let sum = 0;
        for (let i = 0; i < vector1.length; i++) { sum += vector1[i] * vector2[i]; }
        return sum;
      } else if (operation == 'cross product of') {
        vector1 = cast_to_vector(args.VECTORA, 3);
        vector2 = cast_to_vector(args.VECTORB, 3);
        vector.push(
            vector1[1] * vector2[2] - vector1[2] * vector2[1],
            vector1[2] * vector2[0] - vector1[0] * vector2[2],
            vector1[0] * vector2[1] - vector1[1] * vector2[0]
        );
      } else if (operation == 'add Scratch rotation of' || operation == 'subtract Scratch rotation of' || operation == 'add trig rotation of' || operation == 'subtract trig rotation of') {
        vector1 = cast_to_vector(args.VECTORA,2); // require both to be 2D vectors
        vector2 = cast_to_vector(args.VECTORB,2);
        let angle = null;
        if (operation == 'add Scratch rotation of') {
          angle = Math.atan2(vector1[1],vector1[0]) + (Math.atan2(vector2[1],vector2[0]) - Math.PI/2);
        } else if (operation == 'subtract Scratch rotation of') {
          angle = Math.atan2(vector1[1],vector1[0]) - (Math.atan2(vector2[1],vector2[0]) - Math.PI/2);
        } else if (operation == 'add trig rotation of') {
          angle = Math.atan2(vector1[1],vector1[0]) + Math.atan2(vector2[1],vector2[0]);
        } else {
          angle = Math.atan2(vector1[1],vector1[0]) - Math.atan2(vector2[1],vector2[0]);
        }
        let magnitude = Math.sqrt((vector1[0] * vector1[0]) + (vector1[1] * vector1[1]));
        vector.push(magnitude*Math.cos(angle)); vector.push(magnitude*Math.sin(angle));
      } else if (operation == 'add magnitude of' || operation == 'subtract magnitude of') {
        vector2 = cast_to_vector(args.VECTORB); // remove requirement that both lengths must be the same
        let magnitude1 = 0;
        for (let i = 0; i < vector1.length; i++) {
          magnitude1 += vector1[i] * vector1[i];
        }
        let magnitude2 = 0;
        for (let i = 0; i < vector2.length; i++) {
          magnitude2 += vector2[i] * vector2[i];
        }
        magnitude1 = Math.sqrt(magnitude1);
        magnitude2 = Math.sqrt(magnitude2);
        let angle = Math.atan2(vector1[1],vector1[0]);
        let magnitude = null;
        if (operation == 'add magnitude of') {
          magnitude = magnitude1 + magnitude2;
        } else {
          magnitude = magnitude1 - magnitude2;
        }
        vector.push(magnitude*Math.cos(angle)); vector.push(magnitude*Math.sin(angle));
      }
      return stringify(vector);
    }
    vectorvaroperations(args,util) {
      set_var(args.VARIABLE, this.vectoroperations({VECTORA: get_var(args.VARIABLE, util), VECTORB: args.VECTOR, OPERATION: args.OPERATION}), util);
    }
    twovectorvaroperations(args,util) {
      set_var(args.VARIABLEA, this.vectoroperations({VECTORA: get_var(args.VARIABLEA, util), VECTORB: get_var(args.VARIABLEB, util), OPERATION: args.OPERATION}), util);
    }
    dirofvector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      let angle = Math.atan2(vector[1],vector[0]);
      angle = convert_angle_units(angle,'trig radians',args.UNIT);
      return angle;
    }
    dirofvectorvar(args,util) { return this.run_against_var(this.dirofvector,args,util); }
    magnitudeofvector(args) {
      let vector = cast_to_vector(args.VECTOR);
      let sum = 0;
      for (let i = 0; i < vector.length; i++) {
        sum += vector[i] * vector[i];
      }
      return Math.sqrt(sum);
    }
    magnitudeofvectorvar(args,util) { return this.run_against_var(this.magnitudeofvector,args,util); }
    slopeofvector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      if (vector[0] == 0 && vector[1] == 0) {
        return 0;
      }
      return vector[1] / vector[0];
    }
    slopeofvectorvar(args,util) { return this.run_against_var(this.slopeofvector,args,util); }
    rotatevector(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      let angle = Scratch.Cast.toNumber(args.ANGLE);
      angle = convert_angle_units(angle,args.UNIT,'trig radians',true);
      let old_angle = Math.atan2(vector[1],vector[0]);
      let magnitude = Math.sqrt((vector[0] * vector[0]) + (vector[1] * vector[1]));
      let new_angle = old_angle + angle;
      let new_vector = [magnitude*Math.cos(new_angle),magnitude*Math.sin(new_angle)];
      return stringify(new_vector);
    }
    rotatevectorvar(args,util) { this.run_in_place(this.rotatevector,args,util); }
    scalemagnitudeofvector(args) {
      let vector = cast_to_vector(args.VECTOR);
      let factor = Scratch.Cast.toNumber(args.FACTOR);
      for (let i = 0; i < vector.length; i++) {
        vector[i] *= factor;
      }
      return stringify(vector);
    }
    scalemagnitudeofvectorvar(args,util) { this.run_in_place(this.scalemagnitudeofvector,args,util); }
    normalizevector(args) {
      let vector = cast_to_vector(args.VECTOR);
      let magnitude = 0;
      for (let i = 0; i < vector.length; i++) {
        magnitude += vector[i] * vector[i];
      }
      magnitude = Math.sqrt(magnitude);
      for (let i = 0; i < vector.length; i++) {
        vector[i] /= magnitude;
      }
      return stringify(vector);
    }
    normalizevectorvar(args,util) { this.run_in_place(this.normalizevector,args,util); }
    convertangleunits(args) {
      let angle = Scratch.Cast.toNumber(args.ANGLE);
      let from_unit = args.FROMUNIT;
      let to_unit = args.TOUNIT;
      
      return convert_angle_units(angle,from_unit,to_unit);
    }
    convertcoordinateunits(args) {
      let vector = cast_to_vector(args.VECTOR,2);
      let from_unit = args.FROMUNIT;
      let to_unit = args.TOUNIT;

      return stringify(convert_coordinate_units(vector,from_unit,to_unit));
    }
    stagesizevector(args) {
      if (args.MODE == 'size') {
        return stringify([stage_width(),stage_height()]);
      } else if (args.MODE == 'width') {
        return stage_width();
      } else if (args.MODE == 'height') {
        return stage_height();
      } else {
        return 0;
      }
    }
    fourvectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      vector.push(Scratch.Cast.toNumber(args.W));
      return stringify(vector);
    }
    fourvectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.fourvectorfromcoords(args), util);
    }
    fivevectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      vector.push(Scratch.Cast.toNumber(args.W));
      vector.push(Scratch.Cast.toNumber(args.V));
      return stringify(vector);
    }
    fivevectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.fivevectorfromcoords(args), util);
    }
    sixvectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      vector.push(Scratch.Cast.toNumber(args.W));
      vector.push(Scratch.Cast.toNumber(args.V));
      vector.push(Scratch.Cast.toNumber(args.U));
      return stringify(vector);
    }
    sixvectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.sixvectorfromcoords(args), util);
    }
    sevenvectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      vector.push(Scratch.Cast.toNumber(args.W));
      vector.push(Scratch.Cast.toNumber(args.V));
      vector.push(Scratch.Cast.toNumber(args.U));
      vector.push(Scratch.Cast.toNumber(args.T));
      return stringify(vector);
    }
    sevenvectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.sevenvectorfromcoords(args), util);
    }
    eightvectorfromcoords(args) {
      let vector = [];
      vector.push(Scratch.Cast.toNumber(args.X));
      vector.push(Scratch.Cast.toNumber(args.Y));
      vector.push(Scratch.Cast.toNumber(args.Z));
      vector.push(Scratch.Cast.toNumber(args.W));
      vector.push(Scratch.Cast.toNumber(args.V));
      vector.push(Scratch.Cast.toNumber(args.U));
      vector.push(Scratch.Cast.toNumber(args.T));
      vector.push(Scratch.Cast.toNumber(args.S));
      return stringify(vector);
    }
    eightvectorvarfromcoords(args,util) {
      set_var(args.VARIABLE, this.eightvectorfromcoords(args), util);
    }
  }

  // load extension
  Scratch.extensions.register(new SoupUtilsVectors());
})(Scratch);
